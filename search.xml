<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F09%2F03%2FFeatureExtraction%2F</url>
    <content type="text"><![CDATA[Principal Component Analysis** : 主成分分析形象理解如图，下面是一张3d的图片，从不同的方向投影出来的二维图，可以看出右往左投影的含有更多信息。 如图，下面是一个高斯分布，二维点往两个正交的方向投影，长轴含有的信息更多。 PCA的过程示意Step 1 : 去中心。中心在坐标轴在（0,0)，均值在坐标轴原点 Step 2 : Remove correlation(去除相关性) 通过坐标变化，坐标旋转，矩阵作用 数学推导目标：变换后的矩阵，对角非零，非对角线全为零。S(Y)有非零的对角元素，所有非对角元素都是零 理论推导 PCA Examples PCA bias]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F09%2F03%2F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%2FFeatureExtraction%2F</url>
    <content type="text"><![CDATA[Principal Component Analysis** : 主成分分析形象理解如图，下面是一张3d的图片，从不同的方向投影出来的二维图，可以看出右往左投影的含有更多信息。 如图，下面是一个高斯分布，二维点往两个正交的方向投影，长轴含有的信息更多。 PCA的过程示意Step 1 : 去中心。中心在坐标轴在（0,0)，均值在坐标轴原点 Step 2 : Remove correlation(去除相关性) 通过坐标变化，坐标旋转，矩阵作用 数学推导目标：变换后的矩阵，对角非零，非对角线全为零。S(Y)有非零的对角元素，所有非对角元素都是零 理论推导 PCA Examples PCA bias]]></content>
  </entry>
  <entry>
    <title><![CDATA[心路历程]]></title>
    <url>%2F2020%2F09%2F03%2Frecording%20of%20master%2FMyMain%2F</url>
    <content type="text"><![CDATA[From 2019-09-31 to 2019-11-10过完了研一的第一个十周，内心很空虚，极度的空虚，不知道怎么回事？我觉得原因是：自己对自己的要求太高了，要求自己做的事情太多了？结果什么都没有做好。 对于自己的建设，我尝试了很多的东西，化妆和打扮。我觉得我还没有漂亮的资本，没钱，没房。所以一定要非常的努力才行。我只希望我最爱的人，配得上我，我希望我们是共同奋斗的状态了，而不是依靠。所以尽量不化妆出门，除了重要场合。 对于学习方面，了解了高铁背景，还是没有进入状态，所以要更努力才行。最近的课程太多了，平衡啊！我心有余而力不足的。还有一定要会说，不好说。接下来一定要马力十足的出发。 对于人，可能这里只是三年的一段时光，很好相处就好了，最重要的是男朋友和室友。 对不起，我还有奋斗，我要奋斗，我要奋斗。还有健身。 我的时间都分散在其他视频的事情上了，杜绝啊！每天最多两小时。尽量不玩手机了！！！！]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之数据分析职责]]></title>
    <url>%2F2020%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%81%8C%E8%B4%A3%2F</url>
    <content type="text"><![CDATA[技术+业务 业务+技术，至少懂这些 术业有专攻，知识要广泛，是职业发展的基本准则。特别对数据分析师这样一个多面手型角色。那么我们应该了解到什么程度呢？这里有个建议： 业务方向分析师：数据采集方式、数据字段格式、指标的计算口径与更新时间这三个是必须必须知道的。因为这三点涉及到数据真实性与可靠性。没有数据质量做保证，什么分析都是空谈。对基础数量越了解，越能从细节中找到思路；算法模型的种类与应用场景是必须了解的。因为这涉及到如何选择分析方法，如何提升分析质量。具体代码怎么写，弄懂就懂。 技术方向分析师：业务部门分工、职责、流程必须要了解。至少职责清晰，知道自己要对接的人到底是干什么。自己对应部门常见的业务需求，如销售分析、经营分析、促销分析、商品管理的方法要有所了解。在面对业务部门需求的时候，大概知道他们在想什么，有什么套路。帮助自己更好的理解需求，规避需求大坑。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>职位要求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语Daily]]></title>
    <url>%2F2020%2F08%2F25%2F%E8%8B%B1%E8%AF%ADDaily%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据分析技能]]></title>
    <url>%2F2020%2F08%2F25%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[https://ask.hellobi.com/blog/qinlu/sitemap/ SQL 学会直接把别人的知识装进自己的脑子里https://www.zhihu.com/xen/market/personal-works-all/houziliaorenwu?zh_hide_tab_bar=true LeetCode &amp; NowCoderhttps://leetcode.com/problemset/database/ https://www.nowcoder.com/ta/sql 关系型数据库MySQL数据类型主要提供了三种类型，分别是文本，数字和日期。 MySQL 数据类型在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。 Text 类型： 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 Number 类型： 数据类型 描述 TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。 SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。 MEDIUMINT(size) -8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。 INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。 BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。 FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。 * 这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。 Date 类型： 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 * 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 Day Ox00 入门：https://www.w3school.com.cn/sql/sql_syntax.asp 通过SQL使得数据操作员有能力查询，修改数据库。 WhatSQL：结构化查询语言。SQL对大小写不敏感。 SQL语句后面的分号？有些数据库系统要求每条SQL命令的末端使用分号，来表示语句的结束。 分类： 数据操作语言（DML) 这部分包括查询和更新指令。 SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 数据定义语言 (DDL) 这部分包括创建和删除表格，还有定义索引(键)，规定表之间的链接，和表间的约束。 SQL 中最重要的 DDL 语句: ​ CREATE DATABASE - 创建新数据库 ​ ALTER DATABASE - 修改数据库 ​ CREATE TABLE - 创建新表 ​ ALTER TABLE - 变更（改变）数据库表 ​ DROP TABLE - 删除表 ​ CREATE INDEX - 创建索引（搜索键） ​ DROP INDEX - 删除索引 Day Ox00 简单查询：SELECT : 查询语句不带条件查询语句 123SELECT 列名称1, 列名称2 FROM 表名称SELECT * FROM 表名称SELECT DISTINCT 列名称 FROM 表名称 //去除重复值 有条件查询语句 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 WHERE 过滤单条记录 12345678910操作符 描述= 等于&lt;&gt; 不等于&gt; 大于&lt; 小于&gt;= 大于等于&lt;= 小于等于BETWEEN 在某个范围内LIKE 搜索某种模式注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。 WHERE 过滤两个以上的条件记录 AND / OR]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析实战项目]]></title>
    <url>%2F2020%2F08%2F25%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[研二の学习]]></title>
    <url>%2F2020%2F08%2F15%2F%E7%A0%94%E4%BA%8C%E3%81%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[记录日常，日常留念。 闭关修炼，修炼成金刚不坏之身！ 立下Flag, 三个月后，看看自己，努力😀😀 清单😀😀 what how 日志 公众号、博客、CSDN、Github 主要输出 搬砖+项目 主要输入 数据分析+新经济 8:00~11:20 2h 14:10-17:20 3h 19:00-22:00 3h 每天 每天的规划；每天半小时瑜伽（哑铃)； 接下来有意义的事情，转过去转过来又回到最初的起点： 1. @可视化。封装一下matplotlib修改一些默认参数。主要就是修改字体，字号，主题，背景。 2. @填充简历。a)基本信息 b) 项目经历(三四个吧) c)实习经历 d) 知识技能(要进一步补充)。较弱的地方:落地的项目(好想好想实习)；英语啊； 3. @研究生完满的结束。毕业设计每章对应发一篇文章吧（产业)。加油，加油！这半年要做完，再找数据 4. @英语。新概念英语二和新概念英语三天天学习喔 5. @刻意练习。如果狠不下心，那就每时每刻的刻意，每时每刻的殚精竭虑 6. @公文写作。嗯嗯嗯。刻意的训练自己 每天追踪公众号文章。 猴子数据分析。 20200903 终于考完了啊高高兴兴，认认真真搞科研了！ 这个月把高铁重新更新一下 这个月把时间序列跑出来结果 这个月可视化资料弄一下 这个月 必修环节 6400006003 学术活动 研究生院 0 1 春与秋 其他 考查 是 必修环节 6400006009 论文开题报告及文献阅读综述II 研究生院 0 1 春与秋 其他 考查 是 实践教学环节：还有五个学分。 实践教学环节6个学分中，基地实践必须完成2-4个学分，按照实践时间1-3个月、4-6个月、7-12个月及以上作为实践时间单位，分别认定为2学分、3学分和4学分。要求提交实践总结报告，实践基地（单位）就学生提交的报告给予相关支撑书面材料证明，根据实际实践时间，经导师审核通过，可获得2-4个学分。实践教学课程主要指突出实践训练的实验课程，全校可通选，完成者取得相应学分。 3个学分(实习)+学位论文写作规范(2)个学分 虽然我很喜欢天天睡大觉，躺在床上睡觉。但是呢？好好工作，规律的生活作息，这还是我的追求。 虽然在成为那个独特的自己的时候，会走很多的弯路，然后才知道怎么样的自己适合自己。什么的东西是应该丢掉的。 修炼，修炼，修炼 不能再吃外卖了！ 20200902 复习今天复习软件安全性分析 20200901 复习今天早上复习背诵 今天下午敢报告 今天晚上Android漏洞，哎，虽然写过android apk,但是安全问题好难啊 2020082020-831 复习+玩耍今天早上复习软件安全性分析 今天下午和鹏哥出去看电影了 今天晚上复习软件安全性分析 20200830 复习ing今天继续软件安全性分析（无聊，低效率) 决定晚上把报告完成了 突然想看论文了，我发现是的的确确爱上社会经济学的东西了，糟了啊。感觉要断送多年去互联网公司的梦想了（其实自己学的也不好)，是不是要去体制内工作了啊！感觉去体制内工作要混个博士学位才行啊。看了实验室博士毕业的条件和奖励规则，突然发现读博好难啊！(主要是我想3-4年达标啊）。那我断不断送去互联网工作的想法啊？？？？？ 按照硕士要求干？ 1**）博士生四年时间应该有一个比较好的研究规划。博士大论文一般只需要6-7章节，基本上每一学期完成一章节就可以了。博士生第一年，学校安排大家上课。有很多学生在这一年时间里面延续本科生学习习惯，将考试成绩放在第一位上。对于取得好的学习成绩、打好扎实的学科基础，固然有必要， 但博士生第一学年一定不能够只做“小镇读书青年”，除了书本考试，一定要尽可能早点动手开展研究工作。与此同时，我一直觉得博士生第一学年结束时，应该撰写完成博士论文第一章“研究背景和国内外研究进展”95%以上的工作，同时，撰写完成博士论文第二章“实验方法与基本理论”的基本内容。 博士第二学年，努力完成第三、四章的研究内容，并根据研究内容撰写1-2篇中等水准的学术论文。 博士第三学年，完成博士论文第五章、第六章的研究内容，根据研究结果发表2-3篇较高水准的学术论文。 博士第四学年上半年，补充、完善博士论文第二章-第六章研究内容，撰写第七章结论部分。通过对博士研究内容进行系统性总结，发表一篇高水平的学术论文。与此同时，博士生在第四年上半年将自己的博士论文第一稿递交给导师，让其有充足的时间帮助你修改。如果导师发现有不适合的部分，可以抓紧时间进行补充和完善。到第四学年下半年，就是安排送审、准备答辩，还有足够的时间找工作。 如果博士生能够按照上面的这个计划去开展工作，博士期间可以发表5篇以上学术论文，应该都会超过学校的毕业要求，博士不正常毕业是没有理由的。** 突然发现读研读博跟工作性质是差不多的，都是靠自己的本事给老板服务。嗯嗯，就是这种相处模式。 20200829 复习ing今天早上和同学聊天，居然出去实习了 今天晚上和下午复习软件安全性分析（难） 202008028 密码学考试今天早上靠密码学 今天下午收拾博客文章 今天晚上，由于下大雨，回寝室看剧了 20200827 工程伦理今天早上，搜索很多数据分析的资料，感觉业务型数据分析师要接触太多业务（转行的人多啊，大厂能发挥作用)，技术型数据分析师要算法学的很好（我又没有很特别的头脑，项目经历）。但是呢？数据处理，数据建模，数据可视化是干什么都要用到的。还是我本科的水平。但是我还是想跨界啊，果然是爱一行，爱上一行。鱼和熊掌不可兼得啊，要取舍。 https://ask.hellobi.com/blog/qinlu/10261 今天下午，考工程伦理。心塞塞。 今天晚上，看了我在颐和园。历史文物，园林风景太棒了。英语：《breakfast or lunch》。又进一步进行了职业规划； 复习密码学；学习了tableau，果然漂亮啊！ 我想了想，把毕业设计做完了，把时间序列项目做好，把找实习相关准备做好了，看看剧，养养花，这样的研究生多好啊，干嘛要不自己搞的那么累。吃好喝好，时不时给家人买礼物。 啦啦啦啦啦啦啦啦啦啦啦啦啦啦。不要追一匹马，你用追马的时间去种草，待春暖花开时，能吸引一批骏马来供你选择；所以只要自己足够优秀，你就有多大的权力选择自己的喜好。就自己努力的动力啊！ 202007826 Deadline今天早上，复习了全部的密码学。 今天下午，复习了工程伦理的分析题。 今天晚上，学习了数据分析中的逻辑思维，如何精准化产品设计，产业运营。 我已经受够了这样的生活了。尽早实习，有人内推，就看自己了。 @@@@@@@ 我不是一个热脸特冷屁股的人。 20200825 七夕快乐今天早上，起床发现臀部好疼啊 今天下午继续复习密码学 可证明的加密安全性；数字签名安全性相关概念。公钥体制的安全性 今天下午学习了A/B(what，why, how)，用于评估某种产品和设计是否有效的提供了某项指标，进而有助于辅助决策。 无论是公司，同级，普通朋友，男女朋友——利益第一，感情倒数第一。能实现双赢是最好。 论赚钱的重要性，我又不是非你不可。不喜欢的东西，我怎么都不会将就。 20200824 复习ing今天早上在寝室复习控制流完整性 今天下午复习模糊测试，fuzzing，各种细节 今天晚上低效率复习密码学分组密码和基本概念，还可证明安全性，第七章的基本概念，区别公钥密码体制（三种）， 《像鱼》好听 5W2H分析法在数据分析中的应用 期末考试咋回事背诵呢？还是数学好，一个定理做几十道题，这种学科几个点都不一定考 下周，全新全意的看视频，看PPT，打印论文背诵 背诵，完成课程报告。 20200823 复习ing今天早上寝室洗衣服（周末嘛，多睡会) 今天下午继续复习工程伦理，。。。文科。。。还看了我在颐和园等你。我还在想怎么用工程伦理分析生活中的小三。 今天晚上写了工程伦理的课件， 回寝室健身，哑铃到了 偏僻之地，偏僻之地，偏僻之地 刻意的练习！不会什么，就补充什么。团结就是力量 20200822 平淡无奇的生活今天早上低效率的复习了密码学和软件安全性分析，太难记忆了。看剧日常 今天下午复习继续 今天晚上继续复习，啊，为什么那么多要背的东西啊 20200821 无聊的生活昨天晚上睡不好，盖被子太热，不盖又太冷，折腾着睡不着，我的天啊。 今天早上备份资料。 今天下午和晚上继续复习。好心塞啊，太难背了，感觉在考文科啊。下面时间全部复习了。 看下如何通过Python爬取微信公众号上的全部文章 对不起，其实是最没有用的话语了。 为了每天少往返实验室一个来回，我决定早上在寝室学习了，这样还可以在床上躺到7:45，也不打扰室友起床。 20200820 返校记想不到我马上研二了，感觉还是一事无成的样子。得给自己选定方向，快速发展了 20200819 路漫漫其修远兮再不努力，你就生锈了。亲爱的，女孩子。 你见 或者不见我 我就在那里 不悲不喜 你念 或者不念我 情就在那里 不来不去 你爱 或者不爱我 爱就在那里 不增不减 你跟 或者不跟我 我的手就在你手里 不舍不弃 来我的怀里 或者 让我住进你的心里 默然 相爱 寂静 喜欢]]></content>
      <categories>
        <category>学习の历程(Journal of Studying)</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与机器学习之语言篇]]></title>
    <url>%2F2020%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E8%A8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[神经网络Pytorch基础语法常见神经网络的实现线性模型多层感知机CNNLSTMGAN]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习之模型性能]]></title>
    <url>%2F2020%2F08%2F11%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>正则化</tag>
        <tag>交叉验证</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Book-Learning]]></title>
    <url>%2F2020%2F07%2F29%2FBook-Learning%2F</url>
    <content type="text"><![CDATA[分享看书笔记 数据挖掘——概念与技术数据挖掘的概念数据挖掘是从大量数据中提取或挖掘知识。强调：从大量的，未加工的材料中发现少量金块这一过程。 基本过程： 数据清理。(消除噪音或者不一致的数据) 数据集成（多种数据集成可以组合在一起） 数据选择（从数据库中提取与分析任务相关的数据) 数据变换。(数据变换或统一成适合挖掘形式) 数据挖掘(使用智能方法提取数据) 模式评估 知识表示（可视化等手段，展示挖掘的知识) 数据预处理问题：现实中数据极易受噪音数据、遗漏数据和不一致性数据的干扰。 不完整（属性值缺失） 噪音(错误属性值，离群值) 不一致性（编码) 数据清理。包括填写遗漏值，平滑噪音数据，识别、删除局外者，并解决不一致来“清理数据”。脏数据转化为干净数据。 数据集成。不同数据源的数据集成。 数据清洗遗漏值 忽略 人工填写 全局变量 平均值 分组填充 噪音数据噪音是指测量变量的随机误差或偏差。平滑数据。 分箱。存储值被分布到一些箱子中，然后局部平滑。按平均值平滑。按中值平滑。按边界平滑。 聚类。 回归 不一致数据数据集成实体识别。 冗余。 数据变换将数据转换成适用于挖掘的形式 平滑。 聚集。对数据进行汇总和聚集。日、月和年销售额。多粒度数据分析构造数据方 数据泛化。street-&gt;city; age—&gt;young, middle-age,senior 规范化。 属性数据按比例缩放，缩放到特定区间。 属性构造。 最小-最大规范化 v = \frac{v-min}{max-min}(new_max-new_min)+new_minz-score规范化 v = \frac{v-mean}{\delta}数据归约数据方聚集 维归约 数据压缩 数值压缩 概念描述：特征与比较数据挖掘分为两类: 描述式和预测式挖掘。描述式提供数据的有趣的一般性质。建立一个或一组模型，并试图预测新数据集的行为。 描述式数据挖掘称为概念描述。不同的粒度和角度描述数据集。 度量可以根据其所用的聚集函数分成三类： 分布的：一个聚集函数是分布的，如果它能以如下分布方式进行计算：设数据被划分为 n 个集合，函数在每一部分上的计算得到一个聚集值。如果将函数用于 n 个聚集值得到的结果，与将函数用于所有数据得到的结果一样，则该函数可以用分布方式计算。 代数的：ave(); 整体的：rank(),median() 描述性统计度量度量中心趋势平均值 加权算术平均（加权平均) 中位数 分位数 挖掘大型数据库中的关联规则关联规则挖掘发现大量数据中项集的关联或者相关联系。可用于于分类设计，交叉购物和贱卖分析。 购买计算机也趋向于同时购买财务管理软件的关联规则 computer => finanical_management_software\\ [support = 2\%, confidence = 60\%]支持度：有用性。同时购买计算机和财务管理软件。 置信度：确定性。购买计算机的顾客有多少购买财务管理软件。 可最小支持度阙值和最小置信度阙值。 Apriori 算法： 使用候选项集找频繁项集分类和预测分类和预测是数据分析的两种形式，可以用于提取描述重要数据类的模型或预测未来的数据趋势。 分类预测分类标号（类），而预测建立连续值函数模型。 预测的准确率、计算速度、鲁棒性、可规模性和可解释性是评估分类和预测方法的五条标准。 聚类分析数据对象的集合进行分析，但与分类不同的是，聚类分析 (clustering) 属于非监督学习，也就是不知道要划分类是未知的。聚类分析就是要将数据对象分组成为多个类或簇(cluster)。每一个簇中的对象之间具有较高的相似度，而不同簇对象差别较大。常常采用距离作为相异度的衡量。]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向着永恒出发]]></title>
    <url>%2F2020%2F07%2F28%2Fprepare-for-work%2F</url>
    <content type="text"><![CDATA[编程语言的学习 第一周：Python基础知识https://github.com/jackfrued/Python-100-Days/tree/master/Day01-15 Day Ox00 基本的数据结构类型，以及提供的常用方法。 编码的风格和规范性 初识python Python简介 - Python的历史 / Python的优缺点 / Python的应用领域 搭建编程环境 - Windows环境 / Linux环境 / MacOS环境 从终端运行Python程序 - Hello, world / print函数 / 运行程序 使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE 注释 - 注释的作用 / 单行注释 / 多行注释 代码注释风格 12345678910111213141516def func(arg1, arg2): &quot;&quot;&quot;在这里写函数的一句话总结(如: 计算平均值). 这里是具体描述. 参数 ---------- arg1 : int arg1的具体描述 arg2 : int arg2的具体描述 返回值 ------- int 返回值的具体描述 变量的定义 12345678910模块尽量使用小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头函数名一律小写，如有多个单词，用下划线隔开变量名尽量小写, 如有多个单词，用下划线隔开常量采用全大写，如有多个单词，使用下划线隔开 语言元素 程序和进制 - 指令和程序 / 冯诺依曼机 / 二进制和十进制 / 八进制和十六进制 变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换 数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码 运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级 分支结构 分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图 if语句 - 简单的if / if-else结构 / if-elif-else结构 / 嵌套的if 循环结构 循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图 while循环 - 基本结构 / break语句 / continue语句 for循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序 函数和模块的使用 函数的作用 - 代码的坏味道 / 用函数封装功能模块 定义函数 - def语句 / 函数名 / 参数列表 / return语句 / 调用自定义函数 调用函数 - Python内置函数 / 导入模块和函数 函数的参数 - 默认参数 / 可变参数 / 关键字参数 / 命名关键字参数 函数的返回值 - 没有返回值 / 返回单个值 / 返回多个值 作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字 用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块） Lambda表达式 字符串和常用的数据结构这一句非常重要，python提供的数据结构，和内置的方法很实用。 字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法 列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历 像 insert ，remove 或者 sort 方法，只修改列表，没有打印出返回值——它们返回默认值 None 。这是Python中所有可变数据结构的设计原则。 列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找 生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器 元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换 集合基本用法 - 集合和列表的区别 / 创建集合 / 添加元素 / 删除元素 / 清空 集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集 字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空 字典常用操作 - keys()方法 / values()方法 / items()方法 / setdefault()方法 12list(d1.keys())in not in python list 常用方法总结 12345678910111213141516171819201. 创建 1.1 l = [1, 2] 1.2 list = []2. 添加 2.1 末尾增加一个 append 2.2 指定位置增加一个 insert 2.3 增加list extend +3. 查 [start: stop: step]4. 改5. 删 1. pop 2. remove(元素) 3. del 列表6. 排序和反转 reverse(); sort(); sort(reverse = True)7. 属性 len max/min8. 复制 python string 12345678910111213141516171819202122231. 检测 str 是否包含在 mystr中，如果是，返回开始的索引值；否则返回-1。也可以指定在一定的范围内。mystr.find(str, start=0, end=len(mystr))2. 跟find()方法一样，只不过如果str不在 mystr中会报一个异常.mystr.index(str, start=0, end=len(mystr))3. 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.mystr.replace(str1, str2, mystr.count(str1))4. 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串mystr.split(str=&quot; &quot;, 2)5. 删除 mystr 左边的空白字符mystr.lstrip()6. 删除 mystr 字符串末尾的空白字符mystr.rstrip()7. 删除mystr字符串两端的空白字符 Day Ox01定义类12classclass classname(object): __init__是创建对象时进行初始化操作 12345678910111213141516171819202122232425262728 def __init__(self, name, age): self.name = name self.age = age创建实列std = classname(&apos;xiemay&apos;,&apos;24&apos;)私有和公开的属性和函数：用__开头@property 装饰器如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。 # 访问器 - getter方法 @property def age(self): return self._age静态方法和类方法 # 修改器 - setter方法 @age.setter def age(self, age): self._age = age @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b## 继承和多态class person(): class woman(person): super.__init__() 文件操作文件操作基本上没什么问题了 操作模式 具体含义 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 &#39;r&#39; 读取 （默认） &#39;w&#39; 写入（会先截断之前的内容） &#39;x&#39; 写入，如果文件已经存在会产生异常 &#39;a&#39; 追加，将内容写入到已有文件的末尾 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新（既可以读又可以写） r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 12with open(filename, moder, encoding) as f1: for line in f1: 读取方法按字节12fileObject.read([count]); 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 单独一行123456readline()方法f.readline() 会从文件中读取单独的一行。换行符为 &apos;\n&apos;。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。with open() as f1: while True: lines = f.readline() if lines: 全部行12345readlines()方法 f.readlines() 将以列表的形式返回该文件中包含的所有行，列表中的一项表示文件的一行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。with open() as f1: lines = f1.readlines() json 文件读取12345678910json模块主要有四个比较重要的函数，分别是：dump - 将Python对象按照JSON格式序列化到文件中dumps - 将Python对象处理成JSON格式的字符串 infor = json.dumps(neww) f.write(infor+&apos;\n&apos;)load - 将文件中的JSON数据反序列化成对象loads - 将字符串的内容反序列化成Python对象 b = json.loads(lines) excel单独操作excel的库 创建/打开(对象)，定位(sheet)，定位行列, 保存 就是这几个方法 xlrd12345678910111213141516171819202122232425262728293031323334353637383940### 导入 xlrd 库import xlrd### 打开刚才我们写入的 test_w.xls 文件wb = xlrd.open_workbook(&quot;test_w.xls&quot;)### 获取并打印 sheet 数量print( &quot;sheet 数量:&quot;, wb.nsheets)### 获取并打印 sheet 名称print( &quot;sheet 名称:&quot;, wb.sheet_names())### 根据 sheet 索引获取内容sh1 = wb.sheet_by_index(0)### 或者### 也可根据 sheet 名称获取内容### sh = wb.sheet_by_name(&apos;成绩&apos;)### 获取并打印该 sheet 行数和列数print( u&quot;sheet %s 共 %d 行 %d 列&quot; % (sh1.name, sh1.nrows, sh1.ncols))### 获取并打印某个单元格的值print( &quot;第一行第二列的值为:&quot;, sh1.cell_value(0, 1))### 获取整行或整列的值rows = sh1.row_values(0) # 获取第一行内容cols = sh1.col_values(1) # 获取第二列内容### 打印获取的行列值print( &quot;第一行的值为:&quot;, rows)print( &quot;第二列的值为:&quot;, cols)### 获取单元格内容的数据类型print( &quot;第二行第一列的值类型为:&quot;, sh1.cell(1, 0).ctype)### 遍历所有表单内容for sh in wb.sheets(): for r in range(sh.nrows): # 输出指定行 print( sh.row(r)) xlwt123456789101112131415161718192021222324252627### excel_w.py### 导入 xlwt 库import xlwt### 创建 xls 文件对象wb = xlwt.Workbook()### 新增两个表单页sh1 = wb.add_sheet(&apos;成绩&apos;)sh2 = wb.add_sheet(&apos;汇总&apos;)### 然后按照位置来添加数据,第一个参数是行，第二个参数是列### 写入第一个sheetsh1.write(0, 0, &apos;姓名&apos;)sh1.write(0, 1, &apos;成绩&apos;)sh1.write(1, 0, &apos;张三&apos;)sh1.write(1, 1, 88)sh1.write(2, 0, &apos;李四&apos;)sh1.write(2, 1, 99.5)### 写入第二个sheetsh2.write(0, 0, &apos;总分&apos;)sh2.write(1, 0, 187.5)### 最后保存文件即可wb.save(&apos;test_w.xls&apos;) pandas 也可以操作 123456789101112ExcelWriter: Class for writing DataFrame objects into excel sheets.with ExcelWriter(&apos;path_to_file.xlsx&apos;, mode=&apos;a&apos;) as writer: df.to_excel(writer, sheet_name=&apos;Sheet3&apos;) writer = pd.ExcelWriter(&apos;exam.xlsx&apos;) for i in all_grad_pair: inflowdata = pd.read_csv(newfiledir+i+precitypair+&apos;.txt&apos;,\ sep = &apos;\t&apos;,header = 0, index_col = 0,encoding = &apos;utf-8&apos;) inflowdata.to_excel(writer,sheet_name = CityName[j])writer.save() ​12345678910111213import pandas as pd #读取两个表格data1=pd.read_excel('文件路径')data2=pd.read_excel('文件路径') #将两个表格输出到一个excel文件里面writer=pd.ExcelWriter('D:新表.xlsx')data1.to_excel(writer,sheet_name='sheet1')data2.to_excel(writer,sheet_name='sheet2') #必须运行writer.save()，不然不能输出到本地writer.save() 第二周：numpyhttps://cloudxlab.com/blog/numpy-pandas-introduction/ 对象Numpy 提供了n维数组对象（ndarray, A multidimensional array object) 创建 1234np.arange(6)array([0,1, 2, 3, 4, 5])np.zeros(10) # 1-nnp.zeros((3, 6)) # 2-n types123arr1 = np.array([1, 2, 3], dtype=np.float64)arr1.dtypefloat_arr = arr.astype(np.float64) 索引就是用中括号，注意切片是一维数组还是多少维数组！[, ], 如果，后面省略表示全部索引。 布尔类型索引 12345data[names == &apos;Bob&apos;]表示索引行data[names == &apos;Bob&apos;, 2:]表示行列索引 增改1result = np.where(cond, xarr, yarr) 索引值删计算函数+-/ *都是元素对齐 np.sqrt() np.exp() pandas对象创建索引增改索引值删计算函数matplotlibseaborn第三周：sklearn第五周：sql第六周： Linux第七周和八周：机器学习算法和数据挖掘]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习]]></title>
    <url>%2F2020%2F07%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[线性回归逻辑斯特回归决策树]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>监督学习与非监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data-Analysis]]></title>
    <url>%2F2020%2F07%2F25%2FData-Analysis%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活心得]]></title>
    <url>%2F2020%2F07%2F20%2F%E7%94%9F%E6%B4%BB%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. d17dd087ff99d138a18d9fa37867d6291f29f9410af3dfc6433a1bc47954f1438747793bfc3877a80b2b74d9923ec12294f5b72a4fa54125535bb74dd58002a653cfb6e8cbf98ecdb0c1c9feebfd50feab746b682a53fd101073b09749bece665ab3d667168d10f7c69e885de2e5376e559d333bef368b48557914e39f450283a8d4aac086c85286f464e5b9c57b2607af619e11f5ec517d3a89a6fb7856ed6f64619f8c5cbddd8751b2d6c340cff30cc51dbf4c8388047493985cd4cb99d3d0a04989e89f3f090e4a3996dc2549a43acd37d58f31a44f942f6c537aecf6adee2ee3052c7fa8cbaba3752835bad23acda53f864eab83b3b14fa2b46342ea6b4a72f6d5585a867bbbb8262515b16a15522408402c6f9dae8beea7686cb320d0a34b07a9b272b6a08e49c53470c67ef479cd682f849bfcffef9f20e44679bf5d6124a0e04e959c5140e55f22148d5f9a4ab9fc7facf7deba5c9dfb52d25fb20d2d0c99e8f50236fcd8d6393a8cd5b9a9bdb81cb78288424247b8128f27108a14cf31980db331651fea44a6d748c27cf4c869a91ec5cd2654bf8fcde97539641df4e13d724ab00028f98af23cf3c3f6f388e4c5fbd30f115c6b04ac7da769078ebc5978fba176d133e6d1114864ebdef4c709b8228515caafdd6bda5d446fe28283601d4be54cc3097dbc2b46f2e5f37291ab59d690e4874c5c85c06131a1cc65d19d09706dfdcafeca613b6d3404403709284a6b3e127cb5d564773cb95dd602b630aef4970d8d6f6502b11897eac740feb8ef989465340d95afd5e03ce7e89aec9ea75ab08910e0ce1bae89e2ae1403495a9bc45f27e05578408a38361c3fa40716dbdd882e9736c03552a8c1e922c4fd410fc8828a5c8dcc46910590352aad612917783fa53f197a76584b691b523e45fd76035726aa6e47f26359115156a8e761f7de4dcea2d69553ae85954352e832571bf8bd55d3c4c4f24914ea49588c34655e82e42bb15cdd53880079bf468eefc2ed1aa66b1aa18aa2232fe5899f755e8ec67911f4fa353feea51e20f82e7f9b541d1720f77be53fdc66474dbe7e56443752180638b5892f8524b41b2004e4972d5148778ae2543e3d04d4d518714fcc9640d5e1f9252f17459d789c4daa377b23f77699f42117081e6aa2737ffaef4c581495c2fa45d2552a5421ded3ff77f62295f41b8ebd70c6daeda5f5239593f7c0715cc3bd609c1c0d81c484ecdc973d579769c8b92665a86d3285aac4827a0af736d33f199b02e79508dcc236f77259587de10bde4a7c1acb9bc6da4bfea8fff8f4683cbe1266401aaceb11b6b1db246b77326a96d19a466243571c36c18a6992e9197ff42f928f6b8d3f04841b0eee9e4c1742794903210707dabafbf17afe5c6dda844b509b5564eac677b54dc79041b3e2bc7ddb05a42dcc753f8e57f6846a57a8efbc5c0d6125e8e736e051714b80e06729390ab54aba7cca36c4dd5dc6059cfac328935ae7d38c8580478f88ac1c865b742eea9bee7462155eabbdb8e02ce65051dba286b6835227cfad29118d675cda6efecb0148313f3042f13438260e9dabbbd6c034a9ebab3bb65b3c8731718cebbec75a5773831622b57a5880bd0a03b5a306e8c2fa071d7eead89e0d792659bd0192298ab3da9aac55c485d1a6c46effc3563e7f42b8e6a3461d2ed151d63cb8feb571d544fa10c8cd6477a829cdd587736dd30d1e218dcf2255bc321c6041c6389d7586c25a03ee1f8c875e7edc92dc21943d5de8341c913d7ba763051d2ab67b99e3fc2e39a451261bdb7a0a0faefac4088cc17fb2871496ea415fa287ca7623347da62fa00e22ded584ab8bf296e510f2ebe008fd5dcabc829c15ffb7b0945b0eb446b725927c4f706f441bf3d75a2b7fa5ec5dd3afa52e75fd6bb99c771288405064fd57098d090a9c1d3fd852be2523dbf37185d72f88ba1641337da63b18befe3f1126e2f065f5bbc1be3e50354083e9c208a259a135e798c9dc21802f93118661346d9744f85f06c1f64d2770bb54626cc3098bf114d1220d244e50babca8fa147c30514ce513d45e024083fdb0bfa7fb8c2bcaf3be921a7fdb98d1ff7b52fca0acdfb47788f50c976877f3e041e3057e0dd34b54e9cba7b1c6b05407f0ad88b308c9125bd15910b62aecaa8a8149b81bdce0321019e117c1c54e1dc8c965f446e32417dfc092f58bb9911ca8073cc79ca0d55deea419468da89580eb2004aea83e056af32871d43e032b631a93311fbf6593178c918aa4df202fffadac5d615edfe5f37822729ef586a263f42365558f5bc0aecc7df4d45479374dc41303065206180df2e58a280aa8c10d9a8c53d2dc5fdc44775f5f229edf8f109e1af42f038548fb2ef6b1c7a795c831b86493887e41f55cd8a8af7331153449144b6eb1f651fe73474174e72b5cd8d1db3b7be3f676cdd3b54e0568f36e4554a884dfec3d72e1c7270a3aff408330d166fc25bc4a89a9beb0d0bdaa70f7bef58f945c5211aac7d474775319946cc5d9d3c6d743f9acc39be4176f8021a34775a6cfc8784d6fe6ac80b59ead7f3346e9c17d64cad5ac6cb6dd42dc0165843f02d555c140bc72577c836d1ca25711bfd32f8dddfeff6a745372b0c3186e17cf57ae29c7bda257f0ef24df82e44f10f99f42d7b5d969a99e53c3675d60448c928c12e55bcd99db2510e837545924626a7613090a6c34c8ec3e98c4105aadba98acfea09f6e5cfc1e37ceac9f2d104c3fdcc8ed81935eb1c7153522b7a9ff40d3c14346b2b80b66678b1ce36303b284bfe83ee5630eaea1a3ef939421faa1e485afb25f7cf1861d01846898183c07d88643dc5ec3d13eb3bfeaabf1cd61991c1278bb49574050cbbfdb4e2c4ca873a67cede25204798d88b32d88d81616203f9842d964e44bb943d7017a0239ccab06bf412fc6a6146895a1eb0c58d1e926f89e94a6877052b9c0e1b899a781b45a2e2edd2d65404549bcdc9097d795eb052084922e9d60ab34b8ad5f141f1ccbc3385e8616aed84f51b6708367de6e6e3eebd4dc7001f37bbd2ea539b853e9345e19093996ab668a7a956f7d5eea501220cd564b98c3135c3bb0b1cb298b10365c023744ec918363f7ca1eb63dfca598963274f27743c30fe3fd29a1329463f828e51f3b565e0e71ce7c4b3fef7a5e97af09a9418278b306795a289b72b9cbed826d936f56aa413b911b698144211997b0e22849795d045e6ccdc5ccc636373a6f4415c47e6794c8ce15f5c125004b9c7129e3557fadd33d41c075b769aa747418e33372ba421cc718d2f9875b495ccd38464255302d8e500c31f682ab2547c29c7479deb0ea7623aeca49c0a777d069c593c0a46eefa0e92d8db5587e1fb29b4f5049407b2da38ec2a6dd4c0bbfcc7acb1ee0e69da7cbe245b19f21b6e2e7edd795b2a82b16ec69281e10a4dac6d7a5e8508d3aae6db9b63b81a4a64fc3d2e89fca49113f2037714c56283df78fb47fd5a9682e7c28fc2924fb4ba6bc0bfe4d8d31e0af8f1b6a88b21512c6f743e8bc42b710959bdf3de29ae13b1ebe3b57c7483f49d4d36579bb076552a2b89464b8119445d19ec6376f81ecda4b5c1bf0940202ef82b35cbfe38a59444caca398dbb909dc66abf9573d4d4b91452efae0640f86ff4ce1dab3d0a8df3a6983a94db8d67b57278631ce6c1f7ea557ef38247d36f0df84d8fe9cfba18cc64f21a365ab21347b6c123eeefa0464beb6876307b8bf16adba811bd0e7832537bee2b72b5e0a741af1f4c46fd952cc56f1a22aaa34a713f68c92b349c900457d768fb5a61ff1dd7e4673116f8849aee96310353146d05b737dfd4561d06043e508ca500e7ed078e0a36afdd7bc28fe32134d9c1bc55dd925651767428ded33103ded0e9e87af25ebfb48ed6a278f02ddf28d186c25c13e95f017b2dfd69981fe27d8e8acec28c8c2cf316420bc1912bdf64797084dfb0896f7333e78709e8e0abc468e2152a71088f64dc58875198f70f8a32b9a32e8de02683b49ce37f47610737e75a3599d557ee82b2bab1282ef21429fc8ba3d9243d1e38bd6e743e3051e147595b08a092dbf29c003cc75d19d1db9feced0d61b7bcbbc4ec4c84105da757c1e609e6da2e1a7c5735e6267449ed1acf1b1e08e0ae581f2b57e3b7ae2ca58a73e3b1165350ddf4704816a08c625f4555275eab553720337528a9c1751f24bcb6a39f2b8d346b03741c73b8b250aeea441c6ea9e79013b9e46ebf4515548d5625a5b4ac8db29e2367d6518621bc82ec2bb5cb4569c570cd1386641d40805c9ab30d6b0015e19e45851751aa5de1eb5c3b8baa6e3c0077bbadbe910bad6e8ee02d1d1651cfa6cd7123f93fd1bd0b356824028e435790fd6c173c1c74edc60b0bb81b396506d3842aa5923be16f22e015baabd20ce364b0f3358abc63618cfbad55569b0110ecc63a0b6869970a572312db2b9acd55cadea8b3ecd655bc0f1085f38659645133152d2553fe460731656de5ca9f93dc06c0b3db50fdffe32ac73660a1d16c0a16399ae9731e95fc2b935afc066d6485b76b6ecc4a28e985ae57ffdb5db9d7dc60ab70d59daabcf83634c1de625f291f5a0547d2498fe8648e59b9770d48fd6a0184b7c72f232d88ed41ff38e250fdf44c2c6387b8680d0ebffa21372d100c3f8187f0e2971b454eb26d9a70af3746e60e30a94eeba51744ed51bbeb972599cde54cd28157c41791327b9b0d0449f5b8127d5d306791cd2ff3217e95f19178f885136e75bc3d6410f154ed2e0c4860c7ebe75ce633377b4501bc9b4850ba9fe2e5c498ba184b6d939dbf9b4a0743ab0a16c4c44a2507451dec68ff6e32c3a11feddbafced44c686f1c371d6aa6518fcbc6785e9ab25ced3974e6e101a04a1f1d5b4bba85388b8a2247dade4b43ae7de5177f902a3e3801fb74eac73b58e007efecf06b3a856ff4b5714982b1aea73fefea7600e33a6f5940c68e3be8182e057af865c35fa4dab0a46fd72209ec1cab0aae6080834b0395b17f2805e2079eb6c5f0b78c851a948b3ff02aec43ed41b1e0a4847bdc45e55da7a9cbd54040beee552ddd05da8fcede6cae2ec401d2a1c2635253c192d3871dfd06e9b2d942c9b9f788ee8789db0c77bc2d606219a76200f1efe19ae10f06ab2709d2f0a56c98df3490eb0c648cb8d5b24f890468bc2e23e89fcfced29ecff10cf00d32dbbbd846dcea07aaa91265a7a81776763b9bb6c0c93bb42b8b4f58b00cd609960d13574a30644548aa14d3e3452ab0e303acd6725d159ff0b474f4b3e1502d6e3c202768a93321f3aa156206aeb6b7c3956b424254289f020409fb7de080f9418b5655aec86bc08df959efc686e81ee1233ab324cfc0366a7650f0d8b2e3a51c12b0623e6e6ca6c198b317445ec2a84f78b36447678a81f67ce8648a94e000d20869f1ab038419467c1e721970ecb82d0ae9b64665d353084a18411346c6c55ed9da3b2d4011752fdf43872d5e8684f1d2c7b55990021197004fb6144b80b14424b0c33c3397c66079dc3a83d8a197ab972a6c9ec75cf82023b302b7554021f2b755fffdfd34deca2f39dd543a0688643b38f9fe44cb3c46b9cede058811f2a439d4b3bff8dd39abb4356a6d4790edb00a1e8dd5914b8e51eade556cbcf1f15bbe341916170166558139e43983951216dc8980ccb2131175506b81297817bdd8f404c75d025284b336fce8e8bc2b6ae40df5330bda67719e30c0859828f0cdb95314dfb2594d35be763a0164f9a449955cc8ea69297822d9467a0abbb6ba7e1656c5c12619623c4b6140149c87a46cd88b500b1426b255a0f5d23647b14a2271de03752f6a4cfbd715f4ad8f83b468fe7646d2dacd8a80c24a3b2af960fb54a53ab75f8daac95028e222897ec84bed23390fb58dda66df51a2e73ac00fb057cdad27cef13b5f22c5dd30d4c72963031b4e153e52d56a97ce05a06d1b2e112d26de28a3a0201828ad9b2a3815642ffb249a426b039df14b3a28140dc412f6c83fc4209274b391f050ecfeb539b073c337bbd5d3c3d55153140289b259fac8ad2c9b4a414eaff43ae11a5e8066c380c4994231a025938b3c097bc256cdb0c15f8515009ce75ebac5614a462e659fab6fadcf63371448686fc7af9208ffa02cd95ac6f311b2a8b8aff482c3d10add35cf2331d21ad7f4c5c54e217f094d50054077e0cde70905ccc476ae75a6385ecc5db00cee67d6671fce7cef6bf41dc4bb06f712ab9573675ef59716016360bbafcb062d2de81dead4796fbd34316749096c98a87f5e8e47f3734ed3037c9c511da05ea1d5abb5d992e2836478a21e68a978c7a02e52dcf0a4d5ce617bc5a12c0fde89c6c85f050b7646483c4c5c53bfdfa6d527a20c5a70d505e4c7e81867cc7d1a45f8184dafe7133228a2ebf0b50add92832a19f547fa550727953b0feafe60a0d804dfd90523757ff76805a1c4f5f8b1ebf5f4433501ddad97dbf4f85f0d7b7b2766f45a3e26060010acfb6eede5912069b7e7182caa9c9debde3cd6a8092c6afa9bbc9f025da0d3b1b421ed2b79018b27c981929750af63999f70005ee986f7d69d25aec910cee1ab23675d6f60a0ebc7e1142b02fbe6aa871127d1e1b0d26777cb35f1da6a8cafe5e2a81b0a92a72cf0eb9f3295945bfcc880c61f1a5f0645a5133b3533497ceb297256a7f6e64900abb22b915654754f7e02269139d2c597a958e323036c3beed573aa96405a828626c3292e3edbd9ba10c8d664b17635a87f1329c7b2908618b7d3c3a066cdb38b0e7b8a2c993b078a6a562fa9659d4374da6754d72d95a295d69185f85dcd49e2ff4bde3d932fac4ae7a035dd8216ba22c674bd7c5d7891852635f33e5c469ad99322e5274188bb267444035fa0a30d829d742c6189bb56d61338dc74b48d8c9e255949deb7b303e5837c9fcf61839a230860789e4e8d424c400b2c9a3e147b6a4758352a6dae2a002089e4241ed92a51456ac8dfa3a1c7184c90a3e148aabb3ca32e752e648473d33b4291d97add910c3b362fb7488901b7dffc1331298e46e3c972bc6a5f192390853c391ac1ec2de29416ef676356289d98255f79bfa6a3b6d11deac9390f114eba7dd4aad0386a55ca1cc0f6bf8a74ced533b44d160cf8a3a8c406cb5839d648babf2f80d4e7ad0ba17b117551f4c01b3a62719e77a628e59e4191fbeeaf5e2b20b2db1cd830663117afd01226560cc6a74432963d97e53ac38c3279c97938dbb547923998d442d2ff0c2681805398bc4f1be00c13565058af90e636ec043c76df611581b6e1799c2b8192e210852045a957adb859ee9fa9d76bedef4755e129ef1a6b5a4c1a99e7a7df2e7c715fa21052bff7541399f6e198cfc62e02e352429d7987400e2718efcdf1c33c9bee51f90aba4a2b904dd9227581c1e5bc99f74dbf473aaa57d58c832e340c6958b40b05887be8fe9e6d67b063ca92abafbb90058e9a0529fd4ca0310771afccc56bdacbd0f4c6f46b421094841d83db0c32fdc8efece8a41721fd037eaa7c0f03e7b291b4ae87c106afe3fc0549946d057aad9f2d0f2008fa6547efe9a7351738b660665abc6d153e5528f43c62025e4acc7e0dca509fb159998ba8c52e715a1f3c10f5fe9134524d6c159d35dd663440aa5bdf2bdb069bf0efaceea838d5f84c351732cafd3bcb270eed4c4a1f92cac59d2cf8c30cb0a51cd4029e992513651edc7eec368e0e6b5b063c9a7d8f9008a8e10d8d4c3131cd793a26e71b581150eff3a0d471d830930b69fc0cca388139010c2629a2001c0790c263df35011b965a71ae2564058353989675b3f77213d4ec52484e848e9ba0ddf857c8ecde5e41be3534b86787e4c34cc0293cb09503544e299a8a5e68730dd46bbf0a4f89ec62b3839767c6e3e1a74f14616c274d3281f21c6a7ddd0ae10175a39b69a9376825815ddd06a84ed90dada9f74ca27c77f1ea3986cc254eaa1f643175f61fc6c843c372b21c8382fcf4ed6a6eeec18883d545d70833bd527160b8a3ea6b7274819a7ef06e0bbae35711b704e23c38b8977fa9f2138b34a8a0bf5aa6d12f0fcf492d97c522e164ceb5e035167e9352a7572d75ad9b5e943743a65b63b2e6856cb71beda2ac12865473ae328be03e55bcc3436bd2dfab415922730afadd2f357f048bd968e2d4197f024b58df289c72ef093d7fadff5587063f768317a7a3918b28285ba8331a0381536a46f1278ac9dae3310d1d5fb55622fc92bdf99e696ae47818dad9c6efe880812f72b37d22f6bdabde62f9e239d205096859c064c87309a6d182f9f7735ca8322532664dd2881bdf6128eb75542251e40fd0c2d2baffdc13034deec150da08d073824be395c0ab9ffe4dde86728969787cb6e296c240a8ae27bcc7b6ed892227e51eee0910f29e7ca3d2ea8e5ae6d3ff60935d1949091a607244f9d5deace502164bc9c3387eefe56492c3bfb4f01d9c0d780a2a39513bd4ffd10d31806f5eb4795951f9ece87eaac2060a7ed5c142232fffe7869336e93d4dea8d83c088bd102b0503f52fd6ec93cf69b9998f2d137a2bb188b9e246ec0382a3d48543ffe1ad4edd6564ff22d40692d1f7871c3ca7f29acc92cdbf787e3441c2d323833b625d63b7d605e8c327ad5d4ced243a225912d286468bd7fad8af05d712ce9a4b209b08a904b9a617c891aef236fed3b496658fe1428b93dffd9be5d30669f1f389f2ab51db9347f75404d2a416714067e4dfe4c37248cc8384496993010bcd7ce9d0ea43ff14600a8d02f66fa0e6fe7606189e1f61d217c7de177eb831bbe6c17adc9131e873eadc44650204f492571f1201e06c4f341649ab36356e8eaf69e9362944c5662c1d67cb321d708572ba245f5fa5e0992b441b6a7ad8061c041dcbc9da0ec53bae2f52c5bee0e1c901839d4b79c5228abf640bcce8319503953ecc54d34f2e266a2ba998bcfacd53e2679b1eb7130c5958d0eb57f78cafbda436420b912bc8f8641fa97dcc6de980d77f75b8337224338533f5f836f98424bb27c6382a3c33e3ab70a2ba007e9bbbd9e369fd799c856fc9bd469138720f25732eaf986337f5302741d4661369e65db15f12d87607e027035750d521ad55a5daea4ff8780ba1f7d3c6f19ed6a2def42c891180a40c686d4c4cba0105895e38deb1ef0ed3228a20ac36b2f6806e1ef2da6a13d218e228bfe954b45a6e37c884a3e26e790f614afd19beca013736dd5e7fbc570bac99067a02876c67c9d741e870aacb402a257790cd75401cd5683f59d2945ed847d2c9840fc587176b64c1d6bdb2bf94aa3a69c4050e39510fa2af6653b65c57490b5289b0430169ec2b6bffe0ae33e6b53b404ede59ca4971af231c5036698f0899fe0c0e88dc1042f9fbbf4b0d8aee506ed5c5f74927df70224f419d5677162fc2a034cf626e0d18e9f0860100e292ac3ab9053ad5b0611fcdd1260994a276b785bc1b2626ebd0ede46abe8337e55824fcfbbc111428e0f59b3c7c7cb2350b823614857b5478b9391223a541262bdf5f6fa9321129ecabb688bdbbd6482b408c94d78e7606b07b2267f12d1cda3ab8c29763d389a72e76cd60fdc5d9547682d087062b827dbba42219c80e3ca75bdc794052c9324d2c5a2ed16e310b85ee06397aa221d60ed24d6d4b9b5277494ba86a69de0b8fe224901e0831cf9b6d557bdf99b5142bf0aa705d583f221ae00afc956d5b1d2cd8f804b29870a8a8dff418cfdba0155dc8b4db4812127b08ca341629da43c1fd7011bbe72dba1d6f34e18992d13d1c793e964eeef8097f7d7f6dc507794be0dd19b97f720dfaace2cbea17f645207dd651ce8e3bac009c6b7e09f3bb8ee4eeaa88faa38899daf3ef923e155a56d6118f36f16d01a817b4965890ebc5374ca4ecc814f55ecbdc693256513187411db8ff12389bf663c8d1543de2379f0a9dc019192c36d062ce6d9dd55c84ecdb99e86f50261e99601dfd9c15e9e9c3dbaa751b7918fa8f7af1836ee7dd075c436621b023350e87d0eaf4e344a47b97058d66dc5b87ebbaae156814128725a0fda2044dc68ccc32776d6daccc0755f607fd0ada3aa216f68083b9dc018befa77365a8e241cbac0fb657cacad952ad3443fd1511f1d579ec6fe469ea15930f30e5ef9b82a87024188fe1d423372d5c262337d05a2f3ab44afe1f8f80d3990fbbbac98b268ca8ad203a79038a442adac7ac240a05c49f55239508f75a576eab726e2420555e917e56b907198e3b27b39013927e7a6a5c3628d4af0b0ffb5d20e02bc9fe6d30dc05391dc102aed5899980bb6b2aaf51ed139e159bc4c18db09dec20564f4c41e8c14dbc178ad02e0211fa8efbbc324ec354fe983163c5d98d9abe9ee758df63426bc5766f2841d6ef3975279b307a4546a454c927a0934d11663695b8e7a6b80126b74dca1fdb672363a0f2fa5981817bb252e7a49f167e12275d6039081c8c2b3504f135675f7b602e2c870c6e373ecce2617c5712926023525039782dab828be11b611587a7881f95789cdfa808d7454b75a9b293a2bdd2495a94fa84fe8d707b3cef6f7e2de4b61c4cd6c16c437433c62aebe2bc67f0f7bd774e612c7886caa0822c601e8da4da752da6682a984f68a561274d260c5287c0ae1aba46eacd011116b98a77f20d6f5ace0c6113207224d8df78ce3cd443a7cfb5a7378c7e699da10b10101751bb47a683d5581f19a91d421b2029bfdef9c817391d941f11678ff34be08cbbbd827aeafdb98b7ff13418c4967eea7a9024ca67ce4cffe0b23a7048d6a30c5be61de8d3645a4c11e7b9f9f702863141b4c2fbd026650ebdb7948344ca7de86514aec55fdb23bdc969f14ba0f7ec813858a0cc52bb0098c8f5be4abfc0308bfb4c71b0efc1e94fba964e54fe51df1260be7b6d531974d6b88601ba4d12483133d888e1d412ef2e55397931e207acd138915c604201892dd32150e2fbb9d1ae9e768d3791a466406e0fd2b6cfc1b202522b404c0283dae9ab8660abb36add3eaac6d813b6f9236f81e5cd34df66f4c700ba05b60637428e59d1bc34d470acba25f07b364581ab4f3e7eb617ef81ca3b66842e9e9275b9afc3611410744dfb9ca7b8db02db9a41c68a89caa756c222329e4fffbc2f6edcacb0c3bc61cb71ca4756e0077dbe84f8c9e7708dcdda44bf8c9b5ae63c6dba38c010ce2c6349a3a713e5256d631bead2e77bfbab8fcfa00e3a2a93a379b39073433a0dafcec83a6045459b0a289b9a5233551dfa0c16893ba3f674456d9a7156386d5d0c1c12200f3f9ff4bb0011bb5f06345729d7eaac7107a3c60cfbeb585a588908f3d5cac2d11fc55a723c80801c110a31f2858c10d75b9a6a33800aedd0f7cc22e1fda556b688d5686b615e83935e0ed0a50aa10ae12ea756523bee152c7da19a0ea2c3f2a157b8161c50c132539a9207d0b35ae23ab6094a2b587573fe685e6f01658c04d97885b8a070e64a1495ccc12e98460e8db73eb405fcdb3082c469ce449db3da6f9cf3c971afed0000302dc6b4dec7e13859a09e14ae7dccba7c52599692f48f097aea3f367da478621dafc6c6e89fd9e9c31af4bd58a9d169b37054db1c161300d6e0216cf17427499d915a23182129ed67f627348d54ba85d4fe0b39a16d6846cf1fabd0481d4e1a368928073f20cb7cc6287e946e0cb40170a592540c540e9ceb6bb1a394aed8bc6ec294ac7830830d742c48db06e1317c46af488ba75b9e8a430610a45d097a53e11d7fc45dde61420ed244e510db23ec912c9adc70cc8dc957133899ac71e598b439405b712a012cc501ee0b6dc2340f4899396ec3b6fb2900986721bba68fb562d00802bb15771df00a98461693c4481e372030939566e8fef8fc1b76b44f01275d8d1e2546bbc3cfd6b2bab26b4ae3fbdb07e63c1ccc112dfc9ebe2c46af3ad9e78e66b8ce42050b92436edb2c61bb49bb93db422f62b28385827d0823772858526f203395eb8e6c102741dbad2a3984cbe1829566517d256a44f46a21edbc21ae61356b66851fbb62d00ff84587d1a3ce69009536409ad55e1536a169a6efc56aae33b93363dbb4a10867be58ba7b35c9ce4dba680663da45c24951021cdaa521d7f99416aea9e853a3e2bb8292fb2496ddb7a2ea4f58e88f100c3ff7b6ae13b5be6a43ed614ad294a572335423387ba90de56d610f0e583a6077ebeb457484ceb33a2137ddaf9a34b17404b1590412321fe3b2e46dffa012b9fdbd4c5a46e0ff01eb55810ce9945f9ff632454f085fa192f5300b7b1905e1f31452f2aee01365c1d9847093de19da7457ae77e4ffe98f1b020ede069fa5d7e1ef8075bddf6ce97f44f16aa9bd3e5fd4cc0d6941cee92fb94ab79a224e18e783591934665a47143d89522001b4868e56b532a2303701a03c28e27b743e678819e47ef32e7bcd140e86ede1216e92670f3f35f2e9ff940ef054ab21e9c294f0fda]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书]]></title>
    <url>%2F2020%2F07%2F17%2F%E5%AD%A6%E4%B9%A0%E3%81%AE%E5%8E%86%E7%A8%8B-%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[阅读目录[TOC] 第一章 What is the machine learning?非常官方的定义： Tom mitchell(1998) Well-posed LearningProblem:A compute program is said to learn from experience E with respect to same task T and some performance measure P,if its performance on T,as measured by P, improves with experience E。（这个我莫法翻译喔）大概意思是强大的计算机能够事先地完成人为非显示编程好的任务，怎么完成呢？对于某个任务T,给定一个性能度量方法P,在经验E的影响下，如果P对T的测量结果得到了改进，则说明该程序从E中学习了机器学习的过程大致如此：让计算机从数据中产生模型(model)，首先提供经验数据，给定学习算法(learning algorithm)和性能测量方法，它就能根据数据产生模型。模型： 泛指从数据中学得的结果模式： 局部性的结果 基本术语数据集: data set样本： sample属性（特征）： attribute（feature)属性值： attribute value属性空间（特征空间）： attribute space （ sample space）特征向量： feature vector学习（训练）：learning（training）训练数据： training data训练集： training set假设：hypothesis 学得模型对应了关于数据的某种潜在规律泛函能力: generalization 假设空间归纳（induction）： 从特殊到一般的“泛化”(generalization)过程演绎（deduction)： 从一般到特殊的“特化”(specialization)过程机器学习显然是归纳学习（inductive learning)归纳学习分狭义与广义，狭义是指要求从training set 中学得概念，广义是指从sample中学习 学习过程（训练过程）看作是在所以假设组成的空间中进行搜索的过程，搜索目标是找到与training set匹配的假设。如果假设的表示一旦确定，假设空间与其规模就确定了。想更详细了解假设空间，戳我啦5.2现实问题中常面临很大的假设空间，我们可以寻找一个与训练集一致的假设集合，称之为版本空间。版本空间从假设空间剔除了与正例不一致和与反例一致的假设，它可以看成是对正例的最大泛化。归纳偏好机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”（inductive bias),也就是学习算法在一个可能很庞大的假设空间中对假设进行选择的启发式或者“价值观”奥卡姆剃刀定律： 若有多个假设与观测一致，则选择做简单的哪个。没有免费的无餐定理（No Free Lunch Theorem[NFL]) 在所以问题出现的机会相同，或者所以问题同等重要下，所有算法的期望一样。但在实际问题中，针对具体的问题，不同的算法才会出现相对优劣。 发展历程推理期：二十世纪五十年代到七十年代初，AI处于推理区，代表性工作主要是A.Newell 和H.Simon的“逻辑理论家”程序和此后的“通用问题求解”程序等。“逻辑理论家”程序证明了数学家罗素和怀特海的《数学原理》里面的某些定理，获得图灵奖。知识期：从二十世纪七十年代中期开始，AI的研究进入了“知识期”，大量的专家系统出现，E.A.Feigenbaum（知识工程之父）在1994获得图灵奖。人们意识到，专家系统面临“知识工程瓶颈”,在那个时候，有人把知识总结出来再教给计算机是相当困难的。1950年，图灵再关于图灵测试的文章中，曾提到机器学习的可能二十世纪五十年代初，A.Samuel著名跳棋程序。五十年代中后期，基于神经网络的”连接主义“学习，如F.Rosenblatt的感知器（Perceptro），B.Widrem的Adaline,六七十年代，基于逻辑表示的”符号主义学习技术蓬勃发展学习期：二十世纪八十年代是机器学习百花初放的时期。一大主流是符号主义学习，代表决策树（decision tree).二十世纪九十年代中期之前，另外一大主流技术是基于神经网络的连接主义学习。二十世纪九十年代中期，”统计学习“占据主流，代表支持向量机。二十一世纪初，连接主义学习掀起了”深度学习“为名的热潮。 第二章 ： 模型评估与选择经验误差与过拟合、欠拟合训练误差（training error) or 经验误差（empirical error): 学习器在训练集上的输出与训练集之间的差异过拟合（over fitting）：在训练集上表现非常好，泛化能力太差，最常见的情况是学习能力太强学习到不太一般的特性，无法彻底避免，只能“缓解”欠拟合（under fitting）：这种情况容易克服模型选择(model selection): 不同的参数配置，产生不同的模型。理论上最好的模型是对泛化能力进行评估，最好的就是泛化误差最小的，泛化误差是无法直接获取的 评估方法设置一个”测试集（testing set)”来测试学习器在新样本的判断能力，用测试误差近似泛化误差要求： 测试样本与训练样本独立同分布的 测试集应该尽可能与训练集互斥，测试样本尽量不出现在训练集中如何产生training set 和 testing set 留出法（hold-out)要求：数据集($D$)划分成两个互斥的集合（训练集($S$,测试集$T$),需要注意的是，划分后，尽量可能的保持数据分布的一致性。不同的划分结果，得到不同的测试误差。单次使用留出法得到的结果是不够稳定的，所以一般采用若干次的随机划分，重复进行实验评估后去平均值 交叉验证法（cross validation)I. 将数据($D$)划分成$k$个大小相似的互斥子集，每个子集$D_i$都尽可能保持数据分布的一致性II. 每次都用$k-1$作为训练集，余下的哪个子集作为测试集，于是乎都到了k个测试结果的均值值得注意的是，$k$的取值对结果的稳定性和保真性有很大的影响，因此也叫k者交叉验证（k-flold cross validation) k的通常取值是10同样的，数据集$D$划分为$k$个子集有很多的划分方式，可重复$P$次$k$折交叉验证。 自助法 (bootstrapping)注意的是我们希望通过所以的训练集（$D$)训练出模型，但是流出法和交叉验证的方法，都保留一部分作为测试集，因此实际评估的模型所使用的训练集更下，这也许会导致估计偏差。自助法： 可重复采样或者有放回采样 记采样产生的数据集（$D’$),每次从$D$中挑选应该样本，将其拷贝至($D’$),并再将采样的样本放回数据集($D$),重复($m$)次以后，得到了包含($m$)个样本的数据集($D’$) 对于可重复采样，样本始终不采到的概率是$(1-\frac{1}{m})^m$,取极限得到：初式数据集中$36.8%$为出现在采样数据集中，因此可将($D$)作为训练集，($D\D’$)作为测试集，又称外包估计(out-of-bag estimate)自助法适用于数据量少，难区别测试集和训练集时，自助法会改变初始数据的分布，在初始数据足够的情况下，流出法和交叉验证更常用一些 调参和最终的模型学习算法都有参数(parameter),不同的参数配置，学得模型的性能也往往不同验证集(validation set): 模型评估和选择中用于估计测试的数据集称为的数据集往往将训练集划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参 性能度量(performance measure)假设检验（其实我一直都并不是特别了解） 假设检验的基本原理是重要的统计推断问题之一，根据样本提供的信息，检验关于总体某个假设是否正确。包括参数的假设检验（均值、方差等）和非参数（分布啊）的假设检验。 参数检验： 提出假设H—-&gt;在构造统计量，确定统计量的分布—-&gt; 确定拒绝域和接受域的分界线—-&gt; 在根据样本计算统计量的值u —-&gt; 推断 分布拟合检验 偏差和方差通过概率论分析对学习算法的期望泛化错误率进行拆解$x$: 测试样本$y_D$： $x$在数据集中的标记$y$: $x$的真实标记$f(x:D)$: 在训练集上学得的模型$f$在$x$上预测输出以回归任务为例子：学习算法的期望预测为： \hat{f}(x) = E_D[f(x;D)]方差：度量同样的样本大小的训练集的变动所导致的学习性能的变化，即刻画数据扰动所造成的影响 var(x)= E_D[(f(x;D)-\hat{f}(x))^2]噪声： 表达了当前任务上任务学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。 \epsilon^2=E_D[(y_D-y)^2]期望输出和真实标记的差别称为偏差(bias): 度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力 bias^2(x)=(f(x)-y)^2若假设噪声期望为零，那么算法的期望泛化误差： E(f;D)=E_D[(f(x;D)-y)^2]\\ =....=E_D[(f(x;D)-\hat{f}(x))^2]+(\hat{f}(x)-y)^2+E_D[(y_D-y)^2]E(f;D)=bias^2(x)+var(x)+\epsilon^2由上式可知，泛化能力由学习算法的能力、数据的充分性、学习任务本身的难度共同决定的。underfitting: 偏差主导泛化误差over fitting： 训练数据发生的扰动渐渐被学习到，方差主导了泛化误差 第三章 线性模型我自己其实是一直停留在线性模型学习过程，因为每次开头都是这一张，所以我就学习了很多次。这次不准备再细看了。 线性判别分析 Linear Discriminant Analysis (LDA)基本思想： 在训练样例集上，设法将样本例子投影到一条直线上使得同类样例的投影尽可能接近、异类投影点尽可能远离。数学表达：$D={(x_i,y_i)}_{i=1}^{m}$: data set$X_i$: 第$i$类集合$u_i$: 第$i$类集合均值向量$\sum{i}$: 第$i$类集合协方差矩阵$ w^Tu_i$： 第$i$类集合在直线上的投影$ w^T\sum_{i}w$: 样本点的在直线上的投影学习算法：同类更近：$\min \sum_{i=1}^{n}(w^T\sum_{i}w)$类中心越大：$\max ||w^{T}u_1-(\sum_{i=2}(w^{T}u_i))||_2^2$因此，想最大化的目标考虑$i = 2$的情况 J = \frac{||w^Tu_0-w^Tu_1||_2^2}{w^T\sum_{i=1}w+w^T\sum_{i=2}w} =\frac{w^T(u_0-u_1)(u_0-u_1)^Tw}{w^T(\sum_1+\sum_2)w} 应用空间几何和矩阵的关系描述 类内散度矩阵($S_W$)\sum_1+\sum_2 类间散度矩阵：(u_0-u_1)(u_0-u_1)^T 所以，我们想优化目标如下：J = \frac{w^T_Sbw}{w^TS_ww}如何确定$w$呢？注意到分子分母都是关于$w$的二次型，因此解这和w的方向有关系，因此，可令 $w^TS_ww=1$,优化问题可是如下： \min -w^TS_bw \\ s.t. w^TS_ww = 1构造lagrange 函数 L = -w^TS_bw+r(w^TS_ww-1)对$w$求导可得： S_bw =rS_ww$S_b w$和$ u_0 - u_1 $ 方向是$u_0-u_1$,不妨设 S_nw=r(u_0-u_1)so,w = s_w^{-1}(u_0-u_1)这里考虑到数值解的稳定性，因此往往把$S_w$进行奇异值分解 第四章 决策树决策树是一种特别普通的符合生活做决策的过程。 第五章 神经网络神经网络最开始出现是根据生物神经网络来的。 最简单的神经网络：神经元模型(neuron|unit)McCulloch and Pitts抽象出“M-P神经元模型” 感知器（Perceptron)输入层和输出层，输出层：M-P神经元感知器的学习过程一定是收敛的 多层前馈神经网络 （multi-layer feddforward neural networks)前馈：网络的拓扑结构不存在环或者回路神经元的学习过程：就是根据训练数据来调整神经元之间的”连接权”(connection weight),以及每个功能神经元的阙值 误差逆传播算法： error BackPropagation (BP)全局最小和局部最小神经网络的训练过程其实也就是参数寻优的过程，基于梯度的搜素是使用最为广泛的参数寻优方法，但是如果误差函数在当前点的梯度为零，则很有可能达到局部极小。 第六章 支持向量机支持向量机的学习原理很简单也很有趣，从分类问题，怎么一步一步建立的优化问题，一步一步的完善优化问题以及求解，从硬间隔到软间隔，分类问题是考虑分对，而回归问题希望预测值和原始值尽可能的接近，这样就造成了约束条件，目标性的不同。 最重要的是引入了核方法，低维空间的非线性关系映射成了高维空间线性关系，这是特别重要的思想 第八章 集成学习基本思想构建一组基学习器（base learner)，在结合 a. 如果集成中是相同类型的个体学习器，如决策树，全是神经网络的集成“同质”（homogeneous),个体学习器叫基学习器 b. 不同的学习器，异质（heterogeneous)，个体学习器叫组件学习器 为什么有效 多样性的基学习器 不同的模型取长补短 每个基学习器都犯错误，综合起来可能性不大 举个栗子 也许一个线性模型不能简单分类，但是多个线性模型综合，可将数据集成功分类 构建不同的机器学习Q 1: 如何建立基学习器 尽量满足多样性 M1: 不同的学习算法 M2: 相同学习算法、不同的参数 M3: 不同的数据集（不同的样本子集、数据集上不同的特征） homogenous ensemble 采用相同的学习算法、不同的训练集 Bagging Boosting 相同算法，不同的参数设置 相同的训练集，不同的学习算法 Q2: 如何综合呢？ t投票法：majority voting weighted voting 训练一个新模型确定如何综合 Stacking 偏好的简单模型 综合Bagging = Boostrap AGGregatING有放回采样，同质学习器 算法1234567891011Input : 训练集 D=&#123;(x1,y1)&#125; 基学习算法A 训练轮数 T过程 for t = 1,2,...,T do h_t= A(D,Dt) // Dt第t次采样的分布 end for输出 回归：Average 分类：投票法 优点没有用于建模的样本，可以用作验证集来对泛化能力进行包外估计，可以得出Bagging泛化误差的包外估计 random forest（RF)输入为样本集$D={(x,y1),(x2,y2),…(xm,ym)}$，弱分类器迭代次数T。 输出为最终的强分类器f(x)f(x) 1）对于t=1,2…,T: a)对训练集进行第t次随机采样，共采集m次，得到包含m个样本的采样集$Dt$ b)用采样集$Dt$训练第t个决策树模型$Gt(x)$，在训练决策树模型的节点的时候， 在节点上所有的样本特征中选择一部分样本特征， 在这些随机选择的部分样本特征中选择一个最优的特征来做决策树的左右子树划分 2) 如果是分类算法预测，则T个弱学习器投出最多票数的类别或者类别之一为最终类别。如果是回归算法，T个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。 参数设置 利用00B样本评估变量的重要性 Boosting 提高顺次建立学习器，就是先从训练集上训练一个基学习器，再根据学习器的表现对训练集分布进行调整，让先学习器错误训练的样本在后续收到更多的关注，然后基于调整的分布训练下一个学习器，最后，在将这T个学习器进行加权结合 基学习器的线性组合 H_N(x;P)=\sum_{t=1}^{N}\alpha_th_t(x;a_t)$a_t$是第$i$个弱学习器的最优参数，$\alpha_t$是在强分类器中的比重，$P$是$a_t$和$\alpha_t$的组合 最小化指数损失函数 l_{exp}(H|D)=E_{x~D}[e^{-f(x)H(x)}] H_n(x)=H_{n-1}(x)+\alpha_{n}h_{n}(x,a_n)l(h_i(x,a_t)|D)=E_{x~D}(exp(-f(x)h_i(x)))\\=p(f(x)=1)exp(-h_i(x))+p(f(x)=-1)exp(h_i(x))\frac{\partial l(h_i(x,a_t)|D)}{\partial h_i(x,a_t)}=\\ -p(f(x)=1)exp(-h_i(x))+p(f(x)=-1)exp(h_i(x))=0h(x)=\frac{1}{2}ln\frac{P(f(x)=1)}{P(f(x)=-1)}采取不同的损失函数，得到不同的类型 https://blog.csdn.net/luanpeng825485697/article/details/79383492 GBDTStacking 不同学习器，相同数据集 第一层 第二层：不用第一层的数据 可用交叉验证 注意事项： 过拟合问题：第二层线性回归 第一层尽可能的多样性： 综合好的模型 防止过拟合 1. 随机性 2. Bagging Boosting Stacking 极大似然估计似然： 相似的样子 对于一组数据，假设符合正态分布，希望已知点在这个正态分布的情况下，所有点对于的概率之和或者积最大， ，蓝色表示数据，红色就是做得正态分布 第十章 降维与度量学习k近邻学习k-Nearest Neighbor 原理： 基于某种距离度量找出训练集中与其最靠近的k个训练样本，根据k个邻居的信息进行预测。 给定测试样本$x$,如果最邻近样本$z$,最邻近分类器出错的概率就是$x$与$z$不再同一类 p(err) = 1-\sum_{c \in y}p(c|x)P(c|z)低维嵌入缓解维数灾难的重要途经之一是降维（dimension reduction）这样使得子空间中样本密度大幅度提高，距离计算变得更容易， 多维缩放（Multiple Dimensional,Scaling）MDS 假定m个样本在原始空间的距离矩阵$D$,在低维空间中，两个样本欧式距离等于原空间的距离，$||z_i-z_j|| = dist_{ij}$, 令$B=Z^TZ$为降维后样本的内积矩阵, dist_{ij}^2=||z_i||^2+||z_j||^2-2z_iz_j=b_{ii}+b_{jj}-2b_{ij}对降维后数据中心化，均值为0,$\sum_{i=1}^{m}z_i$,于是乎就有$\sum_{i=1}^{M}b_{ij}=z_j(z_1+z_2+…+z_m)=0=\sum_{j=1}^{m}x_{ij}$ ,可得 \sum_{i=1}^{m}dist_{ij}^2=\sum_{i=1}^{m}(b_{ii}+b_{jj}-2b_{ij})=tr(B)_mb_{jj}\\ \sum_{i=1}^{m}\sum_{j=1}^{m}dist_{ij}^2 = 2m tr(B)\\ tr(B)=\sum_{i=1}^{m}||z_i||^2可得 b_{ij}=-\frac{1}{2}(dist_{ij}^2-dist_{i.}^2-dist_{.j}^2+dist{..}^2)对矩阵B做特征值分解(eigenvalue decomposition)，$B = V \land V$,则 Z = \land_{*}^{1/2}V_{*}欲获得低维子空间，最简单是对原始高维空间进行线性变换，$Z = W^TX$,特别的，$W$取正交变换，$W={w_1,w_2,…,w_{d’}}$W是d’个d维基向量， 主成分分析Principal Component Analysis ：PCA 在正交空间里面的样本，用一个超平面对样本进行恰当的表达，至少这个样本点满足 最近重构性： 样本点到这个超平面的距离足够近 最大可分性： 样本点在这超平面上的投影尽可能分开 对于最近重构性： 假设样本去中心化，再假设投影变换后得到欣的正交坐标系${w_1,w_2,…,w_d}$,d维空间里面的一组单位正交基，$||w_i||_2=0$,$||w_i^Tw_j||=0$,如果再新坐标系中丢掉一部分坐标，样本点在新坐标的投影是$z_i={w_1^Tx_{i1}},..,w_{d’}^Tx_{i}$,于是又$z_{ij} =w_{j}^Tx_i$,$\hat{x_i}=\sum_{j}^{d’}w_jx_i$ \sum_{i=1}^{m}||\sum_{j=1}^{d'}z_{ij}w_j-x_i||_2^2=\sum_{i=1}^{m}z_i^Tz_i-2\sum_{i=1}^{m}z_i^TW^Tx_i+x_i^Tx_i\\ =\sum_{i=1}^{m}x_i^TWW^Tx_i-2\sum_{i=1}^{m}x_i^TWW^Tx_i+x_i^Tx_i\\ min -\sum_{i=1}^{m}z_i^Tz_i=-tr(Z^TZ)\\ min -tr(\sum_{i=1}^{m}W^Tx_ix_i^TW)=-tr(W^T(\sum_{i=1}^{m}x_i^Tx_i)W）=-tr(W^TXX^TW)\\ s.t W^TW = I对于最大可分性$(W^T\hat{X}=0)$ max tr(W^TXX^TW)\\s.t W^TW = I根据lagrange L(W,\lambda)=-tr(W^TXX^TW)-\lambda(W^TW-I)\\ \frac{\partial L}{\partial w_i}=-2w_iXX^T-2\lambda_i w_i=0\\ XX^Tw_i = \lambda w_i$XX^T$是协方差矩阵,$\lambda$是特征值，$w_i$是特征向量 特别提示，$x$需要中心化 对于线性PCA降维方法是从高维空间映射到低维空间，$Z= W^TX$,然而不少情况，则需要非线性映射才能找到恰当的低维嵌入， $\phi(x)$ \max tr(\phi(X)\phi(X)^T)=tr( W^T\varphi(x)\varphi(x)^TW)\\ W^TW = I于是有 \varphi(x)^T\varphi(x)w_i=\lambda_iw_i\\ w_i=\frac{tr(\varphi(x)^T\varphi(x))}{\lambda_iw_i} z_j = \frac{\sum_{i=1}^{m}\varphi(x)^T\varphi(x)}{\lambda_iw_i}\varphi(x_i)\ =\frac{\sum_{i=1}^{m}\varphi(x_i)K(x_i,x)}{\lambda_iw_i}流形学习（表示学习有点困难)第十一章 特征选择与稀疏学习对于一个学习任务，对任务有用的特征,称为”relevant feature”，对于没有用的属性”irrelevant feature”,因此从给定特征集选择出相关特征子集的过程，特征选择（feature selection),原因一，降维；原因二：降低学习的任务。 无关特征，包括一类冗余特征（redundant feature），能够从其他特征里面推演出来。 特征搜索前向（forward)搜索对于特征集合$\{a_1,a_2,…,a_d \}$,每个特征看作一个候选集，对这$d$候选的单特征子集进行评价，可选出最优子集，然后，再下一轮子集中，构成了两个特征候选的子集， 后向 (backward) 搜索每次尝试去掉一个无关特征 双向(bidirectional)搜索上述操作只是贪心策略，仅仅考虑了本轮选定集合最优 ​ 子集评价（subset evaluation)已知一个数据集$D$,假定第$i$类样本所占比例$p_i$,对于属性子集$A$,假设根据取值D分成V个子集$\{D^1,D^2,…,D^V\}$,则子集A的信心 增益 Gain(A) = Ent(D)-\sum_{i=1}^V\frac{|D^i|}{|D|}Ent(D^i)\\ Ent(D)=\sum_{i=1}^{|y|}p_ilog^{-p_i}​ 信息增益Gain(A)越大，说明特征子集A包含的有助于分类的信息越多，特征子集A是对数据集D的一个划分，样本D的标记信息Y则对应着D的真实划分，就能对A进行评价，对Y对应的划分的差异越小，则说明A越好， 过滤式选择Relief （Relevant Feature） 设计一个“相关统计量”来描述度量特征的重要性，该统计量是一个向量，每个分量对应一个初式特征，而特征子集的重要性则是每个特征对应统计量分量之和来决定，最终只需指定一个阙值，根据阙值选择统计量分量对应的特征即可 如何确定相关统计量 给定训练集$(x_i,y_i)$,对于实例$x_i$,在其同类样本中找最近邻（near-hit),在从异类样本中寻找其最近邻$x_{x,nm}$称为“猜错近邻”， \delta^j =\sum_i-diff(x_i^j,x_{i.nh}^j)^2+diff(x_i^j,x_{i,nm}^j)^2分值越大，说明对应属性的分类能力越强 对于多分类问题 \delta^j = \sum_i-diff(x_i^j,x_{i,nh}^j)^2+\sum_{l \neq k}p_l\ diff(x_i^j,x_{i,l,nm}^j)这种方法看一个属性（特征）重不重要，先计算出每个属性的统计分量，按照公式，子集的评价就是对于分量的和 包裹式选择直接把最终将要使用的学习器的性能作为特征子集的评价准则，特征选择的目的就是为给定学习期选择有利其性能的特征子集。 LVW（Las Vegas Wrapper）是典型的包裹式特征选择方法，拉斯维加斯方法（Las Vegas method）框架下使用随机策略来进行子集搜索，并以最终分类器的误差为特征子集评价准则 算法 嵌入式选择学习器自动地进行特征选择 L-P范数 L_P = ||X||_P = p\sqrt{\sum_{i=1}^{n}x_i^p} L0范数 ||X||_0=向量中非零元素的个数L1范数 ||x||_1 = \sum|x_i|L2范数，最常用 ||X||_2=\sqrt{x_i^2}无穷范数 ||x||=max|x_i|对于线性回归模型，防止过拟合，如果使用L2,称为岭回归(ridge regression),如果采取L1范数，则有称为LASSO，L1比L2更易于稀疏解，可以看得出L1范数正则化的过程得到了仅采用一部分初始化特征的模型。 L1正则化求解可使用近端梯度下降法(Proximal Gradient Descent)PGD L-Lipschitz条件 设函数$Φ(x)$在有限 区间$[a,b]$上满足如下条件： (1) 当$x∈[a,b]$时，$Φ(x)∈[a,b]$，即$a≤Φ(x)≤b$. (2) 对任意的$x1，x2∈[a,b]$， 恒成立：$|Φ(x1)-Φ(x2)|≤L|x1-x2|$. 如果$f(x)$可导，并且$\nabla f$满足L-Lipschitz条件， ||\nabla f(x')-\nabla f(x)||_2^2]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>西瓜书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学]]></title>
    <url>%2F2020%2F07%2F17%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[统计学 统计学 day Ox00day Ox00 首先介绍随机实验的基本概念，包括随机实验，样本点，样本空间，基本事件，随机事件；其次介绍概率论的基本概念，包括概率的公理化定义，古典概率，条件概率，全概率，贝叶斯公式等等。特别注意两个容易混淆的概念：事件的独立性和互斥。 day Ox01 首先引 出随机变量的定义，从离散随机变量和连续随机变量两个维度，介绍典型的分布函数。其中概率函数和分布函数是非常重要的概念。 基本概念随机试验：记作$E$ 样本点： 随机试验中出现的可能结果称为样本点，记作 $\omega$ 样本空间： 所有样本点组成的集合称为样本空间，随机实验所有的结果的集合，记作$\Omega$ 事件： 样本空间的子集，叫做随机事件，记作A,B,C。 ​ 分类：基本事件（由一个样本点构成），不可能事件（不包含任何样本点），必然事件（样本空间的所有样本点组成） 事件的关系和运算 ​ A与B互斥（互不相容），并为空集。不可能同时发生。 ​ 对立（互逆）：A,B在一次实验中有且仅有一个发生。 事件间的关系包含 相等 互不相容性：不可能同时发生，没有交集 事件的概率概率的公理化定义计算方法古典方法随机事件的要求：(1). 涉及的随机现象只有有限个基本结果（2). 每个基本结果出现的可能性是相同的（等可能性） 事件的基本结果： P(A) = \frac{k}{n} = \frac{事件包含的基本事件的个数}{全空间包含的基本结果总数}事件的独立性两个事件的独立性是指一个事件的发生不影响另一个事件的发生， P(AB) = P(A)P(B)多个事件的独立性 P(A_iA_j) = P(A_i)P(A_j)\\ P(A_iA_jA_k) = P(A_i)P(A_j)P(A_k)\\ \vdots P(A_1A_2\cdots A_n) = P(A_1)P(A_2)\cdots P(A_n)实验的独立性实验$E_1$的任意一个结果（事件）与实验$E_2$的任一个结果都是相互独立的事件，则称实验相互独立 条件概率 P(A|B) = \frac{P(AB)}{P(B)}乘法公式 P(A_1A_2A_3) = P(A_1)P(A_2|A_1)P(A_3|A_1A_2)全概率公式 P(A) = P(A|B)P(B)+P(A|\hat{B})P(\hat{B}) P(A) = \sum_{i = 1}^nP(A|B_i)P(B_i)贝叶斯公式 P(B_k|A) = \frac{P(A|B_k)P(B_k)}{\sum_{i = 1}^nP(A|B_k)P(B_k)}随机变量 day Ox01随机变量表示随机现象结果，一般大写字母X,Y,Z, 随机变量取值用小写字母x,y,z等表示。 用等号或者不等号把X与x联系起来就很多有趣的事件，X=x,Y&lt;y,等等构成了事件。 随机变量定义在基本空间$\Omega$上的实值函数$X = X(w)$成为随机空间 X: w->实数域（映射)随机变量的分布函数分布函数的定义 F(x) = P(X]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageRank算法]]></title>
    <url>%2F2020%2F07%2F15%2FPageRank%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PageRank是一种网页排序算法，基于页面的质量和数量。可应用于评估网页节点重要性。 PageRank算法PageRank,即\网页排名**，又称网页级别、Google左侧排名或佩奇排名。PageRank是Google用于用来标识网页的等级/重要性的一种方法，是Google用来衡量一个网站的好坏的唯一标准。 假设 数量假设: 如果一个页面节点入链数量越多，则这个页码越重要。 质量假设：指向页面A的入链质量不同，考虑权重的影响，则这个页面越是重要。 算法求解 第一阶段：通过网页链接关系构建起Web图，初始每个页面相同的PageRank值，再通过若干轮得到每个页面的最终pagerank. 每一轮更新页面PageRank得分的计算方法 权重 PR(T)/L(T)\\ where PR(T)的PageRank值，L(T)为T的出链数目修正$L(T)$为0的情况，孤立网页，使得很多网页能被访问到。$q = 0.85$ PR(A) = (\frac{PR(B)}{L(B)}+\frac{PR(C)}{L(C)}+\dots)q+1-q其他网络属性度量方法Centrality indices: degree, betweenness, and closeness. reference提出者： The anatomy of a large-scale hypertextual Web search engine https://en.wikipedia.org/wiki/PageRank]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言]]></title>
    <url>%2F2020%2F07%2F03%2FR%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[https://bookdown.org/qiyuandong/intro_r/-r-basics-2.html#section-3.3 入门： https://rc2e.com/ http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/intro.html 全面： https://github.com/harryprince/R-Tutor 视频： 中文： https://www.youtube.com/watch?v=rPj5FsTRboE 英文：https://www.youtube.com/watch?v=32o0DnuRjfg 这个教程好： https://sites.google.com/site/econometricsacademy/econometrics-models/linear-regression https://www.youtube.com/watch?v=YMt5K68ZvjQ&amp;list=PLRW9kMvtNZOh7Xt1m5Mlhhz2wtr0tCUEE]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xgboost]]></title>
    <url>%2F2020%2F07%2F03%2FXgboost%2F</url>
    <content type="text"><![CDATA[理论部分该算法思想就是不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。 boosting: https://zhuanlan.zhihu.com/p/38329631 Xgboost 就是回归树的集成 https://www.csuldw.com/2019/07/20/2019-07-20-xgboost-theory/ https://blog.csdn.net/github_38414650/article/details/76061893?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare https://blog.csdn.net/qq_24519677/article/details/81809157 有空再推导了 调用库Python 提供了两种库 xgboost xgboost sklearn接口 搭建模型 参数设置 GridSearchCV 调参(网格法) 调参步骤，参数范围 https://blog.csdn.net/han_xiaoyang/article/details/52665396 12345678import xgboost as xgbfrom xgboost import XGBRegressorfrom sklearn.metrics import mean_absolute_error,make_scorerfrom sklearn.grid_search import GridSearchCVfrom sklearn.cross_validation import KFold, train_test_splitfrom sklearn.datasets import load_boston https://blog.csdn.net/s09094031/article/details/94871596?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.compare&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.compare 1sklearn.model_selection.``train_test_split test_size train_size： ​ 三种类型。float，int，None。 float：0.0-1.0之间，代表训练数据集占总数据集的比例。 int：代表训练数据集具体的样本数量。 None：设置为test_size的补。 default：默认为None。 random_state：三种类型。int，randomstate instance，None。 int：是随机数生成器的种子。每次分配的数据相同。 randomstate：random_state是随机数生成器的种子。（这里没太理解） None：随机数生成器是使用了np.random的randomstate。 种子相同，产生的随机数就相同。种子不同，即使是不同的实例，产生的种子也不相同。 shuffle：布尔值，可选参数。默认是None。在划分数据之前先打乱数据。如果shuffle=FALSE，则stratify必须是None。 stratify：array-like或者None，默认是None。如果不是None，将会利用数据的标签将数据分层划分。 若为None时，划分出来的测试集或训练集中，其类标签的比例也是随机的。 若不为None时，划分出来的测试集或训练集中，其类标签的比例同输入的数组中类标签的比例相同，可以用于处理不均衡的数据集。 x_train, y_train, x_test, y_test = train_test_split(x, y, test_size=0.23, random_state=2) https://blog.csdn.net/qq_43288098/article/details/105407204?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.compare&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.compare 参数：分开调 https://blog.csdn.net/zc02051126/article/details/46711047 https://github.com/dmlc/xgboost/blob/master/doc/parameter.rst https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/ https://xgboost.readthedocs.io/en/latest/python/python_api.html#module-xgboost.sklearn 模型保存https://www.fatrabbids.com/2018/10/19/xgboost%e7%9a%84%e4%bf%9d%e5%ad%98%e6%a8%a1%e5%9e%8b%e3%80%81%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9e%8b%e3%80%81%e7%bb%a7%e7%bb%ad%e8%ae%ad%e7%bb%83/#more-235 XGBoost的特性重要性和特性选择 模型复杂度 特征数量衡量：特征重要性阙值的增加，选择特征数量减少，模型的准确率会下降。当然，特征数量的减少反而会是准确率升高，因为这些被剔除特征是噪声。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[English-Daily]]></title>
    <url>%2F2020%2F06%2F23%2FEnglish-Daily%2F</url>
    <content type="text"><![CDATA[2020-7-6coincide with v. 与…相符 stalk v. 潜近（猎物或人）；（非法）跟踪；怒冲冲地走；趾高气扬地走 n. 秆；柄；（叶）柄；（花）梗 verge Bella was on the verge of tears when she heard the news. 听到这个消息时，贝拉差点就要哭了。 resistant adj. 抵制的，反抗的，抗拒的；有抵抗力的；抵抗…的；不受……损害的 People are usually resistant to change. 人们通常抗拒改变。 liar The tall guy was a notorious liar. 那个高个子是个臭名昭著的骗子。 politics n. 政治；政治事物（活动）；政见；权术 oblige (以法律、义务等)强迫, 迫使; 帮忙, 效劳; [常用被动]使感激; 使(行为等)成为必要 phrase. (feel obliged to do sth.)觉得有义务做；不得不做 I felt obliged to leave after such an unpleasant quarrel. 发生了这样不愉快的争吵之后，我觉得有必要离开。 2020-7-1jelly n. 果冻；肉冻；果酱；胶状物，胶凝物；轻便塑料鞋 oval adj. 椭圆形的；卵形的 n. 椭圆形；卵形 rigorous /‘rɪɡərəs/ adj. 谨慎的，细致的；严格的，严厉的 He makes a rigorous study of the plants in the area. 他对该地的植物进行了缜密的研究。 ultimately UK/‘ʌltɪmətli/ adv. 最终, 最后, 归根结底, 终究 Everything will ultimately depend on what is said at the meeting. 一切将最终取决于会议的内容。 sturdy UK/‘stɜːdi/ adj. 结实的，坚固的；强壮的；健壮的；坚决的，顽强的 broaden UK/‘brɔːdn/ You should broaden your experience by travelling more. 你应该多到各地走走以增广见识. broaden the horizon 开拓视野 propel UK/prə’pel/ v. 推进，推动；驱使；迫使 voyage UK/‘vɔɪɪdʒ/ n. 航行, （尤指）航海 v. 航行, 远行, （尤指）远航 例句 The voyage from England to India used to take 3 weeks. 从英格兰到印度的航行曾经需要三周。 2020-6-28moist UK/mɔɪst/ adj. 微湿的, 湿润的 insult UK/ɪn’sʌlt/v. 侮辱，辱骂 n. 侮辱，辱骂 spontaneous UK/spɒn’teɪniəs/ They greeted him with spontaneous applause. 他们自发地鼓起掌来欢迎他。 slender UK/‘slendə(r)/ perimeter UK/pə’rɪmɪtə(r)/ n. 周长；外缘，边缘 blouse UK/blaʊz/ He pointed out a woman passing by who was wearing a skirt and blouse. 他指出了一个穿着裙子和衬衫的过路女子。 perfume UK/‘pɜːfjuːm/ n. 香水, 香料, 芳香 v. 使…发出香气, 洒香水 2020-6-272020-6-26Functional foods are food products that have a potentially positive effect on health beyond basic nutritional benefits. Functional foods aim to solve not only all the needs that regular foods provide, but also to address functional needs, which can range from maintaining and improving physical or mental health to adjusting energy levels and moods. Food has been historically used as preventive medicine in many cultures around the world, but the recent rise of functional foods can be directly linked to the rise of the wellness economy, which, in turn, is largely driven by influencer marketing and social media use. 2020-6-25IT IS A truth universally acknowledged that inequality（不平等）in the rich world（发达国家）is high and rising. Or, at least, it used to be. A growing band of economists are challenging the received（被公认的）wisdom, pointing out that trends in the distribution（分布，分配）of income and wealth may not be as bad as is often thought. 众所周知，富裕国家的不平等现象非常严重，而且还在加剧。或者说，至少曾经是这样的。越来越多的经济学家开始质疑既有的观点，他们指出收入和财富的分布趋势可能不是像通常被认为的那么糟糕。 2020-6-24imaginary adj. 想象中的, 幻想的, 虚构的 carriage n. 运输；运费，（旧时）马车；火车车厢；仪态，姿态，举止 message messenger n. 信使, 送信人, 通信员, 邮递员 pavement n. 人行道 postpone v. 延期, 延迟, 暂缓 We’ll have to postpone the meeting until next week. 我们将不得不把会议推迟到下周举行。 velocity n. 速度，速率；高速 reconcile v. 使和谐一致，调和；使和解；将就，妥协 It’s difficult to reconcile these two different points of view. 很难兼顾这两种不同的观点。 2020-6-23￼The success of the brand wasn’t built through big marketing campaigns, but through a savvy digital marketing strategy that increased brand awareness and generated high engagement, traffic, and conversions. 该品牌的成功并不建立于大型营销活动，而是建立于精准的数字营销策略，该策略提高了品牌的知名度，获得了很高的参与度、流量和转化率。 traffic: 信息流量，通信量 With only 40 physical stores, which are mostly used to drive consumers to e-commerce portals, Perfect Diary maintains momentum primarily through its digital footprint. Currently, it has a powerful presence on Little Red Book, Bilibili, Weibo, WeChat, Tmall, and Douyin. Thereafter she wrote articles for papers and magazines for a living. 此后她给报纸和杂志撰稿谋生。 adv. 此后, 之后, 以后 spur n. 刺激, 激励, 鞭策; 踢马刺, 靴刺; 骨刺; 山嘴, 尖坡 v. 刺激, 激励, 促进, 鞭策 stick adj. 黏（性）的, 一面带黏胶的, 闷热的, 感到热得难受的 n. 告事贴 I have to take a shower before going out because the sweat had made my skin sticky. 出门前我得冲个澡，因为汗水让我的皮肤黏乎乎的 devotion n. 关爱，关照；奉献；忠诚；宗教礼拜 The career needs our devotion for all our lives. 这项事业需要我们毕生的奉献。 reckless adj. 鲁莽的；不计后果的；无所顾忌的 wag v. 摇动；摆（尾巴），（尾巴）摇，摆动 n. 摇摆，摆动；老开玩笑的人，爱闹着玩的人 keen adj. 热衷的, 热情的; 渴望的; 敏捷的; 灵敏的; 锋利的; 强烈的 n. 恸哭; 挽歌 v. (为死者)恸哭 be keen on sth对 感兴趣 be keen to do 渴望做某事 offspring n. 子女，后代；幼崽；幼苗 receipt n. 收据，收入]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day]]></title>
    <url>%2F2020%2F06%2F22%2Ftime-series-01%2F</url>
    <content type="text"><![CDATA[时间序列及其分解 时间序列分类平稳序列（stationary series)序列中的各观察值基本上在某个固定的水平上波动，在不同时F间段波动程度不同，但不存在某种规律。平稳性时间序列的均值和方差都是常数。 方法：a) 看原图。是否在某个常数附近波动，且波动范围有界。如果有明显的趋势性或者周期性，则不是。b) ADF单位根检测。p值。 非平稳序列（non-stationary series)涉及趋势、季节性和周期三种特性，包含其中一种或者多种成分。 趋势(trend)时间序列在长时期内呈现出来的某种上升或者下降的趋势。分为线性和非线性。 季节性（seasonality)是指时间序列在一年内重复出现的周期波动。因季节不同而发生变化，如旅游旺季，旅游淡季。 周期性（cyclicity）是指时间序列呈现出的长期趋势。周期性不同于趋势变动，它是涨落相间的交替波动。不同意季节变动，它无固定规律，变动周期多在一年以上，且周期长短不一。周期性通常是由经济环境的变化引起的。 偶然性因素其导致时间序列呈现出某种随机波动。 时间序列的成分可分为：趋势（T),季节性（S),周期性（C),随机性（I)。 平稳时间序列分析AR模型 自回归模型AR 自回归模型描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测。自回归模型必须满足平稳性的要求。 移动平均模型MA 移动平均模型关注的是自回归模型中的误差项的累加 自回归移动平均模型ARMA 自回归模型AR和移动平均模型MA模型相结合，我们就得到了自回归移动平均模型ARMA(p,q) 差分自回归移动平均模型ARIMA 将自回归模型、移动平均模型和差分法结合，我们就得到了差分自回归移动平均模型ARIMA(p,d,q) 参数确定拖尾和截尾拖尾指序列以指数率单调递减或震荡衰减，而截尾指序列从某个时点变得非常小。 ARIMA建模过程 将序列平稳（差分法确定d） p和q阶数确定：ACF与PACF ARIMA（p,d,q） 模型 ACF PACF AR（p） 衰减趋于零（几何型或振荡型） p阶后截尾 MA（q） q阶后截尾 衰减趋于零（几何型或振荡型） ARMA（p,q） q阶后衰减趋于零（几何型或振荡型） p阶后衰减趋于零（几何型或振荡型） 参数 p,q 的自动确定方式信息准则在参数估计的时候，我们可以采用似然函数作为目标函数。可以通过加入模型复杂度的惩罚项避免过拟合问题。比如赤池信息准则（AIC)和贝叶斯信息准则(BIC) AIC=2k−2ln(L)一方面引入惩罚项，使得模型参数尽快少，减少过拟合。另一方面，也希望提高模型的拟合度（极大似然） BIC=kLn(n)−2ln(L)k为模型参数个数，n为样本数量，L为似然函数。引入$Kln(n)$惩罚项在维度过大且样本数据相对较少的情况下，可以有效避免出现维度灾难。 时间序列的分解加法模型 X_t = T_t + C_t+S_t + I_t ,t = 1,2,..,n每个时间序列看成是三个部分的叠加，分别是趋势项、循环项，季节项，随机项 乘法模型 X_t = T_t*C_t*S_t*I_t趋势分析趋势拟合法就是把时间作为自变量，相应的序列观察值作为因变量，建立序列值随时间变化的回归模型。可分为线性拟合和曲线拟合。 线性拟合如果长期趋势呈现出线性特征，可用线性模型拟合， \left\{\begin{array}{c} x_t = a+bt+I_t\\ E(I_t) = 0,Var(I_t) = \sigma^2 \end{array} \right.其中，$T_t = a+bt$就是消除随机波动影响后的该序列的长期趋势。 曲线拟合如果长期趋势呈现出线性特征，可用曲线模型来拟合 \left\{ \begin{array}{c|c|c} 二次型& T_t = a+bt+ct^2& 变换后，线性最小二乘法\\ 指数型&T_t = ab^t& 对数变化 & 最小二乘法\\ 修正指数型&T_t = a+bc^t& &迭代法\\ Gompertz型& T_t = e^{a+bc^t}& & 迭代法\\ Logistic & T_t = \frac{1}{a+bc^t}& 迭代法 \end{array} \right.平滑法移动平均法假设在比较短的时间间隔里，序列的取值是较稳定的，这种差异是由随机波动造成的。由此，可用一定时间间隔内的平均值作为某一期的估计值。 n期中心移动平均 \widetilde{x_t} = \frac{1}{n}(\frac{1}{2}x_{t-\frac{n}{2}}+x_{t-\frac{n}{2}+1}+\dots+x_{t+\frac{n}{2}-1}+\frac{1}{2}x_{t+\frac{n}{2}})n期移动平均 \widetilde{x_t} = \frac{1}{n}(x_t+x_{t-1}+\dots+x_{t-n+1})指数平滑法简单指数平滑 \widetilde{x_t} = \alpha x_t+\alpha (1-\alpha )x_{t-1}+\dots)季节效应季节性效应的存在，使得气温会在不同年份的相同月份呈现出相似的性质。 如果只是存在季节性和随机波动性 x_{ij} = \hat{x}S_j+I_{ij}其中$S_j$表示第j个月的季节指数，$\hat{x}$为各月平均气温。 季节指数的计算: Step1: 计算周期内各期的平均数 \hat{x}_k = \frac{\sum_{i= 1}^{n}x_{ik}}{n}（k = 1,2,...,m)其中，m表示周期，n表示周期的数量 Step2: 计算总平均数 \hat{x} = \frac{\sum_{i = 1}^{n}\sum_{k = 1}^{m}x_{ik}}{nm}Step3: 计算季节指数 S_k = \frac{\hat{x}_k}{\hat{x}}混合效应加法模型 x_t = T_t + S_t + I_t乘法模型 x_t = T_t*S_t*I_t混合模型 x_t = S_t*T_t+I_t\\ x_t = S_t*(T_t+I_t)如果季节波动的振幅不受趋势变动的影响，则说明季节性与趋势之间没有相互作用关系，可加。如果季节波动的振幅随趋势的变化而变化，是相互作用的关系，可尝试混合模型和乘法模型。 Tool in Python: xfresh特征提取官网： https://tsfresh.readthedocs.io/en/latest/text/quick_start.html 中文： https://github.com/SimaShanhe/tsfresh-feature-translation Data Formatscolumn_id: Features will be extracted individually for each entity(id); one row per id. column_sort: sorting the time series. 特征提取: 可以一次性提取完；也可以单独提取kind_to_parameters 设置参数；还可以提取 可分布式计算 the rolling mechanism 首先确定滑动窗口 Step1 : 实现单变量特征的提取 Step2 : 实现多变量特征的提取 Day Ox 01知识清单: 特征提取：大概上千种特征（几十种方法） tsfresh.feature_extraction.extraction.extract_features(timeseries_container,default_fc_parameters=None, kind_to_fc_parameters=None**, column_id=None, column_sort=None, column_kind=None, column_value=None, chunksize=None, n_jobs=1, show_warnings=False, disable_progressbar=False, impute_function=None, profile=False, profiling_filename=’profile.txt’, profiling_sorting=’cumulative’, distributor=None)** pandas.DataFrame containing the different time series column_id (str) – The name of the id column to group by. column_sort (str) – The name of the sort column. n_jobs (int) – The number of processes to use for parallelization. 时间序列的滑动窗口（单序列划分成多序列） tsfresh.utilities.dataframe_functions.``roll_time_series(*df_or_dict*, column_id**, column_sort=None, column_kind=None, rolling_direction=1, max_timeshift=None, min_timeshift=0, chunksize=None, n_jobs=1, show_warnings=False, disable_progressbar=False, distributor=None)** max_timeshift (int) – If not None, the cut-out window is at maximum max_timeshift large. If none, it grows infinitely. min_timeshift (int) – Throw away all extracted forecast windows smaller or equal than this. Must be larger than or equal 0. n_jobs (int) – The number of processes to use for parallelization. If zero, no parallelization is used. show_warnings=False （指定）特征提取 显著性检测 https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_selection.html?highlight=select_features#tsfresh.feature_selection.selection.select_features 相关性检测 https://tsfresh.readthedocs.io/en/latest/text/parallelization.html#parallelization-of-feature-selection 123456789101112131415161718192021222324252627282930313233from tsfresh import extract_features, select_features,extract_relevant_featuresfrom tsfresh.utilities.dataframe_functions import imputefrom tsfresh.utilities.dataframe_functions import roll_time_series, make_forecasting_frameimport pandas as pdimport tsfresh as tsf fc_parameters_value1 = &#123;"length": None, "sum_values": None&#125;fc_parameters_value2 = &#123;"maximum": None, "minimum": None&#125;kind_to_fc_parameters = &#123; "value1": fc_parameters_value1, "value2": fc_parameters_value2&#125;if __name__ == '__main__': # ceate data rawdata = &#123;'id1': [0,0,0,0,0,1,1,1,1,1],'time': [1,2,3,4,5,10,11,12,13,14],\ 'value1': [1,2,3,4,5,6,7,8,9,10], 'value2': [1,2,3,4,5,6,7,8,9,10] &#125; df = pd.DataFrame(rawdata)# 设置长度+1 = 真实长度,是当前编号往上数. df_rolled = roll_time_series(df, column_id="id1", column_sort="time", max_timeshift=1, min_timeshift=0)# roll_time_series的返回值 print(df_rolled) df_rolled = df_rolled.drop('id1',axis = 1)# column_id: 聚合列 column_sort:排序，一个column_id就对应一个特征 extracted_features = extract_features(df_rolled, column_id='id', column_sort='time', kind_to_fc_parameters = kind_to_fc_parameters, show_warnings=False) print(extracted_features) Day Ox 02 查看提取特征可根据此提取自动提取的特征，用于预测时候的提取特征 1kind_to_fc_parameters = tsf.feature_extraction.settings.from_columns(extracted_features) 1234# 5. 特征抽取与过滤同时进行（一步到位，省去多余计算）# column_id: group by #features_filtered_direct = extract_relevant_features(timeseries, y, column_id='id', column_sort='time')#print(features_filtered_direct.head()) 学习路径： 1. 数据格式 2. 滑动窗口设置 3. 特征提取 4. 特征选择 专题 时间序列的竞赛方案https://mp.weixin.qq.com/s?__biz=MzU1Nzc1NjI0Nw==&amp;mid=2247485604&amp;idx=1&amp;sn=6283ec080344665bfad90570bf1504a4&amp;chksm=fc31b29ccb463b8acac7acf4d89494aaad0c76620becb2b07c370ccbfaff850edc3c1ad4e0fd&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1593390448780&amp;sharer_shareid=fb5716a8ad12ea6329433df53d4cbf64#rd https://www.zhihu.com/question/21229371/answer/533770345 Prophet 工具]]></content>
  </entry>
  <entry>
    <title><![CDATA[回归分析]]></title>
    <url>%2F2020%2F06%2F20%2F%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[TOC] 回归分析最简单的线性回归，避免多重共线性，过拟合，引入正则项的线性回归模型。涉及到的数学知识：一范数，二范数，多元函数求极值。模型的含义，参数求解算法，目标函数，以及各种模型的优缺点。 定义回归分析是寻找自变量和因变量之间的数量关系，用于预测建模的方法。其一，它可以揭示自变量和因变量之间的显著性检测。其二，揭示多个自变量对一个因变量的影响程度大小。 回归类型1）独立变量的数量 2）度量变量的类型 3）回归线的形状 1. 线性回归（Linear Regression)因变量：连续； 自变量：连续或者离散 模型的形式 Y = a+bX+𝜀\\ \left(\begin{array}{c} y_{1} \\ y_{2} \\ \vdots \\ y_{n} \end{array}\right)=\left(\begin{array}{cccc} 1 & x_{11} & \cdots & x_{1(p-1)} \\ 1 & x_{21} & \cdots & x_{2(p-1)} \\ \vdots & \vdots & \vdots & \vdots \\ 1 & x_{n 1} & \cdots & x_{n(p-1)} \end{array}\right) \beta+\left(\begin{array}{c} e_{1} \\ e_{2} \\ \vdots \\ e_{n} \end{array}\right)\\ Y_{n*1} = X_{n*p}\beta+𝜀where $a$ and $b$ are the regression coefficients, and 𝜀 is the random error. 目标函数 min SSR = \sum_{i}(y_i-f(x_i))^2\\ min_{w}||Xw-y||_2^2参数估计最小二乘法（Lease Square Method)（OLS) This approach is called the method of ordinary least squares. 模型评估拟合优度 R-square , coefficient of determinationLarger $R^2$ indicates a better fit and means that the model can better explain the variation of the output with different inputs. https://realpython.com/linear-regression-in-python/ 要求 自变量和因变量之间必须满足线性关系。 多元回归存在多重共线性，自相关性和异方差性。 线性回归对异常值非常敏感。异常值会严重影响回归线和最终的预测值。 多重共线性会增加系数估计的方差，并且使得估计对模型中的微小变化非常敏感。结果是系数估计不稳定。 在多个自变量的情况下，我们可以采用正向选择、向后消除和逐步选择的方法来选择最重要的自变量。 逻辑回归（Logistic Regression)Logistic 回归的本质是：假设数据服从这个分布，然后使用极大似然估计做参数的估计。 Logistic 分布 F(x) = P(X]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>回归分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识清单]]></title>
    <url>%2F2020%2F06%2F19%2F%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[主要是列出关于日常中遇到的很好的资料，自己不清楚的文章和资料。 2020-8-24 5W2H5W2H分别对应着7个关键问号： What：何事？ Who：何人？ When：何时？ Where：何地？ Why：何因？ How：怎么做？ How much：多少钱？ 5W2H梳理销售下降问题 文章最开头，小P老板提了一个极其模糊的问题： “最近销售额为什么下降了？” 如果用5W2H法，应该怎么理清头绪呢？ 很简单，跟着问就完事儿了！ What（何事-问题是什么？） 问题是老板抛出的销售额下降原因分析，但这个需求太过笼统，我们需要进一步询问来界定和解构问题。 When（什么时候？） 是什么时间段销售开始下滑？下滑是环比还是同比，亦或是和平均相比？从趋势上看，是持续性下滑，还是某些时间节点的突然下跌？ Where（什么地方？） 是所有渠道的普遍下跌还是某个重点渠道的折戟？是全国各地普遍销售下降，还是某个地区销售下降的厉害？ Who（是哪群人？） 是新客户还是老客户的销售贡献乏力？是普通客户的减少，还是品牌忠诚客户的流失？ Why（为什么？） 回答完上面4个W，综合起来基本能够回答为什么销售下跌这个问题，但是这样还不够，数据分析更重要的是指导该怎么做 How（怎么做？） 如果是某个渠道老客流失严重，应该快速做客户原因定位，以及用CRM关怀来挽回客户。 如果是各渠道、全国性普遍销售下跌，市场份额被对手侵蚀，那应该紧密观察市场，紧盯竞品动作。 How much（量化做多少？） 结合上一步的行动，具体衡量通过短信或者其他方式触达花费多少，需要投入多少折扣，预计唤回多少客户，提升多少销售额，这些都可以基于历史数据量化。 怎么样？ 对于一个模糊的销售下跌问题，通过这7步的拆解，很快就打开了分析思路。不过，要完全精准的定位问题，找到本质解决办法，还需要进一步的定位、假设和验证。 2020-6-29 Z检测和T检测https://mp.weixin.qq.com/s?__biz=MzI4MjkzNTUxMw==&amp;mid=2247485455&amp;idx=1&amp;sn=857066158bf8c2de38939f3037416035&amp;chksm=eb9321b9dce4a8afd68d764c295f8bcc69c62f2b1d000f3e1c5e61a7d9b6e2ec3de8df068174&amp;mpshare=1&amp;scene=24&amp;srcid=&amp;sharer_sharetime=1593403964973&amp;sharer_shareid=0e2d0ffe45c3a6dfb66aa422c3a1381d#rd 2020-6-28视频： http://www.julyedu.com/video/play/58/405 2020-6-19SQL 中文: https://www.liaoxuefeng.com/wiki/1177760294764384 英文： https://www.codecademy.com/courses/learn-sql/lessons/manipulation/exercises/sql 视频： https://www.jikexueyuan.com/course/sql/ 基础 https://study.163.com/course/courseMain.htm?courseId=215012&amp;_trace_c_p_k2_=f68f3d2867a343789ac2d3cfa92dd308 https://www.nowcoder.com/discuss/95812?type=2 https://www.cnblogs.com/zsh-blogs/category/1413021.html]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data-Science]]></title>
    <url>%2F2020%2F06%2F11%2FData-Science%2F</url>
    <content type="text"><![CDATA[CourseTsinghua Dr. Yuan Data Mining: Theories and Algorithms for Tackling Big Data ToolsStata: https://www.stata.com/why-use-stata/ https://www.youtube.com/watch?v=AyXeh7iojuA BOOOOOOKhttps://www-users.cs.umn.edu/~kumar001/dmbook/index.php]]></content>
      <categories>
        <category>数据科学(Data Science)</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天了解多一点]]></title>
    <url>%2F2020%2F06%2F11%2F%E6%AF%8F%E5%A4%A9%E4%BA%86%E8%A7%A3%E5%A4%9A%E4%B8%80%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. fcff92c6407c0cbda68bba8aaf002853c06cb01a45d12df94e42bb4a271fbee0436bf044295cb309028e8545d308163a0f9a198f58f3b26dc0d16e2cfb415a1c5310d0d3e143644eaadd51a7a946b8971ad199b3a8e63479a53027d3d6217ded0067a4dc29114f2aecde01e8b890a02961ee5587173ded9d6f8b535fa96cffaa788b880a8dcb0b91995f1f315ee47a2f0342187a0748388c427217381cc39745cedfe8ffc751761397f3fdcfeac993bc7efa8abeca83b36c03ead25690e84a71950bbaa05a1019f2eb9e2bf95e8a5a92dee58d5324077bc81a413cae85453ffc8e6e0d6f22a54ad49528276603949d974e4d222f46786bc07030d65a7154d959373bf46b90c838f6768cb681854fa7a6481801c8863acd6e8dafed33c94f4143290fe8037b4a8140adbbb1f58f78145f9dbd354c263d4e105f156fa1268024569fb2ef488263bfba14ef41b7d2a5fd27c425e3e8b3bebca2416cc2fe40e9ebb2ccdbd19116f72bdebcfbba8b181ee71b49f1092cdcb47bb41a651d9eeab0d20943484faf45770fdf3e8023f108146278bcb05f35fe1c01ab504f684610b8135881eae83b6f4afc0af20958cbb0733a3acda4da981e19da90d2dbf9710b0dec4d09b7701043e972981186e81de0470570a74cdef4912e7c4dcca066d14e5712ba5c5c54dd40d89311dc1e07579873dc382c32bef768b834c3e124f9e4dccc5a6a0d35b320ef7ed2ee4aa33d2adc91bc322c59c1147ee0d729439a0bed1928f3d6da4f144f27bf56d735055ff78a15fd3aca12e1998b47224a73da40a77d460fd11013bbffbd86dc1390531a386373577790e3e46525ccc02cf665bc94f83d0162387028624771436bfdf7a1999c735cc0252ccda27aeb1db07c7581a3fb0a3fb7778232b3f6f37b8cfc50f0108b885d56350b0dd927d98fd1dbe5cb6b71881bc6c3ac0873861fcb273c31c8b2a167ab6650bc9830b97c21a2b27d3b445cc5ed13a5d6f38c71e99e653cebea542e84d5203af2c5fa6ca9adc4ca811518018df4e69753f97e7bc34e403279210a894435ff3897f2a84dc1ed49e30b7a0ece6396683def8a3f062c4a65417584db25dd5997565f560fc5ed3e5f428ad95601e1c96318795d729928de5e20996dfea95ff11bd86bb80aedfc8fa4a0772e247d9f2e1b9b8c0d0d996bdf373bdebc6f9abd98c984974589f0ca92ccb0584d2d84c4af20ef86fb03e50be3d5483b28f88ebfde2f6e928047659b4fefb1bae32d31457569fc8518c037f4bd4086a69f31095546ed817d05bde366353f4f5b4d8c92afb37371c0bd35445e6101d04518a7901c943087df8a26fbec5f4c9ddd476b7cece4d0aa427e519de139ac012101eec3ba535df40150a56245009f6fa16ccdef23fcf9c40a00187935a140c69987062c4826f9c8341d907b1b2705b750b5077d8e5f4ebb1a21ea1d4f9aff2220cdbb02be76a19d49c1cb62313ae98f42c5ff71f2fc4f0b70eb95763c0756c5e8d510a2f1dc8c5c2dfc41ab67bbae960307adbf443db584fce6dee6576349a1baad9981a7c9e8e2e84c445a6b8cafe1c3cc185862aa5cb0e9d03ab298e7f2bc70e4873a546cc848377bff6bd47411ad4d677e9297db33df43a56049e0ce81959afa63416fb5a0871749d736dc8982a7e3784ded3d59e5778f947d18c7797a0a6a89828d187f7f6992af8cec46bef8b637039efc860b118edd973a50eb7967b088d83c9aa82364efcd472651468cca097191d1a44dc6cc83f175c2835f6e3d63376cec4659c920aae4115538192940bbeb83156697bbee3af02749923b75285a3ca6e142915d6a78080d80b7a3ff8a706dac99fb781ecfd947c8489618bc45c8eefb43ab9c2cafd172fc1c8b2408ca1a778e93f9b7ee08ad804ff63c924d91e3f5fc7b9a9cc3b873dd235967898b29b594519860c246f43419be4f95b202972d9f3bcca442c1063711b388d7888603e4f4e532f6577fc29fb524dc7f8a942db6e7c35c7538bcbcd133310dfaad07607f034f9ba6ba0a0bc7bbdae4f27221e1de62653bf6f5f9cec310a1279c018140ff131c59b2f776367d0f125dc1fa4fd5498179600dfc4ab2e6e7d9fea25d0577f23e32ccd8995abb5acaeca22fa1291bf685ff4a29e0cd9c9deeebc66efe60b7554e123f6395bd21da9c20b76fc32a0b576652258212dd5186ace148f2b840f98e0eaee77083ecca9056b5aa76410ec5e2829a77def10805bcccec9ca5d567536503c260800e1524bb7ee611e024907ca8ab617b5617e86849ff6604dc93b3ee49a6d92214d40f8cf8c7e3d21c66ea1058814862fb8de6fec49889116c37e00cf717649b93a10feb36f8df3769972745c695d0124a967df9223acad4e116fd64c7d68b099111044dad0c116bb57782c5e2f86278083192d99e64ef219c02ec2a3ac5e1093403f7fe81275318d82ac6752662ce854ebdf41b3277a9e0ab783d4f6a13327cb1a5bd1808b95b19ea1cc49c93ec6bad6db9d84da5a68cf61b5d97d6380a76b6d1360596ffea4c15aa0e75e13144e510ce17f3666047267d3d568754ac619d2e000ef5032b6730bba8d4cc6befb0ac4e07c9881ee3c62db58a7c12bd6f2aee8a73c75f2739ae0ade84d717666fe79d06639c8dde53d6e9fd64b3bda121079f9ed3d6c24067941943d0847bc9e83300f900b8296bfa916ca21a7f10f9c5345a9ea2eab92373ce0ec4b0da2691c642b57a866b39a5e2d6aa7f397557a9ca832ba0da2ce3d2dbf2a3fb6aef61d542788db9f1ae8538a4547f249ad024e64892057789ea5ae6e75130abc591a2fea19c0d040695b296aa5ed8f5f5c7c4b9931dbb8a81fa3b7cbf250816a804d47855c38eca8551e46025b409e9291102397a6e3a004b3b85811574a34de68cb77551d8b132d436af3156158f4fd8f2022287b38f258e83ccd3b6fbc991d92155d03bb4e3e6339ed538c9524e268060c90492149d64e10a9719a0344546bf0c0002f3cc146685d9238514f95468335d7da54888376fdb6156e4529ed3b03434598f92ff639e8a5926c9d81471a40dfc842f09b616831ec2a127f4aa4d62c401f1b4aba84563b553362e6b67badaaf6fbaefa48ec045a92519b3b0f8fb323384c95d180e679e98c669bea9733935455b80ca98d75737ef9fdf4dd150b1c7fadcfb4399537d04ddc119e0de97e1e207d4ac27a19dc3d8ce6472a10dc8ed9332e26f8f5ae1e55fc4b4952492674b266e96cbc61e89d0eb5b7660c0a3f3b34b7bf4bc94b83192f696bc9cbbabad08b14456f058670bc6c8ff828333354dd8318ba311cda65ee1c6c643bc7b2fa070e0a076e6e05a9aa06b27b1a80871c4f108688a5ae45c939c9149be0af3db9560b045d746d7de113688665816a7ce341f96b064834c3c65e1bb928b0d5b7860158e035ace072d437e7db750c090e7b8d0e6a5271ad2ae146db4cce8aa09675bba21b4d4d71b2a1fdc5d6eb8e25addba0b772d3f55bbca3b4fadce37bedbb27dc851f98f54ad77080c3c8a2b316b5ddc602e06b19e4784fb248455abc6c120a710c14e03a2a4b80e2bf79c33817407d54ae7d57fdda3487b6a47580243b3636ddada7440e5221d2ab10b638e495af10362ab8ca1f5664aa7a4ddfb00789ab8bd4f6ab4c4384f7fc101d6e341e2e5fe07b8f1620bc15d86473ec5bff1799c585970740e51edd0af0ef103cb89a1489d6e7a95af6f900f9d7478708a25a5f8d6122c28c925966ecb5181385915f44fd0dd34f209cc6f843aa42d2d82445a55653390f7cde13fa11451acf5a935044d1a6f0cf2f08aed52d639e9e94265e99c8ab70bdf1fa3e2b7cbf766ccdad31d9eb5e34d37987fba1922412c40d358a2780c27d7260b0f4860fd48cd4c8e3bac10fbee817d7f14221049ac4c2c41d0a7eea356f46e711222e09bc7f7ade062c86772fb3589357b8bc081c0be4e039f1de3609dcbe327c644e6f3dbd9b5903e4e52203405b203e8eb8e5100a5dc29d4e027b05afc6e7f4841d71e78d56cfbe5c16e346d04a56b2f202eb82979ab301a94211e7382aff811cadddf89ed00c8bc26e3acee31546024cecfccd9f78bb6622a1c880b3c8be94db6072c27f683f43b9ff6759cd9c220e279c092e11748d6a76b22cacdd71efa49e5f880ff1d1a2c210a47986d615df50b0be4d8ee8eb951f96491a321a7c63c16e50b7a1fe7a56ffc0e798f7c71f4ba2fd0a334b33c9a97d0382a87d469f182c1d225d00ca5b642b1f268f374344d8e83081a5f869bd9ba9ea5ee6e8c996bcd289db5dbc4482558bff4aabbab26966de24d0126f8d1154f7dba1d6baab7da155a4f0677158e2b168e921ff1dfa5747e4ffa4b6f6a05459cfcc8e7d672c11e4a0e49252d9b44be1979de8383ea1427dc170672a0c6272dda9f9b0925d3272567ff643bfc56d25307f83df0b89ea7a98d20c4291760687b883437b880a05dabf2777f52f8401f06ed8dde0a1183a017ea0a50ea512cbb8734347d4e707c0cf6fa8d051a514938c3e7d45c8c21d1a488a32c67605bb5b31e5d79d3e6be275c04213d181189fd9f3c517083a75df91551504b51fdc00435a6086977f21dd8d78f637a63e8d16570a36ee2f5bc36fbcbde56499ccd1e73692986f5b46fad3a5df2cd02703a14d23a935ded00f4999d45add87c3ea95a3ceea54c44f151c92cb620733355813d46573b181dc58b716cc8c0d6b19564f066d54beb05405032d992485779a57843e2db8e8842ef5539a5f3205c552af872e797fed51fa4e3bf44c8934db51d882f40884eb06e1e043d499f7e0acfa4bfe2bbbadd61aa06729b4da4f61cae6b5e50b09c98a7f04477f70947018ccb96c1b9551596d652031fb533c1cab10937c134b35765e7659072bdcfed4886b7c56c49740996e5168a5c0c287bac30a708120f164a515b83bb3c7e1986380d5534d783421d01c8386464c98b564d53d684eac56f9f90b39002887c911068b951982355a84e53f1fe14be8a7c1e0d88cd61c4d24029f5f3e73b9e713891a5e5cbd6706fa8844f8ce6c84c51ad8f65bae45ea6f34f10949bc98ea4ed5e952b81cc50d872524da3a1890b35e8854aac1455ca8b0ce4839420c1c5bb514c83643da563ce346463e9a809941add20199a3a8ed956a34aee13ad9c275851e5149e02f7af0b29a726fd43881f9385ec71a2c63f2eb1b204eb7b3be8e05ad7282d5f9c2cd7b912848bc771b1d0d7938e3e2adaba00f55dc4cf1f107b662ed53b53777c522ebbf192ebc4d04f964cb1e5cf5dfbc3f0ba10d5e3f6171da4329daeadca5f5caf8b09e81d8edaeab2caf150bf9fbe5e8418fdfc8b17b1d2ea05413e964b8c1e36d925009359967604bb799cf39926f6f93718f35098a09c0f0266c316d5647c11aedebea0aa7de01b669f399db5a93500fdb1ade28142d5439df6475033a93dc623823142ac0b7b6d05a19de2788bb302fe233b359d198b5b94962c934de641f1cc9b5e52e5f719d7fa1bda6cfb5f79d460c6cb89078949e940b6d4feca23318c8bf1a793b3abcc3fe0b45c7f7255a4ba95ecbeb720a26735825e152b6e1ba3030069c2885e93f5865f73c3bde6b34ceeffeb61cf7e8abc7813c5b4a7ff0d99f3c6403e8c8aeb9709cd4c64fe3871ed1fbaff39e9b769879e72520b95e4fba357dabfe8a365c08a556582f978783679d4a2571fe616d599c724ed014de391fa6273657ebcda90817625832673d4cb7a4a39db74bed8f886aaae43e33e42a3031b26118c6f4e29d125ad79970bf55dffa8cb5d9007ac450fcb5409ea2faf782f56bc113c20254b1a49cc4c511aabbf20d2732bc454f552284c451c3dfcf3a0e15251e3d2addc09e54920131581998b148bf2ca41950c562fe614f22ef7a47904268194a26dcf6fe3b5b7456d5ba4a0d788a557ec9d8830a447c822cbc9059e8756dd26a1ca2b8b6faee1d4a02c83a9429e70a315fe616eb644e66da8356f7d4a99ce54ade99ee813c3bb590aa70973b70ce26deecd3cf1b41d657c1432d94e1a3925ea7ce311f31ea260126af2955833a38759bc2fd9e2bbdbaa23b5f67556dde52c23aac3890a6838b533b9f7240077ca3f8411ad7f219e8fb84748d47be844e820664ba951226a6d1cfa50da1b220109f669e4beb60474da7a11b989457bd4111e30b1b26e4d12ef3afa73bb38e70befaabea701f8f24c2c1c98b5b15f05272d0c267f2ebb4ad1a027d4f4fa497ddd1d382b8e10309c540318638b72a4285b24944ecb5a7d27f70bb9235ade9634b10057af9e0c54e5be6ca642abed39cee4af492b367769638cb2ee15c0311266dcac3b64b6682994c598d101cf871b25aa485afd393ad2457ee8bef418af7ca8deedb8e0d3eb805ad8f50ac2eeb21d6ed653746f8d8aaf8b94cd2b0009f06eb0e28b9ed74af296dbe8df7b755792cfdaacea1597a3d2c396f8added0850fd68942dc110e4d014c382aab4b61af58d1a7f8e74326f9d29103da8682ae975ea222c6a3a3760b7f6f57539ef794f30bc40f113d7bb399a84c1ebb9978e2e8d3ec2fc6b82809f423a77373aa7010ed045f22a4b5da38d712d209c83204486802c4cf858e2338a3fbe2c2c96452e4e84a35d5203b53dd312af80a47d965db68e1ac022df707a3bbabe52e3a418db57bfaa48b654abdf801df5f607bd5c21ed71663af91dc59bae64db66c6d2c411225357769395d8d2c2994dfbc369678e1bad700c31a9192d655076b4bb538fe6e7023eb7bf938de2c18b067e8f2b81af9d053d4c90fd2f135353f1233c4f40a3f2e90fcf97036aec57bcd90d1eeeb79abe03f316a0b8e3e579370ca2eb2e0a8eba5414a14f03a181f6a63b4732584ab4886fca4d60e128753322baa608984f6d888bb499e25e7bc4782e90f1edf601a5862951c26d9e77b97317b5814e872e409aae1c441a743fe969870f6e232224d7e3c988251aea33c75b1a297091cc54ddcefeb474fa928c430d004535237d3843b0d1badf82d6f012b83d3e32f534a89fb369dc328caafe44fb86cc092ebe82b529a17c83e3433797dc2126403f009945b8c0f6e40c41613370726543572bb793a8d30524534ef8506e0c233d4e9c8f70c7a38be409b724a8c060e312d8edb4602f084671f650720808af314d386b91a7f4cf718405d82c970973eff17d5e5fc62d3cde2c8158e7060176d91abadb8dbc949f76b8506ebef066dd7e20e45afa8189c9ccf8e825486fdd7ea8843a122ff9b9f98e6d3abb2fb7df8f002bdb4062ab9b7f42a34c8dd2185a00a6526e9dbe5a8ca52b0b51ee452e4d5fc7167d1f99116fa4ff0a3d8aa72bd56df7bc76980236e3b32dd5658ad54de4ed26edcadbae459e11f8ab0c82dfac80195aa3dfd634537ce2a737b14030df19db1672d465219011a42c2dc61eae4766d69227efe5c17e616b96fbf7939a26eaf3b8708c3b8e568bfd22549ab505a983d91fb146ea044484ed789dcc6c5bbd38a95a5d8096c2ed4e6c2ff22c6456a6668325871ef27b4b7130265f0dd45a360c3fcf91387a8b4cfa341bf03a533ce8fed9c162c111df2f4518f28408fb57515cd2c52598507f56de35d6e82919339718096bc4e5aad19f8a49af56f58d67914c322730ec84847e87e8395e8fd3332fc780a65abc9af279162ee8117058c6545e0d2e792b92c8a543cd08dc85148c83dd5f159e5c18c4a64899d20ad8d544a982404f88be45e0feb70eb89c3e9318326cb6ecd1e399f12154694992c453e6ea095b4cf5a85a793ae37d39d286e063f1101d691f1936f40cfa3fad5ed07c0b249c08716c9dc258404d768452bbe890dcb5d5e9b78eab7a62ef5ac09885aff85452b7793d33c1f17ef49f0b815508c61b48f1428dac334f0318b01cba5307bcfb5c36959c475001e6df40f81f42bbbb3d0b2d3bdcd748acc9e2cb467a24fd2f3715b0b67cfd117d8dbaa2320066cbe619ef0b69c49858ce411cbaea289e0129e27c0a9cf0a7cae68f5c0427ba46579630eafccf9c56c322209f0cedc4a530f16d7141799ea56e93b4ca5d106d80ad693475d20164fc0455cb665236db02af74b8bad4d11642c48b7a0c3fa15ad7942ace6ce342bb77a7a0ff4884f9aee307cd9c6523eb2c3609b2c4cb6143f985c760fd0e7f51d99ce80552d452cbce0adcf8e9336c525ec4096cd69ce873ca5b5d001e091a5d31d9536570689576bb32326e44d9200aed3f57e20727f16df04d86d517313f477a7844b77de88cd4bf2d3e50ee269a81a23f363a1db73d50be6b14da4ca5a6f5dba4ee96368c831013a0d1223e898d001d728a465cd008db17e068e167512797ce648c3a47c52efa3f2b47648fd47b74f2fa6fb90478cd8109f04081d8d655f6c5a1edf4b145dd1fc66c69fca6c1b4ae303a055fd519bedd00d3ec30343b246762c63102136c58f0ff4902ce0ff562f38f8a8cbe314dd8b4492ab31bba811463fae648a6c33c5f91fef94d958d242a3392a464127a92007c8b90c65176bee9f5cd430b6041e4070c32f93e2d165917fa309657e4be8013f32a3fd0d5fe61feb1f859e1c439205a0878a984cfce082d03dc0359741030684cef24b2f63ecf0029c1ae7ee3e8faef8a162a6d7db0d991d208c7ad216d244be27f229d587792f3a0c2f8e11a6cf874afde3922852ae1945bce7460ed6adea194fe115e08ae3ea3434cb51589c0b2080129a9385c34f4f3af75dce05ccf3ae4493201424705ceba7b6a0aa2d6523dc8f87f971811af30b8a31f87eaa6c2beb4b86d51b68a43e9ddffe323aad223c7b630c9ea75e29eb59c7082657666c2e3f37b53833fde241e6595992d1e30ba436a7931e026afdcc944e37421d5e9509a900fb6f18a30252a5fb25f9e48d9c7ca518e95e0792df845f60cf4c43b8c067b85fd03ed9c2303b0f2de18a3deefc9591a3bb2ad4e2f6f273445db7b28cf6c7d026c322e8a727d8f631f577dfeb1a061bbcc44329e4bcf8a3afdd18ac122f228f8f817bc1786a669728030f3384a6f3b390b88ff0fc42cc481198892a9256d29165e7400319aa1dd5bd71db2de01b9ff82b75541302c0b5e80e25adfceb35b36a7d0b7e57a6bbbfe87ab0c5cacd12dc4b940d7d08a803bb638fcd69fad6892778c23ba31b9044011d399039b51354cadfe4ee4d0fae8ce402074c232246e7a95cacbf2be168aa4e3fdc5201f1af34a83df0a9eaedb9d81f9ff6190ee06b033431fcef4b84cd7112f9758b033c93cdd0483c12c151c14367d6fa67ac5e7b0cfbb8a59202b23f4794fb8091df1fd2805a35ebd2e06b909f345a6307ff24179d8bb080efc923d09e6d42424e6834d023a030758ecb4a10175d8156578b493ade0d8752a681e4fe6e1037ec6fc1f3af0c89a04370e58ccd9424871e5ca9b9afe498c5bbae7b27b7f90d6286dd04a27cf62dc10e7eea51c7982b0dca5aa1f97c258df5f24c124b472b58fc60c9e46cba422c0c7de739fb64a319d3b87670f3b7fae7317710cdc4f42acd1261b1ea2ea6e55c18e13a676f57ff646319fda376eb7a31f8d734d0a81ff49c9b3da48f7f93bf424bfa3b72a2f60edc69e5237e6d111c02dfbbdd154305ee3feb8652b2c8d171595f322d2b60c41aca486ec75273e045211cb8827134d7e72a49dcb696564439994d6d81209b7c8ce5e36cb2e35f86aab6749e57803e6293b3ae1d29cc96b7408de3e718b8041bd91a28cfb4c97b1d0dfa8d17e2d6061e5a0c0330281394ca53839470d6290a2063b29e5db63652ac217b8a786f1cc681774f6dd6b7a7a89b344b52966862029047726773e79633c57e86d79e58c01afff1617025d6b9e4925d7bc3719573a8cb62ee9f9e9eec4ca944ed4568c7356e0dfabc607cfc21e8d6c0bf596de0decc76895f1f7a3cc7c98b77f4a9ca675bf73997240c78e4e8d07554be0954dd7b5f84341c053f6a7c6bec38ab47a393d0a86ded1fd35e997886f6ac1b3ee23f5132a2be8376d023e376ae3768569ea966fb82902c3e33686ac1baf98797432ff9509e5dc6fde60fa3b36ec425ea6855a77555e5eeaedd0a9434a405e588e2082aec229b8d23d532f4f07846e600d3d88cbc7c9230a1deb3417d11504224b46eb0cde52290be2fdf27a9203eef5001a35ade238693eaa00f78d0dbf8b1d612e25e1e3b549bb0dc56af8b60ee8e9a5633a5037ab3572996fc5c56deb71c79ca7293c22e8d4ad8035f709a13bfcd3c87ca73c4ac8cff96228011c96a8fd20fed64536e4c8effa884cdf9ded26103bcdb3acd60775430f20249434aeb1716c58b4f834d2a858fc65aebedaf04d9330f1eebcab4c3b3f71c59709e9f5e478c15efe3fc70fb50b1389ebed4acc8edf007ab2791139747de64c79cf36366029b3312f9c1fcc59b4f4aca8a371050c3e29bac434f24547aee0e953a0b29249d4ee197f3fc973f0cc99f7895075ddf60132f6bc3bfc36cbe3c072b860e49aac42052916b9a5575adaeacb8f3aa3a18e94545f0c070e0bb3fd55fe9864dec1016b78eb1716df8ecfba27786779c001551d30083b0e43b865e1523a99a7dfc626e1277a3b7f5611876463185bdc7be9dc6b111811297e3a80874b4e6f946769222d0f1f93ab2f9c21b1ad8064b90cdf1fe78e51f67706d8132d42749cbacb433144ed738ab96d21028f1e21e2e02f03b649ea4092cd1a6c8fe4d91c85a8bac264da7c845faae4af96a0d2d6f606e38ec0343d33f265693036342c7aceb5b2a90b2bd4bc2875fdbbec474120992d2e2f1a064f9490295ae6f9b1f1fd0293aabc43d85a85873b734a8e89b3e5979cbfd41172d7b022688da1ae5c58a5aa99e7d34afc1e9b72faf5b547509baa1af2d8979419577757e77910e5b4ddffb49259d336c39c067735057193741af064a82859a8c2094fe3db934fb4a83584b9ee57adaa644a4227781f268f9e2610679cc638d878bdcc9a85695795c2b2ed09e093caf0a3e99a26ff846447cf3df507dbd426ca3eb91677e4dcb11f86e604ab43d93757d3a49d5f2052ded73997708d9b850bbf3b9fd6a3bcabaa2dd566cfd2161f957ec0939926c673d939f38f9c492380b976f88e3648715f7d82165109aa3f0fd52ce5b8eede5d566b683c6b1cb7aee672a93fb410b35a34d3b0adeacb529a568b560e2cb1021603061b8caabd41bb78d7ab0a333859d53fb3bf3a25a45604364830e9e70ea53ba1cddaf184b72c568fcc86d8826a938ddd315ac7dcdd652af4e493227faf2e8d4e72d322cad21d1b84e31b3ad590a25f2a337cfe78ab718b88c6205338c794a45b97815438a5bb1a3b34a5ce75a7d82e6d462658150e3654b52632dbe59fd3934867ec368f9e43a069133732ea25d0faff0f0e86a88b467c4a7de0057c2770995e60945c0434a0227dd7a67e2e5c5260f2849f987106e74907c8841d1ecc9b9620910acd358af40c91aa53aedd1264f41ad3cd11af79f185936f5b29b9fbbb48289bd88758a47ee35e4f9f7a6a7bf0ea5b568ad9f938605060210dfebfbd5cb42ce85289d80635c49dbeebeaee1bc8bc7c44b3e693a1800cabbcb961462c76a5c57a361268c5cb2029e2a9fbab08348bb6e0dce84b73eba93d5b751a53ab7b4e3e9ba56bf58a82704282414915e09dc4d35dd1683ebca4d702a37e21e7a5b5c268d1f3bf524bc97455fdd369635bb5d4226b23ad3ca06c382fb9c41bcefcf58536514bf53988ffd2df42ee66880631381bda1ec619850c4e82c62237e99eb349a4e5ea0cde9fe9b8003452b1298a49b0a4baad356343f2b97e33d172a84bfc848115f4f26c8c01458f32717ec08f45d5933256c53bf4733b38e2d45f171d689ea9fc72764d985506edab0e70363b000039c5595da1e150ab9448fd2efcb1d802228e4b8714686153b097f6e14f6df8280a6201ef93382ac20b641fcc37cd74735165f0592dc1a97c3d2fe8f942831f7ca92c70216c2ea7d483c13ecb680d2b49e88cbc8f11493ad7c17ca05e29700a6f029a3508258f79bd873b665b8c4c25274c3d5403aea838e6edb5e4dedf3c0ca2b2fad7f4473a12cee7e1a073ee399dcb2a4b37d05c305b2a318758011ef8c1c52be399b1b563670c419def524911803888cd8eedce2592ad31bfb6bd545e98de0dd74f6f5a0f117e10249dca48be447b10ee0e7abd22b937c2eaf238b0b54b376c9f58b3af92fbc53dcd99f671fabfe2552dd32c323ad40023b45d4cee3d05349ba5e5a20924e5d954a209fac3f4c094ca929a66a4481b89e3ec56f8a20b984700de7e30cae5d4d973128aaac677be43f90e2869cea2d52d17aa21a739615d3b5cbf2ce393315702f4c31d4438a9552db8c03362a087b68cb961c6f69f6a0c6660741b230edc8b58776bf53d0dfdfa369a1a2b67f184f5bac962043c74468cadc2af378798de5bab6cf89e0a3d495463a01ccce8a2eafc9e70186a0e0993f8993e65b6451cd094e263bf03ac6996dfda728d6188ad1bb3e879ac65f0ebbe21e6010262d34f93fd0b9009e661b03c07a6e6a9ba342fb762b626a551a106ecb5382fba7e6e5f8384f95660591dad898cb38eb0c7098d59a9c4cce9140854d8267c4e2f56148651590c0e8bc11da773c873f45eacba07ac07f0ded01166eee0d76f61b236bd56d4df4db5d26db1842a6309db93fb96e59b8197da4741cf6f4287e57286da80c8859a55ed18191e2e4f304b2a3ee4e8f16c4781f66a5e36af7693c4f66cde8d6a9df29c3208f4f8f92665378171fc95f1346e663a571043bfd9b4aae06b834071557d5ecde1c5c60c3cfa58a1b404a9cef2681f5ce20fa2b0724f603323b19a7c336da950536d5b2257b7339c2fe9afe18d8c13825075146c643364dc8e6d524975c3769e07a98a7128949a89d88d2eeab0bf78c84c71e8f46697ef11a5d91577fb3d6cec4dc39762b41c2c40971399c6eabaa6e70873eb2c1dba47a49ecbe22174b4cf12fb1bc2afeea835fe151a925155d4d392580c4127fbe0587ad6591298bc9785617ae7443f1c25267f8387d4bd37cc5cb9a0256d9a3b723a8ba1e2428073e313084a0028b89b9a3232527c17d18e45443bbc0b51163137da53b42c366fb362434484e6c0ad6a44acccca02f588afc12fb52c3842ab7504de8609c492952d6cf78a2cb652c7f85469de7920f76749f857d56318d4c1460f3a575f4b2c1ebaa07577857539684c160d8cd80a9f11fd6a109a38dc5c8792280d0cb5450114f443b92679cfb8bfaa076a81d8069efb9930dd523e12d45f824d534a4732664971348beae2ea5dd779cbed67ebce2a6e79ef39e11a486540f2a7fd7e0be2ab3408935143663c8250813bd07117697bdf2b35c69aa45225e2e7a1a5dd00636c80c12f2b40d6ef4f681df2eb073e97cd1729beb681f1a9bbf591bcead4dd4e8a856f1cf8f053730b7c21d3f922cdab17e8185784dd860e46ad30ec802a31afec0245f1af099e0c31d7e0a01b6dde893172dbefb99167aa348537c1bbd6b63ccfaffbaae19235d7a8dbeb9315c5c99284861bb7aab69ec0d72a47972f9384a3960981d93bdc07274975bb3ec46ae7a10813828c39a0baf977d26d4fe6e91da860bb7cb9a42efa460255a84dd3d98297c00db73aa21831f47d9b6ea749c3e3ebb31ce6b5664a32662ea635d2601ae88e3797b7fdefd78dd09e91891533cb5e044536ac91c7c37874268b4ddc0b3497ca0a70b5a81c5fa47b165b6f5a2fcb2de1ebfd6adb11ac7f37bc65a4dbc8a8d2eff03ec98759ffbf310bda4a3814a835ac2e826f5dd241a5b8681d91cb73bad5c3ccb14bc4789ba3aa304914ce98f354ee82f0523c5823b6805d1bcefe3b0e7b8fae6426f7228eb6b4e4005ca936a5e81369b14c91b2aa1c474685393b6bf800b3bce2f5d51d5aa305b5d11acff632902b836ca6e7a043935b639a47c944e51a6256aad3ba4a4dbb387da18c728f40ccbd1dc9d4430aaad6021417377942a156a4d433de5d02bdf74ab3aa04b6d3bd0c6d882ffec5e3f98b38d6723e5233d0a92b517e92a93e512694f1aafb5aaef4aa847ec640ed6521cd43753147ad63f26f97cf6d4bd41ff4996ccaa48b92cadd63ebf45bef3f1ae3ee16359cd5ed23c7717f36d5db65d7a7a9548dd88e3686f1c533a1dee2e1d659397070964fc0e5b6b2f27a3160ee61ed81200a2032640692a5f5e0e3a66098541bd35ea8e4382b25306ec139eb299aab61cd4fe266acf1c7a4a07ebdf704c3306269ed88c976a6085cc3d0ba0b3eceea8fccd91393b5554063acf98196f079cd2d91912f8ad6a596798c027e65d1c37d0984a6b177623080b39a30fb3838eea0d0e3569b43f8d1a1a2b8750c801fb12e21c617e37e58695505f616297a1f3bf972cce59a7e23e3c70dd7d1e82c480bc86576d7d8d591618f20f205c2dd02786914e572192854083414da9b427622c593007e583fadbb0035b1746eca3c87f9e0bbb760eddb7a12440b27988cf6d7d5f335961145dfac5ea60c785dce2cab23c4d96b31d7207f03cd9cd4a77f53f052bc538bd5a1f73afc96e8c4efff2050d9110c7f6a2db518bc7d76dfd797c4df2bf9b0d2d8d594be7b0e2cc45732174a1b2a5158646724cd3af613597df20bc69aeb3649ac1458ef870d00cb427ecd9e423bb81393a0d103ec49159ffe7c1c4a9d307b655d4739d8406c7894311b69bef866b83dabc0adb0fb7672e926e99d46a92364e844b50dcbbd607870276524102fa7d5436bc8efce8f78f4fdd9550fb042a13c9ca75894cf30df6993d8926b90ec2c2e0e22ebfdb3f6a9da043f5c26ce0c66f4d1355b0cc68b309903177d71d89a346a9912ce0ee5bd600f7f0ae72bf70cf6eb54a830174cbb1f2d29fb750d9eb6928ed0064e80dd92472c32fdba5613e20d5eaae8112873bbda708aebfee044908811441ae78abd8741e65b8137b568b8b91542fd6a8f378bfbf1f497c789c874094359a94f5312505b447343a83bb49bf0224ff0c109da53deb207da7814da6d1980487d630c9272dd6b7d4e96d30fd7b49adc3ceb1323906041c8da04c91e656d975d524d2171efcffebf22596d3dfdadf27c2de281baff4762c2e234c25876c11892f7d92cfbf4b08d4b3b65870c11441b6afa664acc85e754009ae5d4a79a3900b0d0c5e00ccf1b670bce82361f9508e390a8f58c2d7a7e44b88fcf969f0991d716a9bc89d1774553667e33472210172010b57d137dbc51d39542af641353b4948a1c7021227a0637205230896908fbd5bf5f8ca4599182a8be00fc5ec670c7d960900e977bfb0335ae8efd50ab9087b1b04ad54b6971892d7ac377e342dc06f289b46da884add9cc3a37cb5f612e9f75987612433868b4bb7696c67f8217055ff4135bc0b66930fe8933a7791d1ea8a858bbd372868acbc19ea2b1af87ea6533fd74f5c2f99fc02305e07305d556c1644e5a3d4145b770185b1c27c3e979a0640008de6196a9bb45ed4bef1c202cd022a7ede6fd826e362c8b151da33574e9a2a8f5e1a4c83187d494aab0864d2dd2404557fa1e106560c7349bb7cb316d3b1197a890b42d4636652510cd8e44423bf6de5354f1e6da62a2531fd10891e6d7d6cf80a752c95f4b24598272a294dc99e15511357054e5e85d22fb5d55362ab83c2f8d4248dee4bef4a98938a2abfae1ee9aa5cb39bb1e58e64f26c45d23a8ba3aea93282778e8ce6e9afc41327594b2737d731967564aac147fa78074cd5a6214fb83f9c197186c5a9fa25e23af03e47f786862978d1fc26fdbc98990341818ac7cf9348f733972a2fabc589e262bdf3a11d3d91d75fa8b24a55f7b682852682e1bface5b358fb181431c11866445dad81b8310ad76c97058c21485deef81721d8a2b34c2fef6ae64d292d0b91cbb1e58b91345ef99943d238f31963882dbb525c999239ececa8f7f1407620486f276451244b70246e850d75fa68618624dcf0963d254fd84360eaaddaa665a5c9028881c1e1099ba688fbe275e9aa9633a71c230f87c833ab6a8916592f0de7cc59c1c2ea1461e95103cfcea2d8a6e900ccd1ef9d819f4e7d1b2b43e9553c5485670447915076930663deb74f90a739746565d475f755006cfaa091b6dbe75ba88111a2282c9531661d0085f7d5fff602bc59e5326918d5216bfd904271332e855ed64524746086cc86c26d2abb08e09515dea7ff5b1039726ec0cb2d617985b82a78238f5ab2a57bdfbc1e34899cad259418366093d9cd6129c06d688f6b310d6e2d9d1d17dccba16b221f98ea809c7e0a14a837993c3d229b39afa8e550d0043d9ca97f661b6960ea37ce5c24f0d47fa5a98fe2b1fac993bf8d45caa78489b948780a890fb5fd3393d93678e481410c8a1f4d4f442da44e51de9fa9fec139f1d64ee8750aec5e80883ffa53287f2c0bcdec054780c5dc93abe399f78b60235517c53c003656c4a795c6ab284e7835803a9f1ce55408d83a31f49d4fd683680cfd34ec01e4f00d6a9d2d014dade9139a91a459b26e2b69706dcc81f0698b0c35a1f1c508c6039bc25fef039cda5dd000af004a1f308b0661d6f441212fef63afffcde38736dfe8f37ae8b8c192d6ccfd1d1ed26bbcfeabd5030d03fe464493b5dd898c2aad6027089392ec2ecaeb0da9347a70bf92c0971196e4df783c0abca8db813ebd247b59d493f1513aeeaa3d23941b42c9bf02189d58f681786d4eddd7cfac76265c725c53585ad93c985b6f4556b9931d11a8d029a9a5fbc327f1ca0c4a778a3b086124d6c4fc16674f2eb1d903b655b8e6e09ea506825f7fc07a0e8a27d863aabd61f7e8a80488e339b422abafb0771a88ba07a30216fdb31b6b537c29cd9659f62262cf7f618c1a920a4a586a226d6e11f5335f27fdbc36e5b07974e6e2066013cd36c06c412c4031545da63d4baa32737ca55629b0643b86dac7d0e9cc1245d870f9e3764c4bac2d5dc5905575ef12c598519dda946ec5c9b6cb07f284c558ecf570d63108b68be10ce69c2b75c248a4812c54f64ef180ddf2ca5181124cb2769ab42a8735433f312025caab129d6db86e33e481dbe37d1c4ed084909ade019260b0156b3078fa6cd1e1475e31ea3a0cd12b777a5fcccc6e3f59414b2d7672b74e696f5841debeda348d7f38510b3f7ba91b7b5312814f75715b76086a2354cd4890b9dca21e9213f69975210199d24371a30d37187b2343ec875102ee212d1c7cbed738e6b21d69d1b7abbcee387afc39bd105549dbcd591e9b22237059d138bcb099f7194f3899d26420270daf8ea7c88ff325db5ceba21bf2d22f22dfe57330a30dc2f3a6b7fabfb53de3a53d5c063b5550c051794f6be567ddc1ab70f82684d817a15e90e69e90cc8f2d903af5fa026d9c89e0aa57be812ececccfc7869125159be40c45491f72eafbef0594a316c38f0b53dc98b90ffaf3a1553f9183c5408ccb4916cce198279a8918f09af9ce6d7f5f0379ca9b619c2dee57336c5e4d129344108645e4ad5d2ab1742209db2431de5d6992efbdb553ab05182d257867821bec13c96ffa89f68ee868aa4a39bd8274ff63c3764c5b5689b3ae5cc5101d7f146e2d1f4345f639736745fe3fac8bf48c4fc2380c042278cf3359293671c106f40c5aa00b004d913ed08049ab212cbf6e74405328acce2e8448cb180c7212282baa37db42d48ab12ffb79b260ffb91216b6095d2fc689233559a91536766b249726b73356b6e32560d32aee905d5e5fa8961b9d07f7007916edfac480abc417da89fe2b7c2d6d7d77fe4b7d80893d226362fae1ca1a58b072fd67ad2e095ee4f2bba244e1392fdbf6de5305acde3bb4fde6a781d883e70a7737a2357efb7d126b731344f5004ac852c5adb59325d154213a88efbcb9eaf6b5ccba2f41a04427d5d3945e4347ac5289f2836b3b488b869c90e6e21d832ca25086358cbe8287574cf719b0156716ddd3404aa13de099749dd4361df6086cb5e7273585aee1a82d5d04414ba878912049f3da58ae29da53365929b7ed403f0e079fa45035a97b78d53caa8dbf99e1a640dabab6d342ebeb0f7daff1bee31531f258e9474642acb5e5c7481c5815688d80469d52c12e8895049ec66911ebb8ff194458229f8434d01854cb09c3424c3b5742a524fb28b16387b8c64e56da831da3d9234fca3accb43781f6952c16efe0488281649f9333fc15148ee95726b6a0253dacc9163e81b10cfbaefc5a425afa4e9aa3630261fa0a5dc2fcf107c09658c74f6fd5fdaf4ab1ec4f7e07378fd00c1811b3d73cdc215e83b5c57a871c286cc99be49c3ddf5d976f4ba75728fc9e7f1ecc67400a2c56d1514d242af27a0f996187202471a13452b1e0946dee4c1d3e3affb44c37130fae1742518c0bf5664d9f6dd4fe7c3aefab8a001fe456c00b70a81dca5a11257fd93dab7094eb1ab3dad9d75737f12760825a6dba2fa4653d9baf9e7cecf2e199ce0d0b0865ed25d6479964e6350752ce5fbf05773b00eba718207da248e9843e2f0289a501557bc9b2a4de659410842ce3cc4a188e5195ba89f979fe59dda6d77e22db0994fc3f951d9d12839f398d540d25f695449de08de2a59e96ada84509b1458359df4035d64badfb945ba2a31fae9e5979fb9dcc1852185ce552c63b1bf031f35546dac38530acd6bba3ba8a275ae2e7dc8ca53c1a8338fdf2aacf8c93e66d73d9cee5546b723aee0dcba4facd06e53096c53666f36691c6e99e0999d1fa5faa54c740d88ff482299e9c959f8fc572fd221212bd20f7e877b3b2b40625142410b28cd88f60de5bc2d4b78016de248d6de68bb168b70da97ba402e61721a94eb5ee8746749e1ea7ca4c473600c8b2b1c88a2c07346bc734f0d682550086f93513a8ec5ba2b697c0b535304ce5eb9116258040ae95628183fcbd33f1300624140353cd2d50fe0e18bed8ab6ceae4cfd8910aa2d899a10c37b5a1025a2cd0b3661e3caab0cb7162938f4c4f922f20f238f546c1a91612b91bc40c63aee13a3ea7842d92467e7693d8a56758b2c2180b6ba77e925b88fba3ff987b4f01ed1cc8ddbeddc54573ac3e7e92cc2de6b31f94db274632ea5e98f905caa28384972745912e10f7fbeac3e5db5af2076ab96203f2dd11f9cbc66c27a69eef3e107c6d7b2265e06c75fd8fce9f2b2655c42c6dc1ddb5793d8a321ff0c81437693f0598833e7526bca924a9fba79bf632b396ec236f251ee039535a98311c2ad1595e4798a0d280ef925da14e718dd7677c4c811e22973d8f867be82b03199868f343e9d36bc71670f98924d2d2439455520e34c8bf6ef66d7a216df21d93ebb6b5d9259a2334c447639db58b70ce90e03e805457e762e89c7a0b4289a93dbafce5f3cd9bcf20b86063eaef87d3061034267c34e9aa06cf3104ceb79dea4f66a6d85192adc17cc8cc4226efe1f29fe7b5924d2609059d8e967aab7f59530b937cbbec2329c2e496bf245c44035f75c5179cdb2e0b07c5f509bb9477b46bebe570dbfdda07db7caa7aa8499ef4feaa0df6a11d103bed984c5a77754c9f01c2d4e09902920f1f8e2dfe2f8559f1544d838f9b19b5f7cbc8dcd546f8c35464092b4d7a741a5a6cfb6dc430b608c238d8106241e16ad447b850d0001159c1a32bd7a938202c3324b90f3302260b8d985fb3c0dbd7662be03a2559f268ec1fec92ea79b6b91d6f4af5f47db941a3d4211ed98df87e15443fb73c8f5a1b23ac1bf6b9181b4a0969be90131d2a96a6a4dc5415afb0e4ea30e07b196368628627c403f0462931431e6477e64a05e9c5a377c414ae19809e14ecd12c7dd7877ac8f7d39bff0fae91b1d2c141b922fb25133b581448802bddc249f8bfd2d592fee9d6172e9765d4a7bee48f399ff3b65e7fcca1add41e8bfef6dd93719f057ddb0fad8fcb48930171ee55c69f05c811abfeec7f6d2eb15a07ad7840d275715ea714662132ee2ab01615297fc09de30202e7d19532632e34ea339fd9d15404c77c8c185d4dbd1f49a5a8dcb8a11b29f2f04c92699ff40740f469d690d17d553d443cf699f1af76101fe54521978e1de0387b2214b3a5fb5394fc81c5272bbe7988025ded8c3bc39c95a04ce2765461ae7fa23dc42f190c40252abd87d5dff74e01e98367b856fd71d218c9c988dc655ded9a65b318b001176225775ef3a3a558059ee943fe8eeb49438caa91f59f072b2fde2ef4a30fa2430c4ae9f0f5f5a0c28501db9479ba397c73f918c7556749bafe55158fee325d64e7b992b8871bc29820d4dfe306a50a11d3c6b39c988c94b7ec4baa23a0c7777a8d7d35dcb1052556f1a4b20fc5f99925b94905b3c933d1b471f4d1f416d885e859185a5e90b33878ba98bde53351fea81fccdc61c8e5d55598023c841ef4f0edabd924b5aa6fd22461671fe9428d3fe72510efa066faf4e7970b52e4c90a3f76b9d198a2b27f197989e21dc55f67877e1fbe2579fe965a1e835baeef12d7843749387d420c43321514cec6a50e98ade8750b066e04d5e07b90c40c14f64178c23c913561c00a270eec57383763abfa908c8a60a9fe9dfe7da8f16cbd6470298fba617b5230b17e9039a3fb2b65fbf02da625df36d3073b5e6bf6bb6e843e88e02f2946c15c0454b53d626074a9f2eac32948425be038827beed30d78ac2d7ab48b9f5f68c4b9bda125999e2590c4978c8d7924faec81acd9c16e0af5bb5433f969e2199b073d918151330189afb9d82536a811528af12f258ec1de572951d64a925224c057c4883fc0f8969a04cb43cac764637c3853a71e34948055e802e5a9cc1b2a035e9884b2245c4a61cd3a9f68dd2ce2bea91490a2daf477ce4b7b735d12f2ed66b08858a2a6e9a74fb6b0d9ce1b50a3a451ac1e5142e7825cabcb056a5abdc65a19fd2d2a355001995df15a6ceddecba81cbb9571cb30d93f2dc960e1fdbc6aeeb381ff8c76886577bd9ab6965e1c8b7e57a0433ed0038586ea1ec2e28df9d529ba5fd81d35c8cab69675c0c3d38011f2df351cf222796322f4a41f00770a51f01e42571c2541283c30de58939782ed86116e876a28f5441b1b71b0b073acd2caddd53df0058e2aa0d755a20067fb190a59dd2b0cde386db2bdc878256c834aebcb2baf2e19bb94c1dd8aceda244f23ffbba44c00b8cdea2152efc5c8b8938cfce2c3b6ea58b5f5f66903d99ffa51520c07c010236098b2738e055a35a435af2bca8a676ad7db2ca90935887154ffe92b22df4f36498f74d6cf1103af967f03b9aece32d39ca6e97706f51c5f46174acf8323c2922d95b4e52f59f0d4e4682852cc50e81a568f108428294f4b97bf2e48be4750903bc1f556a81e2915898ab613da185889942c1089c9ca982bc2c72569d9b6d818acd00cc81155f09d07bd22051bbc10d3b169c6cf5e52c0f6bfd69855c44f490beee9d7c96882bf6ab2f98cf6bdfdd1636626d0eb7dcf82afa0fc7aeccb1f121904d8d39c3a4dd7731680f0d912288fb8819ca9b117aa5e51c471e902b97fe01b932cb70d3a7c992bdcf58acfd0dc4757b49123a9435729e43ec8c93957a1dd6732afcbc4f7cc1e064fb1e0fd01cdfa76478fc9cf547b7bd5f28b613bfa6754514c351c234ceffc059c7a7d26ddb792ae5588ba8e43ef3f5797f8d05c153fb9fef01a8d2b5d7258c49f3808295204151b2ef80bc171c7a51b7cf1831b9cce9da4c1cf435ce661ee636a30a0de9dee159fff807e36484ad5cf40c281edb6f3675e3620e86d6be8194967834d9946243822177d8b126e8b26c1d08d92a1387d916ca0e63c43b8b8b5021e3e0f312be8940e238d0e7bc75d89d4f7726d9b4f3ab65410a36aa8dc1d0eeae653af9c06b5bf1f0ef357c4bf2fffd9a8e51a73de518cdf89e4405882a83c2a74f44dea104ba22ae43abd72d32322135eda9df2ddc34a7f2a2340ea2649ec762554c3165272f9ca231f97c086a3f06e61369f77339dbe9bdcb23b162223e5254f7b4ae244e67231b0e65f097c5c4b5f41bcc570efb0baee4e761ef9ff88c506c33fdafdcff1bc0d4eea4d69b343c7eee0ad63529a647d9e53b69387d35b6abb4b6566b63ba84ab38894f85cf52355da3682a40d23928a98e61e44b2585568fa5e867a048efebd1f9539cd0e90ea220c7e078fdefc24bb6fb542421dbf858c8605d2a266700ce3d756e0c7d90cd3ebec6beb5e8664cdebddbf38a20cb257b8c0398b95b229bdd782b73b00b160d45c2c85852dcba29538470842bb2e581a9031091e0c4b759dce8d564df18a093790bdc60eeeb2fba24badc74070fd8a2ccfcf6f0c8f9c58bfc6564d208a82ce1225ea27cf6df966129f86faaac8331cd1e90f147751884e0bee8d638294b29a9dcad6d7d003346188415a71a1b1f8673cdcf9ef1dfe205812ca81c918d0ad654df44012aa14704fe22b18ae0674e5153e580d4a4b13c6befb9d31f10a2840fd67bd05d583a671be8ce4ed7a180b4982b9088d0d273826d3a9e217d78c031c02a1b71a949be7e1dccaec94d605b652d3bc96b817f908aae0ea535caf914269c2eff2a854b7aa0e1e46ce36b78aa8f3ac64e4aceb00808b0d6a2e19b2413490798ff9f87d62b99bf9db3273b512aaf7493d58fe13248117fb16e9b5f8e0012717ec2e2e9ce2c3d0ea2613ba9659d39e3c26dc3185eb9dc26f4e9eb6bbafb9e6c52bf5471ed2b48bdf7e132db043fc8b5e4c8e1846a238601859c2cc2d3740a46947ef38b4360ee55ad3f97bc6659852fd5a53bf49266bf1c265f77dc1849d00b81487210366b1348b75e0d50d66e563f8fde87191b2d9d465c9b5829207a5d4691a055fe3c7f7ba2f0e79e111c8eb5e72fb02be271d97ae6c783c38bcc8dbfb86d1761dea6e3f3b4906777124a8b74dfff88c705c1b554ae95b0ec715380b8e1fa16e846b734d829f1be8fe864408bec2c338703bfe0b39ddd95e670213705872337f2fbfcb0cdbb22eefdd5f2e5e1e8f1e41ebaa72882a08f64828e8aa2dc039657efebcb3c168824ea3bb7eb438bd4c1132bae85707ab6439c62b0d1c972ddb4adf5c2cc91d8a086ca8627fbe8d4cd33a6e71f75756549843eda43b19abf4073f7361e62836be0c104130e9722c9ea65a377d7873d8da6789799a11b64d15704511b4820e958ad40212b2f7f6af7acf71d2002a55c02289ce8b8dd66e1e5d8d5cf9a0086375c3d9d9581c2bf93ff126295782119f7ffa1e6d8c94a742cb8c0dd256634e756f97b4e6be462f400038190d1a782ebdcdc1921209116df5471aee1b566c4b46a738331d095dcdc51f34e26820778a29fe880ea8a5c5d973dadab702253257c9689345ee7e134458933d38486354e7abec4e015753b675464848baca79cf46aa4dc4fa13104c00452770ea6a5923d06933b1ecd37dfff1b2467ba19c867d0d33309746f528b15f99b2a61e664249dc96ae2c406afb93332f98f94ef83cd65cd07724641c8ca401b1f6656fd98e2c9798ed271c7559cc4cef0e7eb9b8878488a39936727f6e8d340c08b6e24d4b55bd9db2ebb03c24d42e0deb85c477d4c58284259bb62d8040a6b1767727d04ad0ff28f423df6704328cc09e1db08c3321635765e62e5c65564e51dca12d2b5249b2b707a5fd0a48a4b69cf9eec0a6134223ad8a682b13d60e8f7ede1fc29dbe2716084be2561674eaf7e3120222ba90e259963476b8c8a0e10a8ec1671d34e3687e928c700711369808dc7b083fe8fdb5d88c68de2edfbcfe1f7380226340db1569e9ddec149e1d9fdfb9a2235e2867fda23bbdf3845bbf1693e983de7440d40648c4f53dbf70089f0584341835515b384cb2c124f28dfc74fa096339c8e8d724e76637ecce7872dd2c3a170bb5bbfd53a065c6430f24059903dc2da80ac623adffa35b0529e6c3c03345d95742ca9f0d12af91e3f3f4b2d0c16d5dbfdd9dd0551c644d82ca05f11215d48c298f597111baf9a3e2a4c505b68d1b4b9079a1cf0c2f51019a05dd7642a5ab68755ff65ab7f410812c3d223e882c921b6c5a694c9dc80fe35293ac296480d468d1bca1f2ec9d3bb635f2111b7fbbe8992cee5a43df6a5068b0d2e6a260514de1acdce8cb56b0754fcd58543d4034580d88a8310f55a435dad19572bf59a0584de143b6d7d88e842471900a0639f30cd7baf4b71c961d1edeec02d948bb055b4dff1272ca82d758146ca71f561856cd7e62fd446ee1af6654284cbd25cb946d983a8f231d03d693f119ceee0ce26a94c5aaf3d6695a23c81a67df2f67a99d6beaf96a1eb6aba10a785389ddae80e5324826846a4d82a217f323dfc1327e7c691dcb56eb7d1d8875064f4ecef82733c92f717a7427d7b4a3ffa74c44fc0dba6a45cbe19f0d5558a9e9446369ebbc3d92c8179a2953ca5e235515fdcf5235e86f77b2e10bf2e84a2cd9e809b413fe0e9d2e115f6098b66055ecaa93382e37a189545b6da80ba747746d86dcc67fe3f088d50cf69b710548a6c45ce2a74da7b4b45de0bd13612c21ff67f62511cbc459f8404d9f3caab21dd782b58a643315bdc913ef0e9ff7520dad085804ec136b49a29f83b9d44ca5a283947ba42e90c2ee87ba257fd376897f22d105522c2c32cdf1aa0abc968ffc2576de68ebcf4a45be8b9d837b16933493a1e1d76c417372089260ef89fc9254654755bc2ddb696f5cb92037df6e09f4ece792e4cb1af7676e1d945e8470d7c89c6dccb73395a4c2730a4ca272e1c343e2387541c28ac405d932c31e19dc39f0f162e89ba2c793deb07ffcc6a09fe09dbd1b422e16a1a4409cabf9e2863be0b6f1a87ab545218b443b450b06f42081624ab83fa690db52b7d6cea5a8208ca988fd4664b86070aff3c1bcdd1ca8b8cf428c999453c07573810490126010e3c40a31b91fdf4d410f3a016e14a81f50d20e0fcb9bd75c6a3e1fffb1942715f6127f8919c674083ce7e11ceeeb167941a006ba400dbb3ad1da6c0dca83f0bc118df8c7e00927159f7b09876722fe0d744ca692177c81aa165e80a250296cb5228d36519671b0871169832b36dfd8e8a0a9d842178d91d692de5a268bf9abb6b0ecc609fefc004ab3e596f006756eea7559e1ece4e75eb4f736eeba1d2acb85afe42345babd02c5c5e36f8a4d7878f76b4bf365f2736247c47fba2c6e600ca5bf9a0b5838c3661faf9d777f064e16b05fd0548b61c2d9d54fb456e4a3a737bb311e291cb6b2053ba524fb020bb2a9ee596f178dc5c7f40031b241f2615f47b3b472c424227931493a3d9fb0af6f595331a135cba6d22c32db3562f8f9b2442ec72e9f8152c077c8bbab5269b832260a8aa1145b753bdd0d1f8854b9030e1589b085b377f26672a982a184a3372c677367d896c72473d5d03905a98604cf7578955590e5de3388d76f3b2e41eb111ede4c33685c36bc5167c0038c891ff7637417b14581f9100dbb71bb382bb603b86425cc37e7e873b823db3227df04a9ce0eb67294770a0d1e1953e572d035dff888fa181de15cb8995a02543371ebb6a05ddb207b528255d6ae71ab584d7eff5b5cd74298fc871c17e7724b184446cc4fac6deab43c14183a9864e452a828d06ec5c5099968b30bfe73d4315ec18181ef1dea9eb95b90bbd646a53d1810f6c7e1b53586df4cf55c120666c800b804b0781ee854dab5a3faa97c07ccca692cacb7f3dc740f9d4eef14ef69b84dc6e685a581da8df6c1fcc78e5fa07104932898a7201fb3de62c5da494e9298dc5b8461ccf8e482ae4652db8d6ba9d43a2f8cdf1e76976ec5b9b8e637d85946a2532075f48b7a78e917204b20f49529b1536c36f7ff46bfcc678fad0c6ec893e0045de693f3fb32320c829cee77c568277dffec26d82e6a72f237f81150ea8f73a20cafeaa63e566e529a7d787f5f597c7c7135bfc8396b6918340c159978ffdccac9297b18d7248e66cf17989f3a49a0ebc5eda6468459e4c38d25389a0b9eb320d112bd22a5fb56dbc4279896ea5bf62deafe00def8d0d1c86f1a887894188ab7c2df2653fd93b1f74d71751515cd7b47946569a6491d0002ae8c8d352b1993dde53f7b8d027cde51774f19c2deb11c73c5818c7a6f4bd795a158b2db677bfcd6923ff901af2075c8f62fbf21116a0d05b4ac06633289bd4290857a9929f1efdef63aafc7ce136e23ad010f33181999ce8704dd1f58130732eb397af91fc210a8a8e6a717e45175295d8dd66cc413a90c5574c4562a8ee45cd274c15dc4fa9639172d84dd37109c6de30978cfea1ed85d47d89bbfb68bf466c708bf145901681f3233ec2aef43b8276e7713a66eba9f6baddd8de87da0f66805ed7817fa6d1c4c8f45f15e63203d1ca5eb48b18e10f1c39331884d94a2fc842a04419ff76120c3ea2f5fbc82829797bdf211e6e23b37a7f8bee425f0721b83cfc67d987cb37e0a8f0d3dd350b8dc825fe3859b286a173c742c55e4bb45d82f2fd32f658e9f2e70d0b3557962d334a81d70a2d331bde68663abbf2b2eb2329ed824135c850f49d8f5d8cd6b2287f2351a0206956dacfda92586edd658c0107056505a3922ecd629eb882eeba3915b767a5e9d582f862bc7b775ecdc1a22129fcfcd5591294ae9176650ae88efe4ba5e4190411bf0221bda5a83e316f0514984ac97f26dd0d135a52c4edd71111c6d4ea2ab6e4b60e7399add220614aeb1077fd1268f99d39676ee65b508a93d6bd3e86d9a2a203d3d977ac616ed134b9b0bf58013123f81be54b99250236919368597ae01640448be96ba23d94488b18d1cf7c2663716f9de86c98e187da4cb9e8fb3acd14606a73a0ecc248a7ddcd5b6df1b174f73288910920e94abad64d4a1980dea70423318811862dc9d126ad127d598124eb767b436e03cd9d108f3509fda4449bfed2e5d2504526f56607654d7c534386ae812a714ccf74a96aa5ea2e37bf85f3504d15b526d4a7ed5a95ea60e06e6e3a37b01a01f47a9a2abe3d2ddc68e6a4716adebdbbd796c03907d349f42d0731c63f044deec9dea6182b2cc755c99d973b707081073890d9390ee44052a8feb5066d625f028212deeb0eab6492fd2b8f6d60935cbd109a5c4257e805df5479911160aac15edbfb0d93ea79ebee63d6cc755e7d9ab8370e9e44415f3e620cca245287af584ffa9a0bfa78f94ba52b6570d53d0fbecfdcaf2bbbb3910b598e28508b76ee6091609b1823f551c4caa4320e6847ad5aa8aee28539145a90624c9026cb57844e84d100f30b2f9a9bc56668bc550973c10a641a5b11105986e43b3470080dc94a7cc23c365b66c88ebe2b1daf15913f88c89d2a45bac62c1189cba60ce5cdb281aecbb8213dc593165b859ee85ffaec5bab2d2379813e3eab2a63b6bfcc6dc0358e7d4281172e60965c361649ce7152e8c855eb0b246e8e75e5717e04619a581a8057b05dac1d84794e32db442f1f2e629c6d9aae8753ad424b17cc32350a16de539ce3370d120962c0dd3447a34d461fb14482c2ebb709e3ffc39ad5f66b216761d152dd3045a0169b1cba29de6390df838e1e4bc00076c1779bb921bc8deee80c0c7cbd952036cb2ff36f2e79ccfc5f3a73e8d6ffa933e507a3d5f022de76694af2f0ced58ac5cbe7b43d10771ec6ecceb647cd6b96af10aaa1ee01924eeab7f9e192aff98d134451035c0b14fb2856b34d647f7e6e2a1bf14ac23c77ca8e8c3f27d0cb7169395a591c9643cbe6655ddf5490c19e42534d517dc3f5fbf5a4103c59164f5d64ee1f30c3680fad45cf795e841920411b5992187cfba3aaa24d7c448cc60e92d118ce478616622e91fa5cf09cc98f34ae8be0c423882fb4c7270159db995ba0d08fbfda03d738dfb0c2a6a356be8b773d4f1c27788091639f88e3fd54843ca7acb048c3a76998277ccaaeb56abe3a06438067bb0d49183496e4958e0cdb4f6b44aef9b7178155691e5d96742269f6d7c9b8e7efc2f1da11d1b5c183dfce10340324d25c0a7a40af75b70c1d298ecb88addf35954cbf12a657ad31f12b786bed4c1890ee57c8f98f60d7cef9773fc88bfa9ac0ddac6739738dad34caab506998c1397e887175ccb788820488c0c456461dd91fb4431a6efb0b63e9393349261f67e049be3d73d4ada0e834c01a220a8b6d096e27976096b9c82693da394215276bb974287e9a5419e8ff4df876eacfab8d5cbfa014252bb71e024776bc696d50fe3b5464873d8819bb2ff2df46d9a78c6b47b37b7ae84e7d5334a23c392c0c0e21f233147a31d46edc2b0f11ead168d6536761149465940d81fbb0ddb2167eb7663e718775cccf4509737ca6c63cc04d303aaecdaba523399000370aa726682af6d4f15f8d075b4107ff0e4bad23e133c8610a793e9abe2a20fc912b7791f252273eb40e6fa70c0f9e3010040557ff2ea1e86c29f3f60e4a1484edf2bab7967ab84899510c08c08d377c653d15440fb24c529986ff98e942f4f2c16b9639e6764bea9bdfbe14bc4c350eec73bf6178549c32b3e63e57e7771b757a9195437ccf6bbbf566ac69a6afe32f75bd8cb789b735807f7494bf91577ef31180aba0c43f2831f6503101021d55b5468e62305a7c7af4f905425a81abcb60321b4a33f9a9c879b644c720f4cc2937114fdfbbde01bfcd6270b5b45af9187fce93f41ee9b858910be3553e81ea3fbf5545d74f96a172355dcc6c22f7c69e0a453193ddd938614f2f510d76ad426f3cf4a44964e70b1e9e972c9db46ab2190a5f0e475eeb896faa8210d5b68714e8143a5ebc794016a7987407a65d77bcfaaeaa1d811f4775db3437d6a76524b6a10f584821074533f72369eed0370edaba36b7fc9f969c96687acd31795d8042f9b9ac01bd3273baa264354850596b2d5f14a6340ffec63872fd2e884399d90434793b8f500c347f912070b15ad7bda7be01d49f484127eff517ace5e0b816d1fd13833316befbcde8a81752a57e7f74f1502b64a1bb15a617a004dac9d4d0b16e1fa7ee03c8d19a201f4fc083a3687847f5d37958c59c30e9f4e04c27fd7be494189cadab3455801f2f7b8b65310b3a7c7b10de49b2de1b3e06f5896b488c2ebe3fa6701553810bfd3ec2eb3eb966ebe130697ae3f7c30ff998658fd970b28c8847011b98133cc455c35289fcd1f0ce65534a4ce73174a8a5a5d5d9f07df1804678328f6754b144b68f50e90831ef453aa1779389a4f1e320ff5be4d9df40d2e4aa1b6fe384c9b51bf6b2dd5fffe0ba93387aa21fdcc01c7562215618df23a5d13c5b409fe4b5ca0d33a448370a726f9f5c03559ee1ae463fd863a05cffe027287a5e016bed3895dd742fa6c1ff402471cd4b51f11b86af7e9a97837ca181dc8b7e18651f7d1682388c28dcb63e7dca6cfe308bce9d9df0fa23f15e11195aa497ee77054b75f0dc969339d10b3102eb92957ab8a74cd3e03d925cea8fc0e0edbe58db2b03f010ba3f6b59d24814e569d5e2a1a1dbd72457e745fe064f4f58e8c0c718deb10f61ea1c36b953690fb6d310e8d65a0726b0f37418389b5a10c5f19e70c2e4a4b7bd613a319e575333c9f0b50e753a288198cde496a58d2b116251ad52e57b30d433573fdf6f1e21c82e12007ad78703a1d09290a179f100158e374f0382053681370eb16720c7dab8aa1bf55d0b3d3ea1229f23be88d4e27efd48e8c7c7aed79a42f0ce6a4621d6b5fd8246d3f29fd57f64b64a142914923c281124b17dc018aa84d328a77b26013fc0f2bfe2c32c69898400f7fefe2520a1834871c79bbee54370f4401c732502d08def8fbe2b5afa59fa84781b7af0f958070e46a4fb22c82292f92843d1d328725502ff6bf41999ce7850177964ccd19170b9f6aa050c1b25a0c934b4a11f4b56888f6bfddfcc8b4b81b8fc9a06cc2ed28a0da800567015c11651b9449edd5c9309ec3f11a8aa76a460fb5dc8b58d0042cf6c8c6a1b1f2373145c452809732a1ed4ec62efcbdc72c3a3577baaa2d91877f64363bd215c0911d84b3c12be35cf9f84a83fa98eb01ebee35ec2d38761a50fa33792573fbf4f54b75fb50538ce9a35854dd4a3484ea0de66e099c7e35ebc9841eff629fc7ec485a9b13a53fa628b869e13351ac43b0d2d47c63f0c4b262711f805e42b34fe42c8e1f60c9f6eda247662afdc1f3f1564350d6ac9afbb2395a2b6e9550a8b1fb088afde991c35a51aec4f31f4698f97ab43e719b13c443acd3aca267fad4a4b3022e40723579cbdab7de61696966427cc5cf8b2968cee7fa21ccdbce4877aa9f21428b590ccec7c78bcd3de795471c38b8375ce84496de55f87a160893952e772f81fb77159e82ffe1ca36ca0f921412b0f54381447685788ad6499f01a96f53dfd7731657e282846d9c8f3e23d9935ed3e3a42885bba74484ef65d15b37125f67919a5fd9a59a498199c49842d42e44013525059e9e90c7c864f73de0bd005fbd9d1449b1a1a294fc3af14a8ed7dfa357d7374e1cd5802b620382b5ea0b9e6442b60995102d4d3ab82c6296b98d8f5154667faa3aea8c3c41f5934895fed2eec6c3343aa074fcda148e5ab0c511b113d9ddef439e8bc8dcfbc4585f4f11e7980e5fee96887780198361480796e0b2d99995be515f2b550213851558fce6b55019e739bececf45018cd8f74f179d2c02fdb8e7c225d4545d77b3cde8622448cc2d825c44318f07a391da494812156fef69f46ce4075bd83fd30b682a85d104c4458931a4783e6d742b8f41716cc3555296b83240b79dbe3928b11841df8b36ca9b50d60e4ea833fc9b6b727ae34a1ab17e9b0fa44c40f65afa5785ddf2a007a39c3225679297c17a710ca4cc91dfd7d6bcbc64022de4503b40557ea5faf9578ef917f886d6208f7b95c98b48aba69e98a4556eddc7ef39c4426ee2110b60f07d71384c7e0d9fa82a205c717ca45914692dfe815c4f63f4d8b93d99f198146e1aa7ef98ccddc738dfd06cebdf93b32424dbca9bd7175bf9f7c66321766e8ed7ef216480f13238fd5a69e8bca111555473ae103a29d7c5c224e51907324eeab33174fcca871c513beb6eb7a66ff9da61f57b1b590864097415dc0c22c3b792dfcffa26b363d85f2d62622bcaf20bc5ad027d71bc5b52406bc4b4f6bf9443805acb2ed607a0557d43d29cff22eca6a06862c813f351c688c8e792de25fbeada7cbf8516d16273936cea177f4af9aa9c15d053dab1c5057f0518f8f5bdac1c4cc3f3961177c593dd8e14fb203ec07090d76990564c97a5f23e13f691b01e7160815a6fe4bde48a4e1a34c6176ff0d9b2353a2e29c6e01e7b18fb37d6daa09d33d876530eabcb0184fa43107ad993da87f8f60bf6b56171205bff2049830f6d51c0550c9572d33a5e2d706dece298ff282851237a959a9642a266171057d5073cc624cf120e6ad5ea477bb2fb1c290bd860f5d96733d146c60f7221d56186c4978a62e0f771408317d4b988aad9323bea4540f8489d9f0ae56dc9af1f194d7aa2ca2c639a57e4f34ca39f37a777c05c4fccce0a5d8448ee05d79af32b2d293d5ec02a9aa3608b9528dd70091562b65727e675a6856f994a35d5ce2734b2c763a6e80bede3ae19f029d68397004102bd3f7a9a63a20418466c33aba7772120e472c954034abc8538753e010a0fe15bec39a691fa04bcd10041fdf80941322764022dd6ad9ff0894cca6de3424c47245cb39ac5ecc2f86d22557c415827527f5511c99a9eefeee58b2b020a6e92001cdaf6a9f56f9544aa0fff9d15f19e2ceee67aa309fb028ebbb889a6b46ac1897caec6204b147eb256eaeccadd6bc79f33bf55c6bb4b12a5ba2bb1fce10785189045f6ea79d1a7a76607a582e3c63e764b4062772e1601d1f96e41a3c39769e15558a8358521cde02b6de0aea8136c0a5b151b0e5cd6a42dfdf46329ef653e20b48b7d31a04f8702290b31665378d9243ee3bcade6a7e55c8d654690ba2b55ace8ea20a1ae0ebb315065e7260fd299806e1d772f64ae4750e9f9c7462089f4c6a6902a5d96e6bfb9314177c7b38a3dd6c46cbd1365d89c83677817ea0ae979e19b555a8b64d93e0e7e91aeb85838f986ce5210bccf12144cc1674e2f79a8a6d75b7acd5ec78656543d479661a447582aefa97cc49dc06bfe431bbd101da355a942f132535d0c142d64aa9c9fdf3c8a86b88740b75be7e82da534653c66517c3fef074537e0d81c8df099b7931aa83b7c5fa64418e79be901de559894a16f9285c492bda365594ba47c4e46f34a93b47b9ae82ac97fa9e955467e3d707d521181523dd9d24c9c7f94ff800051aea7d6febb92d141184ee31f889869a057d36d8d585311187f80c6cf511cc2d8a3f0c2d4a024de93f9ccdaa0303d3adddc8885de618c834bc20ddcf768cf8ea21acde5f58454ec7741fea88310db4e5a96dec7211567b7b58cc88b942845c319ae083addcb60a18cd125b7470d01f5fc975106223ed02ca97c252c62922b7ac7d4f21beafc149edfbd39faee3b07f51436add9d73d418a2c8fc32a1dacb7976947ad42e6cc9acf02df70907ba5a69d1b72366abd0ef566f40764231a48d7beb0c2fe905cb0f2c5e2df879921b4a553b011fc09fdd6d2b1f4a1e6b0aaeecfe352d0c17cd5a74ff92d8f91fe89a572ed292d65380363e7f1a44b7dd1fa3b3954e1402519cee77237f5a45606ab307b703c9200730b6dc953668558d24161e64ebe3949fc08716c12f1e7059cc34a1bc03253df2f375c16504879c7a4dbf1b4c7c99771e646f3f8ac9df37c68d5ef56a237fe83492c61313540b094a2e976543d2331b33befb2bf1ff06458844f3e1f1a4bded12e1a0430bd3b6222cb0adc4fb9ea25da2583bc369a704d0eb32d1d53e4e355151217001108825f5979160abae9c6e1a5d8ce18e54bdb1fcda68096d988f4db7573a046d0be005f22e812af48c26369da5addd2e318f8828c065075e924f33ad4c4d0c7b70542bbdac710106c430b6888ec03d136361468c1756608c3020b9f8857cbf7e5bdf902a796b8833e1bdeaad43ce96ee57f6b821e157240a731d9c6883a6288c5a256a88c81ec4e865fd5894c10a454c31f13f2853d2111e311f8ee51686e1f6d4d9eb062ebfb16cf2c3aef268a12a5afde2aa4c0f060ec60553e10340f15edaa4a758206a5a7e7739c66b7f328d1b7c6fb444b4f21fad96188f43ed48836e33748dc2774c9cc0fe184d57135df4a1bfd5587c2b618601b2f5b2bcb0b1c17a49f658c5a8804c004c6c4cfd8979183ae37035e0cd99e890ea623ab4ec762f78e44e7cacb1b440127a012b705aee865a01a9edcad82e28272cba97d9f79ca71eeea8614be68bbe1704474250efb3d291847d36544811d896357141c6c780635025f90c2473dc878742949131625dbdff893229f00c9bcf2a46bed1a3024f952678fd584e9ecd4c3af4d5c43a9ffe44321bf7ced459a12d6e2993318b1e66aa5968f306dc5f0cabc75cbd9494c9c8f9f01e4622172f0ca575de19639a754baacab999f72a3e2f2a4bd6473fda39adfbf7257f9a12412c35e86f3de1ec7e74436492e0b7811d0e10b9f0b68a9ebd65d0b9628160b4d96cb6a051cda4c3299a08c3ddbe540bd174af7516cbcaa02a5828f9a925789dfb40992d61c3a5bd9baa1141f94326ca0d3a579c196f22670f5f8a9cfbaeb88dac8c851402ca6b9a974be2a82163b12779f322edd4417df4f2983e1ef359c7c8a820bd4f814e781dc88efbac6c6fa2fe502c7d040dff383627ba30f46e2dbe94993a669e9ac04d00e92924a4e0dd534cf2a04bfe02e4512c8721326482951e68ce3efed697ce06217e8457d607122197484b212f49c3ec05ca270f35030624b5a2362e314ac691ece3f36a1794c9eb2f120cca75d3582462dc661ff9c1712cd0b0ec030a180c952d3a1305c86d1bbdd018ecfb1a4aed3a97b9c87512594aa5152bfa8ede2933056f822c98ff17c8b20299d049925292bdec723b9be4061b8ee273628c7f782557d2d22f29d15fd6008c72b60b3a8fa2d87d93b11db0b886581cadfd0564937bb5ec98b193b2022534d2d4b70b0b0bfc7562efb184902ea8603ebcce90897dedd87895cfae7f66cdd16f417de037f9051780947306785c8fb0cdedf81656cdcbec1a2c42fe306cb2ad973838ab4086377960c50dd2add74b73440452a07405f70ae20ebcfda2ceae61cba111bb09862e59577bc9fd36b0cf4d0b9ced26617e6a993ccd9e1412e0593e0e8d0bbe0aa4312c60d5b572feb3a91be459299e4ddf81dd90c565206954a4ec2cdbdcc0ddcfd8364a84503327c51a3911941be2c72b3a08b3cf4b20f7bb080278866ffc5241c82455ab076091a3e2d349ce2bef0f724e6579817a3b0994d1167f0ccdec1145ee525566be7ee02256afa633d21416fad157d300e8ad2093ba526d22abbdac399d06fc315f7c2f470f2fdda83631cbf78688853123ef59470b3cea5192c315e8c66614b7e22466c21280150427ab7b29a4721fe8332c8121ff1ac19ebd87064943ea3f06dbeb7c1934eec4c5a3a97b35dca6bbca42e840761094e62141b1e2da52ee6f32170ad517a91b6fe65915f92a653cb0c8395962e7d544e4bdbf09ddbdbacd39a7ab567b3671ef5687944395c6c59c80f68636285b3dd82ce8b330aa70535c5a2c7a53c509726e19e479db039129734b5bae578321d0def921c0310f6a51d6bb532968b5a7fd6ac1edf7d56d1f5084cf3646edc577d541c8cc8ca13c19b4e00bb7d9f825f41ff20dacd1e89d78e54a0e7dbf348cbb43bc50e931bfe161a02ff681c621e3beb5b6b61fef448b126c194184dd795d42fb91a144512280ca40bab646ff97199643c91f24afd4cc21690d06dbc91fb1c6c6da75b2d690926ea3e9426879bded594d7888425180ff913c3a3f8a7d24dad9cd4983a0eee3a160442f3d5055c0aad7963d06b6e9e499cdfa26d2fe81206004c7999d20dc984ddcccdf9c057cdf42c3fe56b8d9e9dbb2a30a781542b5adc9b60277219fa20b977f79ff6a0a42ed9813b37c27f8731979f33473e964da7388ab970a20b59614b383ab0b4c51d3485019c39991ff99bb7fe6b121c5aed6068d313551a37dc1674b486d7723b6b3c919bc1a3218e2f0873af0e2b1a6fbbedc37fbb495665ca440aa20b810043b92b2abad61c96d98675e95b337bf32f9bf53279e868578ca9b6e12036e91feff62ea423af274942548749bf23a74ba86b198ab52f28ef6062fbc2e224c8a5070e4c232bf4e4621d0057e698f9f57439b6943d5f52c2038b655ee61dea608c9201d0655a8cabd91a03cf6deae117cb59b0c67dc4ad62ff538fd423ee4ed55f1920fb623239ca244f3e8f8ec9efdd24763a18d92ffc63ad0ed0f3a2c6e3614f6616ad313f860209a76e8d9846b0cf288ba325a8c4a3d7853882c91929b292b89416aaa59b0215aa875b377cf0eb3287b5e7d55c63ca1f28dac17d533bb301d150170bb3a500a7b25c265d125fac9f5dc32bd2bad209b7419289e5210f0ffd324f9d87d4c27555913aeb8b0addf1fa71c18d966ec116099ddd74b052265c26544ce57762f336a60b2d6cf076a9e131ef7031d446a05a3043e91f4952ef3d9cacc2e2be36d0dfc23f6315cbbf106026b4900be46c82993452ae80ed7ed682d9dbfe9ab859c87bec58de361ecd8d1a5b5788a1da332376fead471a6f9d11c71242fb5a160b22f44f899af17d29b79117f98a84903a28fe0059de79b99c72ddf71c6789789aa147579d3ec08aece233f106d6789595b6eb82d8b29820e268f3fe8c32e775e31dcb54edd22b56963ec26dd100af5d10c6e114bc332f7ce3e8a1eb1dfb45b5fe8c59e790727061f8173a2247290c71c069dbe22757107b402f215fefbad61f69e91f4fb83ac800439b97789cf39f78a5fb46407fb8ca67d44eb0a4310cd972886f338b77509c07b7079b64587ba8ef2816b7656d7421faf5d08afa73c214a056052448ef016bdc3eb9bac33cd95ef7c6c45e7476ec4880fa977e3655478ba178d3a91a807bb83038609958ff3b1d0171a8e5de47159caa7e38d4dade952f71523a5365bb15f11c97d45536498882d9101f8ff7749659809ae9aa7c13784d048b43c281fe0d9968567895b55f42b2e8e0fa734a694123d2c4333a000fa3760efe0a3f25b42b0fc8e58d95af7ae2a8b58ab67fe6abaf53739f2dae7a01e3e07f2dc60cf311f5f86b464ad49513698ac6637f352592138e52891538a9f4a4db63b0a5f350a42c95cf5e567776278d253a510d337de6b8dc4df228f2c8af158e76d2d6002b39dba44e0f02601ae2f802da9b27695d5894e03fc7ab8fcb774914cd9cbf8e4dd4c8373eba7fe38435886f091ae74c6dd09070ddbb47d51603b0483b481b6215d5c261dc077bcf5fc73f97a5cf998d271af935feed316fc494b40eb70a8e5f1eab2aa1013c27916856c76c462f38774e3fb081c140b9d3e6dde1b86cc8ddc1d53ea83cba7ab50c93d0fc11a54c528c7bdbb6067667adabc079016ebec21a3b564f0c0638f93f2f21f427489ef54652396a7f5d9e4451674362c895c9dafd48be10b8032c8fabc5f47b88369772ed46a54658fbf35d1ddd3d5bfc66debfc515c58397f9388480b35584ecdca44e01878651192ce56b789089d5c001cb4ba6a9055589a3e6824095a25ba04263a88f2b4c3af903cc97f61181c6a5190c49bcfea9ed6ae615eb1d9cc563708884c5aca7ae569f7c27dc1b50ffd5d8f6b4247ec2716bae2b284c47cd775dfbbb2270b06cb5d4c82c9515d9355b1c9d4b58adddd02ff446011ba6bf6782c1f5cea5cf0b4a219c98973a8080bb0f5f4badf454d56ecebb83814196fcd391b19033cd3e903fa1687ecb86313d2c7581e40e41c9fc980537134bb828dab6985973f8716f0dfc055a5f560718350299ccf72c4395da7ee92beac52fb70ebee35359c4ae0f5a1f9e6cc4b547484fbda140f816c81e7d899afb4a0e6a3e1c6c707a00f37f2d14772522e0d6873e32e4014941d7197da8b4a65583b5922430300e1194deb7f8b5709f73ea235ffe5a82b62c64b6d72204485c04358df5d37af96e7b53515f6056f9cba721dd8efa27bb2af7b35ca1fac71fa4ecc1f244bb060c40ac757af1cda2ca254eba9234568931a3d41ec76f94298c21b175d34cb8bdcf4b40a9e8b178a325e13795e6602a60a1b38a4bbd6df45f54caa604ede856bfce9dff84f62baffea932ae4a80a09b3023aa824276a62ea248b1f508ef56bf42d17d5489a63b59917a0aaee4815cc40f32bdf956b20a482cb29ce769278cfcb31f83e62b3248a9df6c7fd934966ad369ba3dc416c6d8f11b53316823049f3d6befb79369a7acd5bca6ad2779c7bba91f0c004d7e965506ce8b3047c2b740bce2434f5fc4346bce7bd99d01a86cdd3e2bff153320925de6e674034e1b2eab373407928f971dde623d519347e88268400c5079f0c685e0fa673439343e3eb734c58b2e8e59b4dd188aa1763e896cbb1375f28430dcf082bc278fd0b254a495edf7e67adf93f0a9fd722240d5ef9fd211c8611ac0689ace9370aa489d013a69a141cbbe6a621e48e0274df3d1cb0b279af9179d7bd70f62667d7f8d7a72a683256450479b0f9983fc6b0925374f9ecbd4b4ed641e05208544a961f9851c2b150683c6ff6dace40e9eefdfa4c0f9f08ab6a4b6657c07f7236919bb29c5a02950acf62df49ecc30cd9a674e4b9a867ef56d3f7b9738d4cac1ecc642af3d96ce8373945fc15f9deea8c46a8c27ec86819011fbbca2a7b5f12a9b34113a9a245d52ee1295d4cf6dd0ff4b8154306db7863f4486d5b3a298de7ce756672bd7db95c97de59dfb47441673a36cef019c15839e6e26cbd9ea5aa6a6c146d38131bf76229d8ef716d887d43782afbc04c638674727451603975b9f60355032c8231e8fdc563e4ddde924cd9d21bac5e730ea6272efa902bd30059162e19b7f04c8ce70346d82145c79881c7e1e7d979f485ac93c1b4197abb24147594b42ad3e63071ce22732e8fe4cfdbc159b8a2f19520c6f6f6d9d7a4e7458b19b09639bbb1cf8d208c5537815d2d286199a537484a526c79c3567cc201565ff5d734e27595805b9bce1d46cfab90a55f3353e71c90d283a384d2e2b4add45c781816080001fb1ec53cb39f3b4115f2be09236ab62d78f139e4303cc5d9184c033a564c1a045f354020a6520a650e5a33df62ad08683829f008df0e28d8ca8d5f1cedad8299074a8e3dbd5abb9b79b43fccbde9bf8159b6087e454b247d55e32d64df7d80d92d6a353802980d1fcd74869085d33f084a7bb828a94f952e3f6058d6ae05d5104da52a8f56b52b3a30e9d95f7233deab2d73faa72acd55aa05f4427128fffe73ad13d09bf29eebbab1b39bc22ce129fb6a583f9874e455c649fa72b50e68cf5859b4ebd03baf51e402a18cf6761648114fa6047ee085f73aec8a9ce12ee1a54ada8a9a242c14d576404438729b97e050772408aebe1b922bb24bdf88d8e710e9defb20653565d0d2296c275faaf3fafc2efe359462ce8c71db51a6b9b8764cab2286627168967be54cf569e3064cfe0c5e3fb5dd4a4720268453bd068b7c8d03921f6fd7dfaa776d06b0a35f706b063363e00536882eda013f8aac5623c36dc2f02e2e2509abb47b667f977df4f6b8aef0b0c2198238fa5c7a139fbb8fd80b816c5e799505cade752ffe3597f25884b5b8627bbe83f9bcb0a28f4c04313c935ec42aee1505d59554cf5a214e1d9b36a7082baca5e99bdedd26a9240cdea0d4d103edfa44e95ced4d50bca48cc16e4897af0ecac4459245149fec3b1f8f036b9113f3f3c7fe41832a728a3eedcdfc7007fa9b99713c4dd2f601a35e5bc582eab30b670f76ea2e2d87ea68538e68ca70fde6811a93bb5a5dacda4d2da40560aef1633723bc0140af52d984f88a3c8190ba4125fa3134ebf4dc9ce7331135048bc497f73e26b650298c9a8e771e87536b5dbcaa493a0e06d8f9b83c33c53593a3180649c77e79aae6fd9035db973942a48345664acc34d05d57b0a9ffb4f622b29e127383852b971409ca3bc5efa79964e4c05702beca5ab94909d306752ce3830b5e4ba8ce18394a92cd057247e431d074e20d936bdf55cfe66ed81fea843b2c4317be4a3541f5a63578e77fffb118dc3e956f72a4a6a88b5d5676310fd9283411fe4ffc98a4b0eaca113c3d5b691074d716a516d23513b2e3891aeeb54c490b31671f4a14fe47c9013007d7dc74381ebbcf9c0a71a9aac4baf40971c0541dc3b8a6518760c73d41ec7024ef9fe48af10f5fe86d0c273ec03507423922871c48a99782a19661bcee344a6c9084817987145821f541073f84e952991119c336a14ef9a0d69e0d23e9dd2b8479751492a445500c78bf90638db62ae05016af1ecdf35cbf839e00e28db5eb6450dd0a376e86a9e8e37b2a5ff0f59b79318262ccfb7afca7244439a05ea27bfe2cb486fe1c07bd528d3c74e667a682665c2977c9d33f1cd03fc7d27dd228acc1e7ff22704ff64991d0b428675d9335efae55273daaa68de5932e36b4a4de3128be7426de9eb9b66d7b97e753934a05a8c7898cebacd3a816e474a37b221eb6338a3667335a7be339890c2f718ef34a0481ec8058c767ee959e4cf59e01feb7ae91de4dda0aa89b5c976e89e2406df7b6ed277bdd639fad0fb4a41ccba5c72f6f72305c157bc72348a87b72d613be859d8d20a04cc4a8d21fe58324419e6cf65b83f2504023ec4a31e504a9a18feadda64f6707ed24dca3b657d6c6acc6024535246c8b858e03b7e708e6facd19367d30cb6cdfa08f788acceae7f7202d493d5e40a949294ed36ad3a0647a9809dab6d10f6d72658c04235a09306438b01b6ffb943530665d76a92b8754feaed37ae4857c5bf0ccfc71042adae8b36506ce334643055612fdc865f91937bc0192bfa3a0e39ff85bca348f351dc4052f1cb49e687e624009bb9ed7d9e3a5385f8c841d2a05b4135255ac6cbe8bff55e018d5af00e8c7e0bdb8789117e3cf568f216a7df565c5542e707aeaea5cc5ae4dc9bef7cec2248c88eaf68c2e7c07b53ed2bfcbf0b6db2a009f3efa38ce8862f83adea760dea0b0ee6bf93d48ae104c6523e663990110e9c52fbd74142129b2ad575ee4b9616d34f465e37459824afe8cb271db7c85c7ec8a5a06e0d5d1fcffec69c2edc7566ea5c45b5c8920bc2f4d2ca8037790d1986fb0f294948e30c4675c71af34a2851fb31b8801b1f75c84cb5a6b403d7d8271e260cb3c0d131e66f1112c546a99c18718dd9111533ed038f1b6c4c5b5da2d5fa9882bd43f3e8839a8bda9c834f7c56c562d1a9bf56fb22ed9f6eec2364c7b63850181944988c437a8f41c176a176a55a323cb0eb0eb37217abcf74dffa20cf24f1d7a380ab611fd642e9ca45e8ce1f5cf4ce2511c23931f16cd45f6c4fd6c2c1e239e5d0dc9e1b76605480c1ee385dc567627701f064581a081701e09595f740437e5a743cbbd9c7027facefe8122d61ab2617289dbfec27332996d40c02fe50ecbbbeeb41928c14275e16b58fb4a18167b67759e469644cea871bd0065f9e23e43491dd9bdb3e98c304dd1c293086889eaa4dc0a3404314d84c1125a17d5a350eee1431303e4b556f97d2ffe5429c4579307ab7404491e6d51125250dd8970284f1ba8297f7993a080b291c68b36b646214a7a9552f8ba316b2f747f156a8b7696a9eeb7fcb7ad3fabbd97eafd0f789518ac0742c33024c092682355b910d29473409974e81324c3898571ae322b51fc0b9dc6d41a779184bdcff9b19a5b4f910ad05d523675677aa64a7f198bf0667b885a22661ba14b5f0deddae3e129873c7536ea1d4e51d7b8caac2594ba4e6a96af0a77360927655fe30aeb614f405ae9ffc71eddf55d0ab616f8b9e8616820ee6a12ec487a5b163f34b7c3c0abc03fc05b3675b54a5e0a6de2238672152a45be293e9c955031b2e56238ebc46ad19c2e17032a13a1abe7d5dd1928a23e5a3eef2203a9544e3293fdc74159b889915fc1983f6abda151c9a86abae331e903184976e747e758cd010eafc43721c4657237dbab8760077da107721556384778b04def3f0d919f93cd89d89a021d39102408c0eedf6d61e4b2a2e0f2c9708a7abfe7399d608bac6a107f4692f56cde5b1023caa76450ff6fe7de0e4ccb27b14da5257306c4729ebdc944deaf29dfac58f1d8651823db73e2c6c45b93b2f42536cb4879a277ee52ab00f43a81a3b272721b4c79383ba67fb03c620576ce2e3e3d1aa1ac2f29b49e344080620ef3594862eabe3a16c36e6a40be179bda73990606adb2115618163244f098eeacaa4e3f7c01b1af5e43be7498fe32c467a03d708580df32e6fa1195797be16cb6144a3d4245b2bf6184733af724b7858093e83f4cbb6bd8a854ab12cd1cf8a9a0754a88fd7fcbc14336929323b020d1c4bc62092]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学]]></title>
    <url>%2F2020%2F06%2F11%2F%E5%AF%86%E7%A0%81%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[科普 Day1现代信息安全的基本要求： 信息的保密性 Confidentiality：防止信息泄漏给未经授权的人（加密解密技术）机密性 信息的完整性 Integrity：防止信息被未经授权的篡改（消息认证码，数字签名） 认证性 Authentication：保证信息来自正确的发送者（消息认证码，数字签名）认为 其他 不可否认性 Non-repudiation：保证发送者不能否认他们已发送的消息（数字签名） 第一章 引言涉及的知识点包括信息安全的要求（主要四个方面），密码学基本概念，安全的定义，密码算法的设计要求，古典密码（替换，代替） o密码学基本概念**,**如密码编码学、密码分析学、明文、密文、加密、解密 o对称密码体制和非对称密码体制 o古典密码体制，如置换密码、单表代换密码、多表代换密码（要会计算） 现代信息安全的基本要求： 信息的保密性 Confidentiality：防止信息泄漏给未经授权的人（加密解密技术） 信息的完整性 Integrity：防止信息被未经授权的篡改（消息认证码，数字签名） 认证性 Authentication：保证信息来自正确的发送者（消息认证码，数字签名） 不可否认性 Non-repudiation：保证发送者不能否认他们已发送的消息（数字签名） http://yuqiangcoder.com/2019/10/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0.html 密码学就是要通过算法和协议实现相应的功能 凯撒密码：移动2位，H K 恺撒密码 安全p无条件安全的(不可破译的)： p无论截获多少密文，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即对算法的破译不比猜测有优势 p计算上安全的： p使用有效资源对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的 密码算法要求密码算法只要满足以下两条准则之一就行： （1） 破译密文的代价超过被加密信息的价值。 （2 ) 破译密文所花的时间超过信息的有用期。 满足以上两个准则的密码算法在实际中是可用的。 单表代替密码单表代替密码可分为 • 加法密码 • 乘法密码 • 仿射密码 古典密码置换密码 单表代替密码算法 多表代替密码算法 第二章 流密码一次一密，流密码，密钥流三个概念。 o流密码基本概念、特点 o线性反馈移位寄存器 oRC4 一次一密（理想） •优点： •密钥随机产生，仅使用一次 •无条件安全 •加密和解密为加法运算，效率较高 •缺点： •密钥长度至少与明文长度一样长，密钥共享困难，不太实用 流密码密码体制 序列密码 •流密码的基本思想 •利用密钥k产生一个密钥流 •密钥流 •由密钥流发生器 f 产生： Ø内部记忆元件的状态σi独立于明文字符的叫做同步流密码，否则叫做自同步流密码。 密码分析学的目标在于破译（ BC ） A. 明文 B. 密文 C. 密钥 D. 算法结构 保密通信系统的安全威胁 保密通信的安全威胁： 被动攻击：窃听，嗅探流量分析等，主要是破坏消息的机密性； 主动攻击：中断，篡改，假冒等。 中断破坏了信息的可用性 篡改破坏了信息的完整性 假冒破坏了真实性（认证） 所以保密通信系统的安全需求有： 机密性——采用加密机制 完整性——采用完整性验证机制，如Hash函数，消息认证码 真实性——采用认证机制，如数字签名，认证协议 中断——用密码学的技术没有太好的办法（这是我个人的理解） 古典密码学 置换密码：又称换位密码，加密过程中明文的字母保持相同，但是顺序被打乱。只要把位置恢复，就能得到明文。 代换密码：明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复明文。 多名或同音代替密码 多字母代替密码 多表代替密码 总结古典密码学的特点：加密对象；方法；保密内容；破解； 计算强度小 出现在 DES 之前 数据安全基于算法的保密。这和现代密码有很大的差距，只要知道加密方法，就能轻易的获取明文。现代的密码基于秘钥的加密，算法都是公开的，而且公开的密码算法安全性更高，能被更多人评论和使用，加强漏洞的修补。 以字母表为主要加密对象。古典密码大多数是对有意义的文字进行加密，而现代密码是对比特序列进行加密。这也是现代密码和古典密码的区别，而且古典密码的分析方法也是用字母频率分析表来破解的。 替换和置换技术 密码分析方法基于字母与字母组合的频率特性以及明文的可读性 现代密码学 1976：由 Diffie 和 Hellman 在《 密码学的新方向》（《New Directions in Cryptography》）提出了公钥密码学体制的思想 1977年：美国国家标准局颁布数据加密标准 DES（Data Encryption Standard） 1978年：第一个公钥算法 RSA 算法（由 Ron Rivest、Adi Shamir 和 Leonard Adleman 的姓氏首字母组成） 现代密码学主要有三个方向：私钥密码（对称密码）、公钥密码（非对称密码）、安全协议。 私钥密码也称对称密码，是对文字的加密转换成对比特序列的加密（相对于古典密码），用同一个密钥进行加密和解密操作，这个密钥发送方和接收方都是要保密的，所以称为私钥密码。它的两个基本操作就是代换和置换就是来源于古典密码学的。 对称密码有两个设计原则，一个是扩散（Diffusion）：明文的统计结构被扩散消失到密文的长程统计特性，使得明文和密文之间的统计关系尽量复杂。 另一个是混乱（confusion）：使得密文的统计特性与密钥的取值之间的关系尽量复杂。 对称密码的代表有 DES 算法和 AES 算法， 公钥密码 DH 密钥交换协议 RSA 算法是第一个公钥密码算法，也是第一个数字签名算法。 p q pi(n) =(p-1)(q-1);与n互质的书&lt;=n 选e 与pi(n)最大公约数1，互质， 找d，e*d/pi(n)=1 (n,e)共（n,d)私钥 a^emod n =b b^d mod n=c 根据以上密钥对的生成过程： 如果想知道 d 需要知道欧拉函数 φ(n) 如果想知道欧拉函数 φ(n) 需要知道 P 和 Q 要知道 P 和 Q 需要对 n 进行因数分解。 对于本例中的 4757 你可以轻松进行因数分解，但对于大整数的因数分解，是一件很困难的事情，目前除了暴力破解，还没有更好的办法，如果以目前的计算速度，破解需要50年以上，则这个算法就是安全的 椭圆曲线加密算法，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法 重合 四、同余运算同余就是有相同的余数，两个整数 a、 b，若它们除以正整数 m所得的余数相等，则称 a， b对于模m同余。 乘法逆元； 六、乘法逆元在模7乘法中： 1的逆元为1 (1*1)%7=1 2的逆元为4 (2*4)%7=1 3的逆元为5 (3*5)%7=1 4的逆元为2 (4*2)%7=1 5的逆元为3 (5*3)%7=1 6的逆元为6 (6*6)%7=1 https://zhuanlan.zhihu.com/p/101907402 第三章现代密码o分组密码基本概念、特点 oFeistel 网络 oDES，密钥长度、分组长度、S盒、多重DES o分组密码的四种运行模式 oAES，密钥长度、分组长度 太难记住了，原理也太难了 Day 2 现代密码一次性密码Frank Miller 在1882 年提出了一次性密码（One-time pad）的概念——加密：将消息和私钥进行异或运算得到密文；解密：将密钥和密文进行异或运算得到原消息，这个过程类似于前面提到的 a ⊕ b ⊕ a = b 。一次性密码的定义如下所示： 无条件安全 密钥随机产生的，只能用一次 异或 1+1 =0 ，0+1 = 1 共享密钥难 流密码体制密钥k,产生密钥流（发 同步流密码（状态无光） 一.加密方法的分类：按照不同的标准有不同的分类标准：1.按照密钥的特征不同，可以分为对称密码与非对称密码。2.按照加密方式的不同，可以分为流密码和分组密码。3.非对称密码均属于分组密码。 1.流密码。又名序列密码。明文称为明文流，以序列的方式表示。加密时候，先由种子密钥生成一个密钥流。然后利用加密算法把明文流和密钥流进行加密，产生密文流。流密码每次只针对明文流中的单个比特位进行加密变换，加密过程所需要的密钥流由种子密钥通过密钥流生成器产生。流密码的主要原理是通过随机数发生器产生性能优良的伪随机序列，使用该序列加密明文流（按比特位加密），得到密文流。由于每一个明文都对应一个随机的加密密钥，所以流密码在绝对理想的条件下应该是算一种无条件安全的一次一密密码。机密流程：种子密码-&gt;随机数发生器-&gt;密钥流明文流-&gt;(通过密钥流)-&gt;加密变换-&gt;密文流设明文流为：m=m1m2·····mi·····，密钥流由密钥流发生器f产生：zi=f（k，ai），ai指加密器存储器在i时刻的状态，f是由种子密钥k和ai产生的函数，设最终的密钥流为k=k1k2···ki·····，加密结果为c=c1c2····ci·····=Ek1（m1）.。。。Eki（mi），解密结果为m=Dk1（c1）Dk2（c2）···Dki（ci）=m1m2···mi，无论加密解密，其关键都是密钥流。 2.流密码的分类分为同步流密码和自同步流密码3.流密码的特性：极大的周期，良好的统计特性，抗线性分析。4.流密码的安全性取决于密钥流的安全性，要求密钥流序列有较好的随机性。5.不明密钥的人如何对流密码进行分析。这种密钥流一般都是周期的，做到完全随机是困难的，这样伪随机序列，理论上是可以分析出来的。举个例子。敌方截获了密文串：101101011110010明文串：011001111111001密钥流：110100100001011可以根据前10个比特建立如下方程 密钥流生成器： 高要求关键 要求： 游程：周期 0.1 发聩函数 产生密钥流的要求，方法、设计 反馈移位寄存器 ​ ：寄存器 ​ ： 返回函数 初始状态 线性反馈移位寄存器 快 周期“ 输出形状：发聩函数 算法 RC4 流密码是一次一密吗？不是 RC4没有实现的m-序列不可约《2^n-1 充要 本原多项式 反馈函数形式 伪随机性 求你12 Day 3 3_13 分组密码应用设计结构原理安全性原则混淆原则 扩散原则 算法要求分组长度足够大 密钥量足够大 DES算法56-64 IBM第一个商业 后面出现了AES 算法框图 IP 初始置换 论函数 16论 分左右32bit 公式：函数（R,轮密钥） S盒 输入六位，8个盒子 输出32bit step1; 32bit-48bit() 选择扩展运算 E 8*4-》两端 置换 S盒 4*16 选择压缩运算 ​ 输入输出 ​ 输入：6bit 二进制-》十进制 确定位置 P盒置换 32 -32 密钥编排 置换-》两组-》循环左移》16轮密钥 性质：互补性和弱密钥性 2DES 56+1 = 57 中间人相遇工具 3DES 分组密码的工作模式 为什么？分组长度是固定，而数据长度和格式是不同的， 电码本模式 密码分组链接模式 ​ CBC加密 完整性（认证码生成）加密，对比 明文校验码-》CBC(M.r)&gt;对比 解决：明文统计规律隐藏 工作模式 2 数据格式： ​ 字节、比特、等等故事 分组密码概述共享密钥 IV 有限域的基本概念单位元：加法 逆元：乘法 AES字节为处理单元 8bits 加法：mod 2 多项式除法 8 4 3 1 0 的末多项式取模 多项式运算 128 128，192，256 S-按列 四个基本做出 10 12 14 s:16 字节代换 She 16*16 S里面查表代换 二进制 十六进展 求逆 混淆效应 乱了 行移位 ​ 循环左移 列混淆 ​ 每一列矩阵现场 ​ 看成多项式 ​ 矩阵选择 轮密钥加 异或：子密钥 居住 ​ 初始密钥， AES ​ 四个位-》一个字节-》16进制 一个字节=》两个十六进数 密钥扩展算法 逆S盒 Day 4 现代密码学 3-27公钥：密钥管理， 非对称密码体制 密钥对 pk sk 加密：公钥 优势： ​ 密钥分发 ​ 密钥管理 ：1 N-1 ​ 开放系统 RSA加密算法数学知识 ​ 算法 大数据分解 密钥生成 最大公因子和乘法逆元的计算方法。 https://blog.csdn.net/boksic/article/details/7014386 https://blog.csdn.net/a745233700/article/details/102341542?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5 https://blog.csdn.net/weixin_34138377/article/details/92199465?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4 https://blog.csdn.net/weixin_41482303/article/details/85417302?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3 签名 证书 https://blog.csdn.net/weixin_34007879/article/details/85528967?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[or]]></title>
    <url>%2F2019%2F12%2F01%2For%2F</url>
    <content type="text"><![CDATA[运筹学目的是在决策时为管理人员提供科学依据。 利用统计学，数学模型和算法等方法，寻找复杂问题中的最佳或者近似最佳的解答。 解决问题的优化算法。 模型建立实际问题 决策变量 影响所要到达目的的因素找到决策变量 目标函数 约束条件 线性规划整数规划1、纯整数规划：所有决策变量均要求为整数的整数规划2、混合整数规划：部分决策变量均要求为整数的整数规划3、纯0－1整数规划：所有决策变量均要求为0－1的整数规划4、混合0－1规划：部分决策变量均要求为0－1的整数规划 分支定界法 : 精确算法—分支定界法(Branch and Bound Algorithm, B&amp;B) 这就意味着，要么花钱买以上求解器的使用权，要么就自己写B&amp;B算法的Code，然后忍受Cplex 1分钟可以求解的问题却要花1天时间的求解。（很多问题时间就是金钱，例如航班延误后剩余航班重新排班的问题，通常需要在10分钟内求解） 想法： 首先，可以确定的是这是个航班重新排班的问题，数学上，航班安排属于运筹学的问题之一，需要应用建立优化模型解决。建立最优化问题，最重要的两步是模型建立和模型求解。模型的建立：需要确定决策变量（整数规划，混合整数规划)，目标函数（多目标），约束条件。 模型的求解： 分层序列法 。 课堂背景航班的重排班问题，最优化问题，运筹学范畴的问题。 约束：算法能够在满足多种实际约束条件的前提下，可以对航班计划进行恢复，并快速给出最优的航班调整替换方案 ； 航班运行与机组编排的各类约束条件 ； 根据航班计划对机组排班计划进行调整，使得机组的资质等与航班计划可以匹配， 川航一个月内的全部航班计划与机组排班计划 备用飞机 有限 调整分机飞行顺序 航班延迟 不能提前起飞 不能超过延误时间 航班取消 如果超过了延误时间，目标函数增加调整成本 旅客转签 只能一次转，还有座位限制 航班直飞 航班由于天气或流控等原因无法顺畅运行时，将联程航班中段取消直飞最终目的地，并妥善处置旅客是航班调整方法之一。（联程航班定义为，前后段衔接并且航班号相同的多个航班） 机组调整（一） 备份机组在航班计划出现机组实力缺口时，可以在航班的出发地寻找空闲机组，安排其执行该航班。（二） 调换机组将多个机组的航班计划进行调换。（三） 机组摆渡当遇到机组计划不衔接（机组的上个航班的目的地与下个航班的出发地不一致）时，可以通过摆渡的方式，采用飞机或是其他交通工具到达下个航班的出发地。 目标： 将航班运行情况受到的影响降到最低从而使得航班与机组计划得到快速恢复、减少航班延误、提高航班正常率，使旅客有更好的出行体验，并提升公司的运行效率与经济效益。 航公公司： 损失最小 游客: 航班延时短]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F11%2F27%2Flinux%2F</url>
    <content type="text"><![CDATA[linux内核，linux发行版（带桌面环境），服务器的访问方式（三种），linux操作系统的相关使用，通过命令行和键盘输入搞定（用户权限，用户分组，用户之间的关系，用户操作；文件结构，文件使用，文件权限，文件编辑，文件压缩和解压，这系列操作类比操作系统，只是linux系统里面，都是命令行完成，不是可视化界面罢了；帮助，终止操作，root，sudo,超级管理员，管理员组，普通用户）windows操作系统可以干的事情，在linux服务器里面，都可以干，通过命令行配置，安装，完成！ LinuxLinux 的科普 Linux 是一套免费使用和自由传播的类 Unix 操作系统 ，支持多用户，多任务，支持多线程和对CPU的操作系统。，就像你多少已经了解的 Windows（xp，7，8）和 Mac OS 。 或许你之前不知道 Linux ，要知道，你之前在 Windows 使用百度、谷歌，上淘宝，聊 QQ 时，支撑这些软件和服务的，是后台成千上万的 Linux 服务器主机，它们时时刻刻都在忙碌地进行着数据处理和运算，可以说世界上大部分软件和服务都是运行在 Linux 之上的。 明确目的：你是要用 Linux 来干什么，搭建服务器、做程序开发、日常办公，还是娱乐游戏； 兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导（这正是我们要做的事情），一旦熟练之后效率极高。 一般命令行操作，通过键盘完成 因为linux的哲学就是：没有结果就是最好的结果 如果只是执行，执行失败会告诉你哪里错了，如果执行成功那么会没有输出，因为linux的哲学就是：没有结果就是最好的结果 Linux的发行版Linux发行版 = linux内核+应用软件的打包 知名的发行版： ubuntu，redhat,centos Linux系统 用户登录系统 （1）命令行 （2）ssh登录 SSH 为 Secure Shell 的缩写 ，用于远程登陆的协议 远程连接工具客户端：xshell, putty, (3) 图形界面登录 文件目录以及权限 Linux 中创建、删除用户，及用户组等操作。 Linux 中的文件权限设置。 1.2 实验知识点 Linux 用户管理 Linux 权限管理 用户管理 通过第一节课程的学习，你应该已经知道，Linux 是一个可以实现多用户登录的操作系统，比如“李雷”和“韩梅梅”都可以同时登录同一台主机，他们共享一些主机的资源，但他们也分别有自己的用户空间，用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于 Linux 的 用户管理和 权限机制，不同用户不可以轻易地查看、修改彼此的文件。 在 Linux 系统里， root 账户拥有整个系统至高无上的权利，比如 新建/添加 用户。 sudo adduser lilei 创建用户（sudo 组） 我们一般登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，这里就要用到 sudo 这个命令了。不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。 sudo命令：获得root权限 用户组 查看： 在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源 。 groups shiyanlou 加入sudo用户组 su ：切换用户user，需要输入目标用户和密码 sudo usermod -G sudo lilei 文件所以者 su -l lilei su chown 修改权限 sudo 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。 文档编辑 vim编辑器 i esc :wq linux文件系统与磁盘管理 $ tree / pwd cd ..: 上一级目录 ../ /:根目录：绝对路径 cd /home/shiyanlou touch test mkdir mydir cp（copy）命令复制一个文件到指定目录 要成功复制目录需要加上 -r 或者 -R 参数，表示递归复制 cd /home/shiyanlou mkdir family​ cp -r father family rm test 跟复制目录一样，要删除一个目录，也需要加上 `-r` 或 `-R` 参数 mv 源目录文件 目的目录 ，可以用来重命名文件 $ cd /home/shiyanlou/ 使用通配符批量创建 5 个文件: $ touch file{1..5}.txt 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件: $ rename ‘s/.txt/.c/‘ *.txt 批量将这 5 个文件，文件名和后缀改为大写: $ rename ‘y/a-z/A-Z/‘ *.c 文件打包和解压缩 zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数、 tar -cf shiyanlou.tar /home/shiyanlou/Desktop -c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后 tar -xf shiyanlou.tar -C tardir 解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数） tar -xzf shiyanlou.tar.gz | 压缩文件格式 | 参数 || —————— | —— || *.tar.gz | -z || *.tar.xz | -J || *tar.bz2 | -j | linux安装软件 输入，输出 输入：输入当然就是打开终端，然后按键盘输入，然后按回车，输入格式一般就是这类的 输出： 输出会返回你想要的结果，比如你要看什么文件，就会返回文件的内容。 如果只是执行，执行失败会告诉你哪里错了，如果执行成功那么会没有输出，因为linux的哲学就是：没有结果就是最好的结果 Tab: 命令补全 Ctrl+C:强制终止 学会使用通配符：通配符：*,? 学会在命令行中获取帮助：man命令调用手册页， 区段 说明 1 一般命令 2 系统调用 3 库函数，涵盖了C标准函数库 4 特殊文件（通常是/dev中的设备）和驱动程序 5 文件格式和约定 6 游戏和屏保 7 杂项 8 系统管理命令和守护进程 1man 1 ls 1ls --help]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清晰有效的数据分析思路]]></title>
    <url>%2F2019%2F11%2F26%2F%E6%B8%85%E6%99%B0%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[如何做数据分析汇报1. 描述数据的表征描述性统计： 平均数 中位数 众数 几何平均数 调和平均数 平均值 中间位置的数 出现次数最多 方差 标准差 分布 得到第一份数据结论 2. 寻找变化，深入观察发生变化的指标一般就是指标关联的业务环境发生了某种变化。通过观察变化量，寻找可能的业务问题点。 同比 对比同期的变化 如：上周五和去年过年 环比 对比连续周期 如：今天和昨天；本月和上月； 增长率 评估累计型指标的有力工具 如：收入 时间上的对比，也称为纵比 ：环比，同比 同级单位之间的比较，简称横比 ： 不同省份之间的分析 得到第二份数据结论，可以分析到问题所在。 3.全面评估，多维分析多维分析： 维度是描述指标 不同角度，通过多维分析，来寻求指标的变化的可以的原因。 广义的多维分析，不仅仅包括从指标的不同维度进行分析，也包含拆分为多个子指标进行分析。 指标体系+维度体系 基础/通用 年龄、性别、学历、地域、手机型号、操作系统 产品 产品类型、归属业务 运营 归属渠道、投放周期、活动类型 营销 市场推广、营销方式、营销目的 如粽子的维度 产品维度 肉粽，大枣棕，糖总 渠道维度 线上：自有APP,电商渠道，合作渠道；线下：合作门店，大屏广告 时间维度 投放周期；投放时段 地域维度 直辖市；省会；二三线城市 年龄维度 年龄段 线上入口 splash,banner,弹窗，角标 输入：第三份结论；单指标分析：得到分析到上升，下降的原因。 4. 多指标交叉分析维度偏差： 大数据涉及的维度很多单一维度分析会出现偏差，多个维度组合起来的时候可能得到相反的结论。 幸存者偏差：样本的丢失问题 第四份分析结论：分析得到出现的问题？ 5. 量化评估，寻找归因相关性分析： 在业务中，通过是为了量化评估各种因素对于核心指标的影响程度，寻找对业务影响的原因。 相关性分析： 单因素相关性分析 多因素的相关性分析 第五份分析结论： 找到了核心影响因素了 6. 回到未来、趋势预测趋势预测： 预测分析是一种统计或数据挖掘解决方案 时间序列预测：一般时间序列预测；季节性时间序列预测；复合时间序列预测 数学层面是严谨的 用一些数据预测方法和算法：指数平滑模型 业务层面是易变的 实际业务环境中，影响未来发展的还会有行业环境的突变，资源的突变，产品客群的突变等，人为的干扰较大。业务层面的趋势预测是不稳定的，且易变的 得到第五份结论：未来效果 7. 分析的实相，落地业务分析的结论和数据逻辑与业务方—-确认，数据分析一定要闭环，即从业务中来，到业务中去。 指标和维的概念 指标 ​ 指标:衡量事物发展程度的单位和方法，也叫度量。如：人口数，GDP, 收入，用户数，利润利，留存率，覆盖率等。 ​ 指标分为：绝对数指标和相对数指标。绝对指标：反映了规模大小；相对指标：反映了质量好坏的指标。 维度 事物或者现象的某种特征，如性别，地区，时间。 ​ 分为定量维度和定性维度。定性：字符型数据；定量：数值型。 只有通过事物发展的数量、质量两大方面，从横比、纵比角度进行全方位的比较，我们才能够全面的了解事物发展的好坏 通俗举个例子：2019年各个省级的经济发展状况：GDP总量：指标；省份，二三线城市：维度； ​ 总结： 数据分析的典型过程；指标拆分，维度对比； 产品（Product），是用来满足人们需求和欲望的物体或无形的载体。产品的实体称为一般产品。产品包含了产品的核心利益（向消费者提供的基本效用和利益） 1. 软件，通讯，手机，科技产品 市场是指一种货物或劳务的潜在购买者的集合需求。 在市场营销组合中， 4P 分别是产品( product) 、价格( price) 、地点( place) 、促销( promotion) 营销是创造、沟通与传送价值给顾客，及经营顾客关系以便让组织与其利益关系人（stakeholder）受益的一种组织功能与程序。 通俗地讲，就是通过宣传、推广，进而促进产品或服务的销售。 互联网产品公司三个业务部分：产品，技术，运营 产品：把东西想出来 技术：把东西做出来 运营：把东西用起来 从字面上看，运，是让产品维持运转；营，是让产品运转得更好，就是要对用户群体进行有目的地组织和管理，增加用户数量、用户粘性、用户贡献和用户忠诚度，这也就涉及到运营工作的三个重要方面：拉新、留存、促活。 理解问题—&gt; 设计解决方案—&gt; 迭代方案，直到问题解决 数据分析师的技能之路 week 01: Excel学习掌握 week 02: 数据可视化 week 03： 分析思维的训练 week 04: 数据库学习 week 05: 统计知识学习 week 06: 业务学习（用户行为，产品，运营） week 07： Python/R学习 数据分析应有的逻辑思维及分析方法提出问题➟分析问题➟提出假设➟验证假设➟输出结论 01 目标思维 在陈述问题时所使用的KWIC方法，其实也是逻辑要素的延伸： 1）K（KEY）：核心观点 2）W（Widen）：扩展核心观点包含的内容 3）I（Illustrate）：举例说明佐证观点 4）C（Conclude）：总结 02 结构化思维结构化思维能够帮助我们将无序、散乱的信息进行聚焦、归纳、分类。 03 推理思维确认论点，结构化论据，下一步是论证。在论证中运用推理思维能够帮助我们迅速找到问题的异同点，从而发现它们的规律。 归纳法，指从特殊（部分样本）到一般（全量样本）的过程，通俗的说是从个别的经验归纳出普遍规律的方法。 这实质上是以偏概全的方法，一旦有一个用户不满足这个前提，这个结论就无法成立。 在输出结论之前需要判断样本是否足够有代表性，判断是必然事件还是随机事件。 3-2、演绎法 演绎法则与归纳法相反,是从既有经证实的普遍性结论，推导出个别性结论的一种方法，常见的表现形式是逻辑三段论。 逻辑三段论的格式为：大前提、小前提、结论。 3-3、因果关系分析法 枚举完毕后，辩证时提问3个问题： 1）原因是否真实？ 2）结果是否真实 3）这个原因一定会引起这个结果吗？是否有其他的原因？ 数据分析的方法01 数据分析前的准备1-1、分清楚目标和指标 数据分析，能帮助我们了解业务运行状况，并从中发现问题、优化问题。其次，还能够帮助洞察下一个增长点。 数据分析的意义，往往在数据产生之前。我们应围绕产品目标，进行产品设计以及运营策划。 目标是结果，而指标是对结果分拆的具体要求，是对目标的衡量。 假设我们的目标是提升年度成交金额，那衡量这个目标的方法是什么呢？ 根据衡量的方法我们才能定向的设置调整产品设计及运营策略。如果缺少可衡量目标的单位和方法，目标会难以达成。 而围绕目标设置数据的采集方案，可以大大节省数据过滤和清洗的时间。 甚至于在明确指标后再最开始就设置好分析模型，通过监测模型中的数据情况更及时的发现问题，做出更高质、高效的决策。 1-2、辨别指标的目的 结果指标用于衡量目标，过程指标用于体现如何完成。观察指标则指的受影响指标，其是否会受到自变量（结果指标）的影响，导致上升或下降。 在上图中，基于成交订单数，设置过程指标为订单平均金额及商品分布能帮助我们了解完成的方式。 1-3、确认分析类型 在完成目标和指标后，下一步就是应用结构化思维进行拆解和延伸。 拆解出的指标目的是什么？根据目的我们才能有倾向性的分析。 1）描述性分析 表现形式：数据报表 数据报表能够帮助我们描述事件发展的情况，但很难解释某种结果发生的原因和未来可能的趋势。 它更偏向结果性的描述，此前的结果对此后是不具备太多参考意义的。 2）测性分析 表现形式：用户相似度及物品相似度计算、用户购买饱和度、用户成交影响因子 预测性分析可以理解为对结果和变量的关系进行预测的过程，包含相似度、相关性分析、回归分析等。 相似度多用于推荐算法，通过计算用户的相似度和商品相似度从而推荐给用户。而相关分析用于预测变量的关联性，如用户的成交会受什么因素影响。 3）实证性分析及规范性分析 表现形式：A/B实验 实证性分析，指是什么，偏向于客观；规范性分析指应当做什么，偏向于主观。 在实际使用过程，上述的4种分析类型常常会被混合使用，混合使用时应明确不同类型我们应采取的分析维度。 数据分析是有顺承关系的，先采集事实，再根据事实或者预测，提出我们的假设。逐步灰度地验证假设，最终才输出我们的结论。 不能将主观猜测强加于事实之上，已经发生的结果并不一定是未来的结果 02 数据分析如何带来长期价值 为了使有用功更多，下文将从用户和收益2个维度分享数据如何为我们沉淀长期价值。 2-1、了解我们的用户 1）基础信息 基础信息，指用户本身的属性。 身份特征，可以从自然属性、社会属性向下细分，包含用户的性别、年龄、职业、教育等。 渠道属性，指用户的注册时间、注册平台、注册来源等。 2）决策类型 决策类型，主要分为决策周期、品类偏好、促销偏好、对象偏好，这是用户分析中常常被忽略的一方面。 决策周期中的首次访问，指的首次触及该商品的时间。结合次数、时长以及成交时间，从而了解用户的决策周期。 品类偏好，结合品牌和历史成交单数，能够帮助我们获悉品牌、价格综合对用户的影响。 而成交品类、商品、单数则是帮助我们理解其品类购买深度及路径，用于进行关联推荐和评判用户的价值。 促销偏好，结合品类和折扣金额了解用户的敏感度，能更好的提高其转化率。对象偏好，同样是了解购买深度及路径，不过维度不同。 在用户层面的分析，此前接触的一些朋友都非常热衷于使用RFM模型，在使用过程中也应“因地制宜”。 3）购买路径 品类深度、对象深度是影响决策类型的因子，当它们在购买路径时则聚焦于次序。 根据次序，制定运营的发力点，再遵循用户的购买路径制定转化路径。 在用户分布相对稳定的前提下，应顺从用户的购买规律而非倾力于另一条主线。 一专多强的前提是专，只有聚焦优势品类或主题建立了优势，才能为其他的方向供应炮弹。 4）增长观察 前面解决的问题是：他是谁，买什么以及怎么买。最后一点，则是增长观察。 购买路径聚焦于次序，增长观察聚焦于深度。购买的次序是运营的主线，购买的深度用于精细化运营。 了解用户在品类和对象的购买深度，再辅以ARPU与LTV的比对，从用户的剩余潜力寻找平台增长点的方式。 2-2、建立你的用户模型 当时我把平台用户的地域年龄、性别等分布介绍了一番。紧接着他提问：“根据这样的画像你能够做什么呢？” 基于对用户的认识建立模型，以上一小节的决策模型为例。 将决策类型、品类偏好、对象偏好、促销偏好4个因子的关联，并辅以用户的基础信息进行组合。 如：“精打细算、专注大牌、疼爱孩子的母亲”。 这样一来冰冷的数据也被赋予了情感化的表达，无论是产品设计、交互设计、产品运营都会变得容易的多。 建立起用户模型，才能够更好地进行情感化设计、精细化运营。 https://mp.weixin.qq.com/s/eWYiHNJ57aXtqygitnwVqw]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apriori]]></title>
    <url>%2F2019%2F11%2F25%2FApriori%2F</url>
    <content type="text"><![CDATA[Apriori 算法是一种挖掘关联规则的频繁项集的算法。 引言对于特征构成的集合$A$, 如果列出非空集合有$a^{|A|}-1$种，太恐怖了。 Aprior算法：核心想法是 L_1是频繁的，则其子集也是频繁的。 L_1是非频繁的，则其超集是非频繁的 这样的化，就大大减小了搜索空间了。 Aprior算法的过程： $C_i$：表示数据集生成候选项集 $L_i$:表示生成的频繁项集 $C_{k-1}$产生$L_k$ 支持度 support(\{A,B\}) = num\{AUB\}/W = P(A \ bing \ B)W:总的记录， 置信度 Confidence(A->B) = support(\{A,B\})/support(B) = P(B/A)注意：support(B)和Confidence(A-&gt;B)的影响， 序列模型考虑时间，如周一买一堆对象，周二买一堆东西 t= {t_1,t_2,..,t_n}\\ s = {s_1,s_2,..,s_n}&lt;{s1},{s_2}&gt;是正确的 &lt;{s1,s2}}&gt;是错误的表达]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>关联规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的数据探索]]></title>
    <url>%2F2019%2F11%2F20%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[简单的探索数据的方法总结一些简单的数据分析方法，以及常用的python 库 Pandas里面相应的函数。 统计汇总单个特征1decrible() # 给出样本的基本统计量 频率 众数 百分位数 位置度量 均值和方差 散布度量： 极差和方差]]></content>
      <categories>
        <category>数据挖掘</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F11%2F15%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python Basics]]></title>
    <url>%2F2019%2F05%2F28%2FPython-basic%2F</url>
    <content type="text"><![CDATA[重新学习开始很乱的学习Python，现在想系统学习基础，真正了解pythonic,]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Networks]]></title>
    <url>%2F2019%2F05%2F12%2FDeel%20Learning%20ai_Convolutional%20Neural%20Networks%2F</url>
    <content type="text"><![CDATA[C4 : Convolutional Neural Networks(卷积神经网络)W1 :Convolutional Neural Networks(卷积神经网络)L1: Computer Vision Image classification Object detection Neural Style Transfer Problem : input big 神经网络结构复杂，数据量相对较少，容易出现过拟合； 所需内存和计算量巨大。 L2: Edge detection example我们之前提到过，神经网络由浅层到深层，分别可以检测出图片的边缘特征、局部特征（例如眼睛、鼻子等），到最后面的一层就可以根据前面检测的特征来识别整体面部轮廓。这些工作都是依托卷积神经网络来实现的。 卷积运算（Convolutional Operation）是卷积神经网络最基本的组成部分。我们以边缘检测为例，来解释卷积是怎样运算的。 常见的边缘检测 垂直边缘（Vertical Edges) 和 水平边缘（horizontal Edges) 这张图的栏杆就对应垂直线，栏杆的水平线是水平边缘。 那么图片是怎么检测边缘的呢？ 过滤器：filter 在数学中“”就是卷积的标准标志，但是在Python中，这个标识常常被用来表示乘法或者元素乘法。 Output; 4 by 4 具体运算： 1） 为了计算第一个元素，在4×4左上角的那个元素，使用3×3的过滤器，将其覆盖在输入图像，如下图所示。然后进行元素乘法（element-wise products）运算 2）为了弄明白第二个元素是什么，你要把蓝色的方块，向右移动一步，像这样，把这些绿色的标记去掉： 6×6矩阵和3×3矩阵进行卷积运算得到4×4矩阵。这些图片和过滤器是不同维度的矩阵，但左边矩阵容易被理解为一张图片，中间的这个被理解为过滤器，右边的图片我们可以理解为另一张图片。这个就是垂直边缘检测器。 举例说明： Vertical edge detection 这里在结果可能有点不对头，检测到的边缘太粗了，主要是图片太小了， 卷积操作API 在 Python 中，卷积用conv_forward()表示； 在 Tensorflow 中，卷积用tf.nn.conv2d()表示； 在 keras 中，卷积用Conv2D()表示。 L3: Edge Detection Example 颜色由暗到亮，还是亮到暗 这种滤波器可以区分明暗变化，取绝对值没有区别了 水平边缘 上边相对较亮，而下方相对较暗 复杂栗子 这块区域左边两列是正边，右边一列是负边，正边和负边的值加在一起得到了一个中间值。但假如这个一个非常大的1000×1000的类似这样棋盘风格的大图，就不会出现这些亮度为10的过渡带了，因为图片尺寸很大，这些中间值就会变得非常小。 filter sobel过滤器，优点在于增加了中间一行元素的权重，这使得结果的鲁棒性会更高一些。 charr过滤器，它有着和之前完全不同的特性，实际上也是一种垂直边缘检测，如果你将其翻转90度，你就能得到对应水平边缘检测。 学习的其中一件事就是当你真正想去检测出复杂图像的边缘，你不一定要去使用那些研究者们所选择的这九个数字，但你可以从中获益匪浅。把这矩阵中的9个数字当成9个参数，并且在之后你可以学习使用反向传播算法，其目标就是去理解这9个参数。 这样可能得到一个出色的边缘检测 相比这种单纯的垂直边缘和水平边缘，它可以检测出45°或70°或73°，甚至是任何角度的边缘。所以将矩阵的所有数字都设置为参数，通过数据反馈，让神经网络自动去学习它们，我们会发现神经网络可以学习一些低级的特征，例如这些边缘的特征。 不管是垂直的边缘，水平的边缘，还有其他奇怪角度的边缘，甚至是其它的连名字都没有的过滤器。 Padding按照我们上面讲的图片卷积，如果原始图片尺寸为$n x n$，filter尺寸为$f x f$，则卷积后的图片尺寸为$(n-f+1) x (n-f+1)$，注意f一般为奇数。这样会带来两个问题： 卷积运算后，输出图片尺寸缩小 原始图片边缘信息对输出贡献得少，输出图片丢失边缘信息 边缘像素点只被一个输出所触碰或者使用， 为了解决这些问题，可以在进行卷积操作前，对原始图片在边界上进行填充（Padding），以增加矩阵的大小。通常将 0 作为填充值。 经过padding之后，填充p,原始图片尺寸为$(n+2p) x (n+2p)$，filter尺寸为$f x f$，则卷积后的图片尺寸为$(n+2p-f+1) x (n+2p-f+1)$。若要保证卷积前后图片尺寸不变，则p应满足：$ p=(f-1)/2$,f通常是奇数，如果是偶数，造成不对称填充，第二个原因是当你有一个奇数维过滤器，比如3×3或者5×5的，它就有一个中心点。有时在计算机视觉里，如果有一个中心像素点会更方便，便于指出过滤器的位置 p=0,Valid convolution p=((f-1))/2,Same convolution L05: Strided convolution（卷积步长）Stride表示filter在原图片中水平方向和垂直方向每次的步进长度。之前我们默认stride=1。若stride=2，则表示filter每次步进长度为2，即隔一点移动一次。 我们用s表示stride长度，p表示padding长度，如果原始图片尺寸为n x n，filter尺寸为f x f，则卷积后的图片尺寸为： \left\lfloor\frac{n+2 p-f}{s}+1\right\rfloor X\left\lfloor\frac{n+2 p-f}{s}+1\right\rfloor向下取整 目前为止我们学习的“卷积”实际上被称为互相关（cross-correlation），而非数学意义上的卷积。真正的卷积操作在做元素乘积求和之前，要将滤波器沿水平和垂直轴翻转（相当于旋转 180 度）。因为这种翻转对一般为水平或垂直对称的滤波器影响不大，按照机器学习的惯例，我们通常不进行翻转操作，在简化代码的同时使神经网络能够正常工作。 互相关：过滤器沿水平和垂直轴翻转，元素相乘来计算，这些视频中定义卷积运算时，我们跳过了这个镜像操作。（不进行翻转操作）叫做卷积操作 L06: Convolution over volumes(三维卷积) 卷积运算 过程是将每个单通道（R，G，B）与对应的filter进行卷积运算求和，然后再将3通道的和相加，得到输出图片的一个像素值。 不同通道的滤波算子可以不相同。例如R通道filter实现垂直边缘检测，G和B通道不进行边缘检测，全部置零，或者将R，G，B三通道filter全部设置为水平边缘检测。 为了进行多个卷积运算，实现更多边缘检测，可以增加更多的滤波器组。例如设置第一个滤波器组实现垂直边缘检测，第二个滤波器组实现水平边缘检测。这样，不同滤波器组卷积得到不同的输出，个数由滤波器组决定。 为了进行多个卷积运算，实现更多边缘检测，可以增加更多的滤波器组。例如设置第一个滤波器组实现垂直边缘检测，第二个滤波器组实现水平边缘检测。这样，不同滤波器组卷积得到不同的输出，个数由滤波器组决定。 若输入图片的尺寸为n x n x nc，nc: 通道数目，filter尺寸为f x f x nc，则卷积后的图片尺寸为(n-f+1) x (n-f+1) x nc′。其中，nc为图片通道数目，nc′为滤波器组个数。 L7 : One layer of a convolution network (单层神经网络) CNN单层的所以标记符号，设层数$l$, \begin{array}{l}{f^{[l]}=\text { filter size }} \\ {p^{[l]}=\text { padding }} \\ {g^{[l]}=\text { stride }} \\ {n_{c}^{[l]}=\text { number of filters }}\end{array} \begin{array}{c}{n_{H}^{[l]}=\left\lfloor\frac{n_{H}^{[l-1]}+2 p^{[l]}-f^{[l]}}{s^{[l]}}+1\right\rfloor} \\ { n_{W}^{[l]}=\left\lfloor\frac{n_{W}^{[l-1]}+2 p^{[l]}-f^{[l]}}{s^{[l]}}+1\right\rfloor}\end{array}如果$m$个样本，进行向量化运算，相应的输出维度，为 \mathrm{m} \times n_{H}^{[l]} \times n_{W}^{[l]} \times n_{c}^{[l]}L8 : A simple convolution network example（简单卷积网络示例） 一般而言，图片的height $n^{[l]}_{H}$和width $n^{[l]}_W$随着层数的增加逐渐降低，但channel $n^{[l]}_C$逐渐增加。 CNN有三种类型的layer： Convolution层（CONV） Pooling层（POOL） Fully connected层（FC） L9: Pooling layers(池化层)卷积神经网络除了卷积层，还有池化层来缩减模型的大小，提高运算速度和鲁棒性 池的类型有max pooling(最大池化) 这里步幅是s=2，filter = 2*2是最大池化的超参数,如果是三维，则单独在每个通道执行最大池化操作 关于max pooling的直觉解释： 元素较大的值，可能是卷积过程中提取到的某些特征（比如边界），而max pooling则在压缩了矩阵大小的情况下，保留每个分区内最大的输出，即保留了提取的特征。但理论上还没有证明max pooling的原理，max pooling应用的原因是在实践中效果很好。 Pooling layer: Average pooling 但是最大池化更好用 summary : 输入$n_Hn_Wn_C$,如果没有padding,输出$(n_h-f)/s+1(n_w-f)/s+1n_c$ L10: Convolutional neural network example (卷积神经网络实例)做一个识别数字的CNN网络 LeNet-5架构如下： 通常Conv Layer和Pooling Layer合在一起算一个layer，因为pooling layer并没有参数训练 常见的结构：Conv ==&gt; Pool ==&gt; Conv ==&gt; Pool ==&gt; FC ==&gt; FC ==&gt; softmax 最终还会用FC层（全连接层），与一般NN的处理一样；并在输出层，应用softmax得到10个数字的概率。 在整个网络中，Height和Width是逐渐递减的，但channel和filter是递增的。 关于CNN如何选择超参：可以参考论文的经验。 Activation shape Activation Size #parameters Input: (32, 32, 3) 3072 0 CONV1(f=5, s=1) (28, 28, 6) 4704 156 (=556+6) POOL1 (14, 14, 6) 1176 0 CONV2(f=5, s=1) (10, 10, 16) 1600 416 (=5516+16) POOL2 (5, 5, 16) 400 0 FC3 (120, 1) 120 48120 (=120*400+120) FC4 (84, 1) 84 10164 (=84*120+84) Softmax (10, 1) 10 850 (=10*84+10) L11 Why convolution 参数共享（parameter sharing) 如果用FC的话，参数爆炸啊！如果conv layer 就需要filter检测器，这个参数就少了，还参数共享 稀疏连接(sparsity of connection) 输出中的每个单元仅和输入的一个小分区相关，比如输出的左上角的像素仅仅由输入左上角的9个像素决定（假设filter大小是3*3），而其他输入都不会影响。 summary1. 卷积神经网络的基本构造和计算过程 2. 如何整合这些模型 3. 哪些超参数 4. 为什么使用卷积 W2 : Deep convolutional models: case studies(深度卷积网络：实例探究)L1 : Why look at case studies?(为什么要进行实例探究？)本文将主要介绍几个典型的CNN案例。通过对具体CNN模型及案例的研究，来帮助我们理解知识并训练实际的模型。 典型的CNN模型包括： LeNet-5 AlexNet VGG 还会介绍Residual Network（ResNet）。其特点是可以构建很深很深的神经网络（目前最深的好像有152层）。还会介绍Inception Neural Network L2 : Classic networks(经典网络)1. LeNet-5LeNet-5是针对灰度图片训练的，使用6个5×5的过滤器，步幅为1。由于使用了6个过滤器，步幅为1，padding为0，输出结果为28×28×6，图像尺寸从32×32缩小到28×28。然后进行池化操作，在这篇论文写成的那个年代，人们更喜欢使用平均池化，而现在我们可能用最大池化更多一些。在这个例子中，我们进行平均池化，过滤器的宽度为2，步幅为2，图像的尺寸，高度和宽度都缩小了2倍，输出结果是一个14×14×6的图像。我觉得这张图片应该不是完全按照比例绘制的，如果严格按照比例绘制，新图像的尺寸应该刚好是原图像的一半。 该LeNet模型总共包含了大约6万个参数。值得一提的是，当时Yann LeCun提出的LeNet-5模型池化层使用的是average pool，而且各层激活函数一般是Sigmoid和tanh。现在，我们可以根据需要，做出改进，使用max pool和激活函数ReLU。 1. AlexNetAlexNet模型是由Alex Krizhevsky、Ilya Sutskever和Geoffrey Hinton共同提出的，其结构如下所示： AlexNet首先用一张227×227×3的图片作为输入，实际上原文中使用的图像是224×224×3，但是如果你尝试去推导一下，你会发现227×227这个尺寸更好一些。第一层我们使用96个11×11的过滤器，步幅为4，由于步幅是4，因此尺寸缩小到55×55，缩小了4倍左右。然后用一个3×3的过滤器构建最大池化层,f=3，步幅为2，卷积层尺寸缩小为27×27×96。接着再执行一个5×5的卷积，padding之后，输出是27×27×276。然后再次进行最大池化，尺寸缩小到13×13。再执行一次same卷积，相同的padding，得到的结果是13×13×384，384个过滤器。再做一次same卷积，就像这样。再做一次同样的操作，最后再进行一次最大池化，尺寸缩小到6×6×256。6×6×256等于9216，将其展开为9216个单元，然后是一些全连接层。最后使用softmax函数输出识别的结果，看它究竟是1000个可能的对象中的哪一个。 实际上，这种神经网络与LeNet有很多相似之处，不过AlexNet要大得多。正如前面讲到的LeNet或LeNet-5大约有6万个参数，而AlexNet包含约6000万个参数。当用于训练图像和数据集时，AlexNet能够处理非常相似的基本构造模块，这些模块往往包含着大量的隐藏单元或数据，这一点AlexNet表现出色。AlexNet比LeNet表现更为出色的另一个原因是它使用了ReLu激活函数。原作者还提到了一种优化技巧，叫做Local Response Normalization(LRN)。 而在实际应用中，LRN的效果并不突出。 3. VGG-16 首先用3×3，步幅为1的过滤器构建卷积层，padding参数为same卷积中的参数。然后用一个2×2，步幅为2的过滤器构建最大池化层。因此VGG网络的一大优点是它确实简化了神经网络结构，下面我们具体讲讲这种网络结构。 数字16，就是指在这个网络中包含16个卷积层和全连接层。总共包含约1.38亿个参数 L3 : Residual Networks (ResNets)(残差网络(ResNets))我们知道，如果神经网络层数越多，网络越深，源于梯度消失和梯度爆炸的影响，整个模型难以训练成功。解决的方法之一是人为地让神经网络某些层跳过下一层神经元的连接，隔层相连，弱化每层之间的强联系。这种神经网络被称为Residual Networks(ResNets)。 L4: Why ResNets work?(残差网络为什么有用？) 因此，这两层额外的残差块不会降低网络性能。而如果没有发生梯度消失时，训练得到的非线性关系会使得表现效果进一步提高。 注意，如果$ a[l]$与 $a[l+2]$的维度不同，需要引入矩阵 $W_s$与 $a_{[l]}$相乘，使得二者的维度相匹配。参数矩阵 $W_s$既可以通过模型训练得到，也可以作为固定值，仅使 $a[l]$截断或者补零。 L5 : Network in Network and 1×1 convolutions(网络中的网络以及 1×1 卷积) 作用 假设这是一个28×28×192的输入层，你可以使用池化层压缩它的高度和宽度，这个过程我们很清楚。但如果通道数量很大，该如何把它压缩为28×28×32维度的层呢？你可以用32个大小为1×1的过滤器，严格来讲每个过滤器大小都是1×1×192维，因为过滤器中通道数量必须与输入层中通道的数量保持一致。但是你使用了32个过滤器，输出层为28×28×32，这就是压缩通道数（$n_c$）的方法，对于池化层我只是压缩了这些层的高度和宽度 doing something pretty non-trivial 它给神经网络添加了一个非线性函数，从而减少或保持输入层中的通道数量不变，当然如果你愿意，也可以增加通道数量。 L6 : Inception network motivation(谷歌 Inception 网络简介) 有了这样的Inception模块，你就可以输入某个量，因为它累加了所有数字，这里的最终输出为32+32+128+64=256。有了这样的Inception模块，你就可以输入某个量，因为它累加了所有数字，这里的最终输出为32+32+128+64=256。Inception 网络选用不同尺寸的滤波器进行 Same 卷积，并将卷积和池化得到的输出组合拼接起来，最终让网络自己去学习需要的参数和采用的滤波器组合。 1x1 的卷积层通常被称作瓶颈层（Bottleneck layer） 计算量为 28x28x32x5x5x192 = 1.2亿 28x28x192x16 + 28x28x32x5x5x15 = 1.24 千万，减少了约 90%。 L7 : Inception network(Inception 网络) L8 : Using open-source implementations( 使用开源的实现方案)开源项目 L9 ： Transfer Learning（迁移学习）如果你下载别人已经训练好网络结构的权重，你通常能够进展的相当快，用这个作为预训练，然后转换到你感兴趣的任务上。 只有很小数据集： 可以你只需要训练softmax层的权重，把前面这些层的权重都冻结。 稍微更大的数据集： 你应该冻结更少的层，比如只把这些层冻结，然后训练后面的层。如果你的输出层的类别不同，那么你需要构建自己的输出单元；或者你可以直接去掉这几层，换成你自己的隐藏单元和你自己的softmax输出层，这些方法值得一试。 大量数据： 你可以用下载的权重只作为初始化，用它们来代替随机初始化，接着你可以用梯度下降训练，更新网络所有层的所有权重。 L10 ： Data augmentation（数据增强）数据量远远不够 Mirroring Random Cropping 彩色转换color shifting r,g,b数据改变 除了随意改变RGB通道数值外，还可以更有针对性地对图片的RGB通道进行PCA color augmentation，也就是对图片颜色进行主成分分析，对主要的通道颜色进行增加或减少，可以采用高斯扰动做法。这样也能增加有效的样本数量。具体的PCA color augmentation做法可以查阅AlexNet的相关论文。 常用的实现数据扩充的方法是使用一个线程或者是多线程，这些可以用来加载数据，实现变形失真，然后传给其他的线程或者其他进程，来训练这个（编号2）和这个（编号1），可以并行实现。 L11：The state of computer vision(计算机视觉现状) 神经网络需要数据，不同的网络模型所需的数据量是不同的。Object dection，Image recognition，Speech recognition所需的数据量依次增加。一般来说，如果data较少，那么就需要更多的hand-engineering，对已有data进行处理。 hand-engineering是一项非常重要也比较困难的工作。很多时候，hand-engineering对模型训练效果影响很大，特别是在数据量不多的情况下。 当你有少量的数据时，有一件事对你很有帮助，那就是迁移学习。在别人做好的基础上研究 提升性能 * 由于计算机视觉问题建立在小数据集之上，其他人已经完成了大量的网络架构的手工工程。一个神经网络在某个计算机视觉问题上很有效，但令人惊讶的是它通常也会解决其他计算机视觉问题。 所以，要想建立一个实用的系统，你最好先从其他人的神经网络架构入手。如果可能的话，你可以使用开源的一些应用，因为开放的源码实现可能已经找到了所有繁琐的细节，比如学习率衰减方式或者超参数。 summary1. CNN的常见网络结构 重点说了一些残差网络 2.数据增加的方法 3. 多用开源框架，不用从头开始训练 W3 Object detection(目标检测)L1 :Object localization(目标定位)目标定位和目标检测 模型 输入还包括位置信息 损失函数 情况一：检测到了 情况二： L2: Landmark detection(特征点检测) 该网络模型共检测人脸上64处特征点，加上是否为face的标志位，输出label共有64x2+1=129个值。通过检测人脸特征点可以进行情绪分类与判断，或者应用于AR领域等等。 除了人脸特征点检测之外，还可以检测人体姿势动作，如下图所示： L3 :Object detection(目标检测)学过了对象定位和特征点检测，今天我们来构建一个对象检测算法。这节课，我们将学习如何通过卷积网络进行对象检测，采用的是基于滑动窗口的目标检测算法。 训练完这个卷积网络，就可以用它来实现滑动窗口目标检测，具体步骤如下。 选定特定大小的窗口，窗口圈定输入卷积神经网络，卷积神经网络开始预测。 重复上述操作，不过这次我们选择一个更大的窗口，截取更大的区域，并输入给卷积神经网络处理，你可以根据卷积网络对输入大小调整这个区域，然后输入给卷积网络，输出0或 如果你这样做，不论汽车在图片的什么位置，总有一个窗口可以检测到它。 这种算法叫作滑动窗口目标检测，因为我们以某个步幅滑动这些方框窗口遍历整张图片，对这些方形区域进行分类，判断里面有没有汽车。 滑动窗算法的优点是原理简单，且不需要人为选定目标区域（检测出目标的滑动窗即为目标区域）。但是其缺点也很明显，首先滑动窗的大小和步进长度都需要人为直观设定。滑动窗过小或过大，步进长度过大均会降低目标检测正确率。而且，每次滑动窗区域都要进行一次CNN网络计算，如果滑动窗和步进长度较小，整个目标检测的算法运行时间会很长。所以，滑动窗算法虽然简单，但是性能不佳，不够快，不够灵活。 L 4 : Convolutional implementation of sliding windows(滑动窗口的卷积实现) 全连接层转化为卷积层 单个窗口区域卷积网络结构建立完毕之后，对于待检测图片，即可使用该网络参数和结构进行运算。例如16 x 16 x 3的图片，步进长度为2，CNN网络得到的输出层为2 x 2 x 4。其中，2 x 2表示共有4个窗口结果。对于更复杂的28 x 28 x3的图片，CNN网络得到的输出层为8 x 8 x 4，共64个窗口结果。 之前的滑动窗算法需要反复进行CNN正向计算，例如16 x 16 x 3的图片需进行4次，28 x 28 x3的图片需进行64次。而利用卷积操作代替滑动窗算法，则不管原始图片有多大，只需要进行一次CNN正向计算，因为其中共享了很多重复计算部分，这大大节约了运算成本。值得一提的是，窗口步进长度与选择的MAX POOL大小有关。如果需要步进长度为4，只需设置MAX POOL为4 x 4即可。 L5 ： Bounding box predictions（Bounding Box预测） YOLO（You Only Look Once）算法可以解决这类问题，生成更加准确的目标区域（如上图红色窗口）。 如果目标中心坐标(bx,by)不在当前网格内，则当前网格Pc=0；相反，则当前网格Pc=1（即只看中心坐标是否在当前网格内）。判断有目标的网格中，bx,by,bh,bw限定了目标区域。值得注意的是，当前网格左上角坐标设定为(0, 0)，右下角坐标设定为(1, 1)，(bx,by)范围限定在[0,1]之间，但是bh,bw可以大于1。因为目标可能超出该网格，横跨多个区域，如上图所示。目标占几个网格没有关系，目标中心坐标必然在一个网格之内。 L6 ：Intersection over union（交并比) 一般约定，在计算机检测任务中，如果lou&gt;=0.5，就说检测正确，如果预测器和实际边界框完美重叠，loU就是1，因为交集就等于并集。但一般来说只要lou&gt;=0.5，那么结果是可以接受的，看起来还可以。一般约定，0.5是阈值，用来判断预测的边界框是否正确。一般是这么约定，但如果你希望更严格一点，你可以将loU定得更高，比如说大于0.6或者更大的数字，但loU越高，边界框越精确。 L7: Non-max suppression(非极大值抑制)到目前为止你们学到的对象检测中的一个问题是，你的算法可能对同一个对象做出多次检测，所以算法不是对某个对象检测出一次，而是检测出多次。非极大值抑制这个方法可以确保你的算法对每个对象只检测一次，我们讲一个例子。 假设你需要在这张图片里检测行人和汽车，你可能会在上面放个19×19网格，理论上这辆车只有一个中点，所以它应该只被分配到一个格子里，左边的车子也只有一个中点，所以理论上应该只有一个格子做出有车的预测。 实际情况是格子1，2，3，4，5，6都认为里面有车。因为你要在361个格子上都运行一次图像检测和定位算法，那么可能很多格子都会举手说我的pc,我这个格子里有车的概率很高，而不是361个格子中仅有两个格子会报告它们检测出一个对象。 非最大值抑制（Non-max Suppression）做法很简单，图示每个网格的Pc值可以求出，Pc值反映了该网格包含目标中心坐标的可信度。首先选取Pc最大值对应的网格和区域，然后计算该区域与所有其它区域的IoU，剔除掉IoU大于阈值（例如0.5）的所有网格及区域。这样就能保证同一目标只有一个网格与之对应，且该网格Pc最大，最可信。接着，再从剩下的网格中选取Pc最大的网格，重复上一步的操作。最后，就能使得每个目标都仅由一个网格和区域对应。如下图所示： 总结一下非最大值抑制算法的流程： 剔除Pc值小于某阈值（例如0.6）的所有网格； 选取Pc值最大的网格，利用IoU，摒弃与该网格交叠较大的网格； 对剩下的网格，重复步骤2。 到目前为止，对象检测中存在的一个问题是每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，你可以这么做，就是使用anchor box这个概念，我们从一个例子开始讲吧。方法是使用不同形状的Anchor Boxes。 这就是anchor box的概念，我们建立anchor box这个概念，是为了处理两个对象出现在同一个格子的情况，实践中这种情况很少发生 L9 : YOLO 算法（Putting it together: YOLO algorithm） 这就是YOLO对象检测算法，这实际上是最有效的对象检测算法之一，包含了整个计算机视觉对象检测领域文献中很多最精妙的思路 Region proposals (Optional)（候选区域（选修））之前介绍的滑动窗算法会对原始图片的每个区域都进行扫描，即使是一些空白的或明显没有目标的区域，例如下图所示。这样会降低算法运行效率，耗费时间。 为了解决这一问题，尽量避免对无用区域的扫描，可以使用Region Proposals的方法。具体做法是先对原始图片进行分割算法处理，然后支队分割后的图片中的块进行目标检测。 Region Proposals共有三种方法： R-CNN: 滑动窗的形式，一次只对单个区域块进行目标检测，运算速度慢。 Fast R-CNN: 利用卷积实现滑动窗算法，类似第4节做法。 Faster R-CNN: 利用卷积对图片进行分割，进一步提高运行速度。 W4：Special applications: Face recognition &amp;Neural style transfer( 特殊应用：人脸识别和神经风格转换)C1 ： What is face recognition?首先简单介绍一下人脸验证（face verification）和人脸识别（face recognition）的区别。 人脸验证：输入一张人脸图片，验证输出与模板是否为同一人，即一对一问题。 人脸识别：输入一张人脸图片，验证输出是否为K个模板中的某一个，即一对多问题。 L2 ： One-shot learningOne-shot learning就是说数据库中每个人的训练样本只包含一张照片，然后训练一个CNN模型来进行人脸识别。若数据库有K个人，则CNN模型输出softmax层就是K维的。 但是One-shot learning的性能并不好，其包含了两个缺点： 每个人只有一张图片，训练样本少，构建的CNN网络不够健壮。 若数据库增加另一个人，输出层softmax的维度就要发生变化，相当于要重新构建CNN网络，使模型计算量大大增加，不够灵活。 为了解决One-shot learning的问题，我们先来介绍相似函数（similarity function）。相似函数表示两张图片的相似程度，用d(img1,img2)来表示。若d(img1,img2)较小，则表示两张图片相似；若d(img1,img2)较大，则表示两张图片不是同一个人。相似函数可以在人脸验证中使用： d(img1,img2)≤τ : 一样 d(img1,img2)&gt;τ : 不一样 现在你已经知道函数d是如何工作的，通过输入两张照片，它将让你能够解决一次学习问题。那么，下节视频中，我们将会学习如何训练你的神经网络学会这个函数。 L3: Siamese network最后一层去掉softmax单元做分类 如果你要比较两个图片的话，例如这里的第一张（编号1）和第二张图片（编号2），你要做的就是把第二张图片喂给有同样参数的同样的神经网络，然后得到一个不同的128维的向量（编号3），这个向量代表或者编码第二个图片，我要把第二张图片的编码叫做$f(x^{(2)})$。这里我用$x^{(1)}$和$x^{(2)}$仅仅代表两个输入图片, d(x^{(1)},x^{(2)})=||f(x^{(1)}-f(x^{(2)}||^2不同的图片的CNN网络结构和参数都是一样的，目标就是利用梯度下降算法，调整网络参数]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Deep Learning Specialization]]></title>
    <url>%2F2019%2F05%2F05%2FDeep%20Learning%20ai_Deep%20Learning%20Specialization%2F</url>
    <content type="text"><![CDATA[C3 Improving Model PerformanceW1 ML Strategy(1)L01 Improving Model Performance需要提高训练结果的表现，表现得更好的措施 Machine Learning Strategy L2 : Orthogonalization(正交化)所谓正交，就是你的操控效果尽量只影响一个方面。比如以老式电视机为例，调节图像的大小、左右偏移、上下偏移。而不是一个按钮可以同时调节图像大小和左右偏移，那样会很难操作。 具体到supervised learning，有以下4个假设是正交的？ Fit training set well in cost function If it doesn’t fit well, the use of a bigger neural network or switching to a better optimization algorithm might help. Fit development set well on cost function If it doesn’t fit well, regularization or using bigger training set might help. Fit test set well on cost function If it doesn’t fit well, the use of a bigger development set might help Performs well in real world If it doesn’t perform well, the development test set is not set correctly or the cost function is not evaluating the right thing. 在训练集上表现欠佳，需要切换到好的优化算法 在验证集上表现不好，一组正则化按钮 在测试集表现不好，需要更好的验证集 在用户体验不好，需要改变测试集大小或者成本函数 L3 Single number evaluation metric(单一数字评估指标)classification Precesion （查准率） recall（查全率） F 1=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2 P R}{P+R}L4 Satisficing and optimizing metrics(满足和优化指标)如果我们还想要将分类器的运行时间也纳入考虑范围，将其和精确率、召回率组合成一个单值评价指标显然不那么合适。这时，我们可以将某些指标作为优化指标（Optimizing Matric），寻求它们的最优值；而将某些指标作为满足指标（Satisficing Matric），只要在一定阈值以内即可。 在这个例子中，准确率就是一个优化指标，因为我们想要分类器尽可能做到正确分类；而运行时间就是一个满足指标，如果你想要分类器的运行时间不多于某个阈值，那最终选择的分类器就应该是以这个阈值为界里面准确率最高的那个。 如此，accuracy就变成了optimizing metric，而running time则是satisfying metric，statisfying metric只要达到标准即可，而optimizing metric则追求更好。一般的，选择一项metric作为optimizing metric，其他的则设置为satisfying metric： L 5: Train/dev/test distributions(训练/开发/测试集划分)开发（dev）集也叫做开发集（development set），有时称为保留交叉验证集（hold out cross validation set）。 如何设置Train/dev/test集，很大程度上影响了机器学习的速度。 Train/dev/test的区别 Workflow in machine learning is that you try a lot of ideas, train up different models on the training set, and then use the dev set to evaluate the different ideas and pick one. And, keep innovating to improve dev set performance until, finally, you have one class that you’re happy with that you then evaluate on your test set. 开发集合和开发集合来自同一分布，如果是不同分布，相当于靶心移动了 L 6: Size of dev and test sets(开发集和测试集的大小) L7 : When to change dev/test sets and metrics(什么时候该改变开发/测试集和指标)如果发现设定目标和实际期望不符，那就调整目标。 举个例子 A可能把一些色情照片也分类成猫了，因此改变优化指标 我想你处理机器学习问题时，应该把它切分成独立的步骤。一步是弄清楚如何定义一个指标来衡量你想做的事情的表现，然后我们可以分开考虑如何改善系统在这个指标上的表现。你们要把机器学习任务看成两个独立的步骤，用目标这个比喻，第一步就是设定目标。所以要定义你要瞄准的目标，这是完全独立的一步，这是你可以调节的一个旋钮。如何设立目标是一个完全独立的问题，把它看成是一个单独的旋钮，可以调试算法表现的旋钮，如何精确瞄准，如何命中目标，定义指标是第一步。 后第二步要做别的事情，在逼近目标的时候，也许你的学习算法针对某个长这样的成本函数优化，$J=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)$你要最小化训练集上的损失。你可以做的其中一件事是，修改这个，为了引入这些权重，也许最后需要修改这个归一化常数，$J=\frac{1}{\sum w^{(i)}} \sum_{i=1}^{m} w^{(i)} L\left(\hat{y}^{(i)}, y^{(i)}\right)$ 再次，如何定义J并不重要，关键在于正交化的思路，把设立目标定为第一步，然后瞄准和射击目标是独立的第二步。换种说法，我鼓励你们将定义指标看成一步，然后在定义了指标之后，你才能想如何优化系统来提高这个指标评分。比如改变你神经网络要优化的成本函数J。 L8 : Why human-level performance?(为什么是人的表现？) 上图展示了随着时间的推进，机器学习系统和人的表现水平的变化。一般的，当机器学习超过人的表现水平后，它的进步速度逐渐变得缓慢，最终性能无法超过某个理论上限，这个上限被称为贝叶斯最优误差（Bayes Optimal Error）。 也因此，只要建立的机器学习模型的表现还没达到人类的表现水平时，就可以通过各种手段来提升它。例如采用人工标记过的数据进行训练，通过人工误差分析了解为什么人能够正确识别，或者是进行偏差、方差分析。 当模型的表现超过人类后，这些手段起的作用就微乎其微了。 L9 : Avoidable bias(可避免偏差) training error 我们经常使用猫分类器来做例子，比如人类具有近乎完美的准确度，所以人类水平的错误是1%。在这种情况下，如果您的学习算法达到8%的训练错误率和10%的开发错误率，那么你也许想在训练集上得到更好的结果。所以事实上，你的算法在训练集上的表现和人类水平的表现有很大差距的话，说明你的算法对训练集的拟合并不好。所以从减少偏差和方差的工具这个角度看，在这种情况下，我会把重点放在减少偏差上。你需要做的是，比如说训练更大的神经网络，或者跑久一点梯度下降，就试试能不能在训练集上做得更好。 dev error 贝叶斯错误率或者对贝叶斯错误率的估计和训练错误率之间的差值称为可避免偏差 L 10: Understanding human-level performance(理解人的表现)还记得上个视频中，我们用过这个词“人类水平错误率”用来估计贝叶斯误差，那就是理论最低的错误率，任何函数不管是现在还是将来，能够到达的最低值 L11 : Surpassing human- level performance(超过人的表现)现在，机器学习有很多问题已经可以大大超越人类水平了。 L12 : Improving your model performance(改善你的模型的表现)你们学过正交化，如何设立开发集和测试集，用人类水平错误率来估计贝叶斯错误率以及如何估计可避免偏差和方差。我们现在把它们全部组合起来写成一套指导方针，如何提高学习算法性能的指导方针。 method summary这一周的内容主要是改善模型的表现，主要是按照正交化，使得更好的满足 1. 评价指标 2. 数据集的划分 3. 人的表现的重要性 4. 当出现表现不好的时候，如何改善呢，有哪些方法呢？ W2 ML Strategy(2)C 1: Carrying out error analysis(进行误差分析)1. simple analysis 通过观察发现算法分类出错的例子，是把狗分成猫，提高准确率的方法就是如何针对狗的图片优化算法。你可以针对狗，收集更多的狗图，或者设计一些只处理狗的算法功能之类的，为了让你的猫分类器在狗图上做的更好，让算法不再将狗分类成猫。现在考虑的是应该不应该这么去做呢？统计一下dev set里面多少是错误标记是狗的个数，分析出可以改善的算法的上限。 mutiply analysis C2 : Cleaning up Incorrectly labeled data(清除标注错误的数据)incorrct labeltraning setDL algorithms are quite robust to random errors in the traning set so long as your errors or your labeled example to once those errors are not too far from random . distribution首先，我鼓励你不管用什么修正手段，都要同时作用到开发集和测试集上，我们之前讨论过为什么，开发和测试集必须来自相同的分布。开发集确定了你的目标，当你击中目标后，你希望算法能够推广到测试集上，这样你的团队能够更高效的在来自同一分布的开发集和测试集上迭代。如果你打算修正开发集上的部分数据，那么最好也对测试集做同样的修正以确保它们继续来自相同的分布。所以我们雇佣了一个人来仔细检查这些标签，但必须同时检查开发集和测试集。 suggestion最后我讲几个建议： 首先，深度学习研究人员有时会喜欢这样说：“我只是把数据提供给算法，我训练过了，效果拔群”。这话说出了很多深度学习错误的真相，更多时候，我们把数据喂给算法，然后训练它，并减少人工干预，减少使用人类的见解。但我认为，在构造实际系统时，通常需要更多的人工错误分析，更多的人类见解来架构这些系统，尽管深度学习的研究人员不愿意承认这点。 其次，不知道为什么，我看一些工程师和研究人员不愿意亲自去看这些样本，也许做这些事情很无聊，坐下来看100或几百个样本来统计错误数量，但我经常亲自这么做。当我带领一个机器学习团队时，我想知道它所犯的错误，我会亲自去看看这些数据，尝试和一部分错误作斗争。我想就因为花了这几分钟，或者几个小时去亲自统计数据，真的可以帮你找到需要优先处理的任务，我发现花时间亲自检查数据非常值得，所以我强烈建议你们这样做，如果你在搭建你的机器学习系统的话，然后你想确定应该优先尝试哪些想法，或者哪些方向。 这就是错误分析过程，在下一个视频中，我想分享一下错误分析是如何在启动新的机器学习项目中发挥作用的。 C3: Build your first system quickly, then iterate(快速搭建你的第一个系统，并进行迭代)1. iterationI recommend that you first quickly set up a definition and metrics so this is really you know deciding where to place your target and you get it wrong you can always move it later we just set up a target somewhere and then I recommend you build an inital machine learning system quickly find the traning set train it and see start to see and understand how well your are doing against your Devon chess setting evaluation metric when you build your initial system you then be able to use bias variance analysis we should talk about earlier as well as error analysis whick we talked about just in last several videos to prioritize the next step in particular if error analysis causes you to realize that a lot of the errors are from the spearker being very far from the mirophone which causes special challenges speech recognitin then that would give you a good reason to focus on techniques to address this it called fast used speech recognition which basically means handling when the speaker is very far from microphone along the value of building this inital system it can be a quick and diry implementation you know do not overthink it but all the value of the inital system is having some learning system having some tranin system allows you lok at bias and variance to do error analysis look at some mistakes to figure out all the different directins you could go in. 我鼓励你们搭建快速而粗糙的实现，然后用它做偏差/方差分析，用它做错误分析，然后用分析结果确定下一步优先要做的方向。 C4 : Training and testing on different distributions(使用来自不同分布的数据，进行训练和测试)this is resulted in many teams sometimes taking one of the days you can find and just shoving it into the training set . Cat app example 假设你在开发一个手机应用，用户会上传他们用手机拍摄的照片，你想识别用户从应用中上传的图片是不是猫。现在你有两个数据来源，一个是你真正关心的数据分布，来自应用上传的数据，比如右边的应用，这些照片一般更业余，取景不太好，有些甚至很模糊，因为它们都是业余用户拍的。另一个数据来源就是你可以用爬虫程序挖掘网页直接下载，就这个样本而言，可以下载很多取景专业、高分辨率、拍摄专业的猫图片。如果你的应用用户数还不多，也许你只收集到10,000张用户上传的照片，但通过爬虫挖掘网页，你可以下载到海量猫图，也许你从互联网上下载了超过20万张猫图。而你真正关心的算法表现是你的最终系统处理来自应用程序的这个图片分布时效果好不好，因为最后你的用户会上传类似右边这些图片，你的分类器必须在这个任务中表现良好。现在你就陷入困境了，因为你有一个相对小的数据集，只有10,000个样本来自那个分布，而你还有一个大得多的数据集来自另一个分布，图片的外观和你真正想要处理的并不一样。但你又不想直接用这10,000张图片，因为这样你的训练集就太小了，使用这20万张图片似乎有帮助。但是，困境在于，这20万张图片并不完全来自你想要的分布，那么你可以怎么做呢？ 我们真正关心的是来自手机手机收集的数据，而不是来自网页。方法一，随机分配训练集、验证集、测试集，这样的后果就是花了大量时间在实际不关心的数据分布去优化。 训练集20万张网络，5000手机，验证集和测试集各2500，这样可以保证验证集和测试集更接近实际应用场景，我们试试搭建一个学习系统，让系统在处理手机上传图片分布时效果良好。缺点在于，当然了，现在你的训练集分布和你的开发集、测试集分布并不一样。但事实证明，这样把数据分成训练、开发和测试集，在长期能给你带来更好的系统性能。我们以后会讨论一些特殊的技巧，可以处理 训练集的分布和开发集和测试集分布不一样的情况。 C5: Bias and Variance with mismatched data distributions（数据分布不匹配时，偏差与方差的分析）首先算法只看过训练集数据，没看过开发集数据。第二，开发集数据来自不同的分布。很难确认这增加的9%误差率有多少是因为算法没看到开发集中的数据导致的，这么评估呢？到底哪个影响元素更大， 评估方法，训练集的分布挖出，traning-dev set : Same distributation as traning set ,but not used for training. 现在，我们有了训练集错误率、训练-验证集错误率，以及验证集错误率。其中，训练集错误率和训练-验证集错误率的差值反映了方差；而训练-验证集错误率和验证集错误率的差值反映了样本分布不一致的问题，从而说明模型擅长处理的数据和我们关心的数据来自不同的分布，我们称之为数据不匹配（Data Mismatch）问题。 C6: Addressing data mismatch（处理数据不匹配问题）I Data: Artifical data synthesis 所以，总而言之，如果你认为存在数据不匹配问题，我建议你做错误分析，或者看看训练集，或者看看开发集，试图找出，试图了解这两个数据分布到底有什么不同，然后看看是否有办法收集更多看起来像开发集的数据作训练。 C7: Transfer learning（迁移学习）迁移学习（Tranfer Learning）是通过将已训练好的神经网络模型的一部分网络结构应用到另一模型，将一个神经网络从某个任务中学到的知识和经验运用到另一个任务中，以显著提高学习任务的性能。 例如，我们将为猫识别器构建的神经网络迁移应用到放射科诊断中。因为猫识别器的神经网络已经学习到了有关图像的结构和性质等方面的知识，所以只要先删除神经网络中原有的输出层，加入新的输出层并随机初始化权重系数（$W[L]$、$b[L]$），随后用新的训练集进行训练，就完成了以上的迁移学习。 如果新的数据集很小，可能只需要重新训练输出层前的最后一层的权重，即$W[L]$$、b[L]$，并保持其他参数不变；而如果有足够多的数据，可以只保留网络结构，重新训练神经网络中所有层的系数。这时初始权重由之前的模型训练得到，这个过程称为预训练（Pre-Training），之后的权重更新过程称为微调（Fine-Tuning）。 在下述场合进行迁移学习是有意义的： 两个任务有同样的输入（比如都是图像或者都是音频）；拥有更多数据的任务迁移到数据较少的任务；某一任务的低层次特征（底层神经网络的某些功能）对另一个任务的学习有帮助。 C8; Multi-task learning （多任务学习）For example, autonomous driving example,check cars,stop signs,trfffic lights ,输出也是一个向量， C9 : What is end-to-end deep learning?(什么是端到端的深度学习)在传统的机器学习分块模型中，每一个模块处理一种输入，然后其输出作为下一个模块的输入，构成一条流水线。而端到端深度学习（End-to-end Deep Learning）只用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。 优点与缺点应用端到端学习的优点： 只要有足够多的数据，剩下的全部交给一个足够大的神经网络。比起传统的机器学习分块模型，可能更能捕获数据中的任何统计信息，而不需要用人类固有的认知（或者说，成见）来进行分析； 所需手工设计的组件更少，简化设计工作流程； 缺点： 需要大量的数据； 排除了可能有用的人工设计组件； 根据以上分析，决定一个问题是否应用端到端学习的关键点是：是否有足够的数据，支持能够直接学习从 x 映射到 y 并且足够复杂的函数？ Whether to use end-to-end learning?(是否要使用端到端的深度学习?)Pros: ​ let the data speak : x-&gt;y ​ less hand-designing of components needed Cons: ​ May need large amount of data ​ excludes potentially useful hand-designed components Key question: Do you hava sufficient data to learn a function of the complexity needed to map x to y? 如果你想使用机器学习或者深度学习来学习某些单独的组件，那么当你应用监督学习时，你应该仔细选择要学习的x到y映射类型，这取决于那些任务你可以收集数据。相比之下，谈论纯端到端深度学习方法是很激动人心的，你输入图像，直接得出方向盘转角，但是就目前能收集到的数据而言，还有我们今天能够用神经网络学习的数据类型而言，这实际上不是最有希望的方法，或者说这个方法并不是团队想出的最好用的方法。而我认为这种纯粹的端到端深度学习方法，其实前景不如这样更复杂的多步方法。因为目前能收集到的数据，还有我们现在训练神经网络的能力是有局限的。 Summary学习如何通过一些手段提高模型的表现，首先了解模型的性能的体现，bias、variance、贝叶斯误差。以及如何一步步的改善性能。具体解决了如下问题，1. 数据的划分 2. 人的表现与机器性能的关系、偏差、方差 3. 训练集和验证集的分布问题，当数据样本对于解决问题不足的时候的解决办法，4. 迁移学习 5. 端到端的学习 6. 多任务学习。6. 在性能不好的情况下，可能需要手动的分析误差，对测试集错误样例做统计等等，]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aiai_]]></title>
    <url>%2F2019%2F04%2F17%2FImprovingDeep%20learning.ai_Deep%20Neural%20NetworksHyperparameter%20tuning%2C%20Regularization%20and%20Optimization%2F</url>
    <content type="text"><![CDATA[C2W1L01 : Train/Dev/Test Sets1. process应用型机器学习是一个高度迭代的过程，通常在项目启动时，我们会先有一个初步想法，比如构建一个含有特定层数，隐藏单元数量或数据集个数等等的神经网络，然后编码，并尝试运行这些代码，通过运行和测试得到该神经网络或这些配置信息的运行结果，你可能会根据输出结果重新完善自己的想法，改变策略，或者为了找到更好的神经网络不断迭代更新自己的方案。 2. data split 训练集（train set）：用训练集对算法或模型进行训练过程； 验证集（development set）：利用验证集（又称为简单交叉验证集，hold-out cross validation set）进行交叉验证，选择出最好的模型或者验证不同算法的有效性。 测试集（test set）：最后利用测试集对模型进行测试，获取模型运行的无偏估计（对学习方法进行评估）。 假设这是训练数据，我用一个长方形表示，我们通常会将这些数据划分成几部分，一部分作为训练集，一部分作为简单交叉验证集，有时也称之为验证集，方便起见，我就叫它验证集（dev set），其实都是同一个概念，最后一部分则作为测试集。 在机器学习发展的小数据量时代，如 100、1000、10000 的数据量大小，可以将数据集按照以下比例进行划分： 无验证集的情况：70% / 30%； 有验证集的情况：60% / 20% / 20%； 在如今的大数据时代，对于一个问题，我们拥有的数据集的规模可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。 验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大到能够验证大约 2-10 种算法哪种更好，而不需要使用 20% 的数据作为验证集。如百万数据中抽取 1 万的数据作为验证集就可以了。 测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中 1000 条数据足以评估单个模型的效果。 100 万数据量：98% / 1% / 1%； 超百万数据量：99.5% / 0.25% / 0.25%（或者99.5% / 0.4% / 0.1%） 3. 建议验证集要和训练集来自于同一个分布（数据来源一致），可以使得机器学习算法变得更快并获得更好的效果。 如果不需要用无偏估计来评估模型的性能，则可以不需要测试集。如果只有验证集，没有测试集，我们要做的就是，在训练集上训练，尝试不同的模型框架，在验证集上评估这些模型，然后迭代并选出适用的模型。因为验证集中已经涵盖测试集数据，其不再提供无偏性能评估。当然，如果你不需要无偏估计，那就再好不过了。 L02 : Bias/Variance“偏差-方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。 泛化误差可分解为偏差、方差与噪声之和： 偏差：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力； 方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响； 噪声：表达了在当前任务上任何学习算法所能够达到的期望泛化误差的下界，即刻画了学习问题本身的难度。 high bias ,underfitting high variance, overfitting just right 1. example Your algorithms ever on the training set and dev set you can try to diganose whether has problems high barriers or high variances or both or neither. L03 Basic Recipe for Machine learning1. METHOD Training a bigger network almost never hurts. And the main cost of training a neural network that’s too big is just computational time, so long as you’re regularizing. 今天我们讲了如何通过组织机器学习来诊断偏差和方差的基本方法，然后选择解决问题的正确操作，希望大家有所了解和认识。我在课上不止一次提到了正则化，它是一种非常实用的减少方差的方法，正则化时会出现偏差方差权衡问题，偏差可能略有增加，如果网络足够大，增幅通常不会太高，我们下节课再细讲，以便大家更好理解如何实现神经网络的正则化。 第一点，高偏差和高方差是两种不同的情况，我们后续要尝试的方法也可能完全不同 只要正则适度，通常构建一个更大的网络便可以，在不影响方差的同时减少偏差，而采用更多数据通常可以在不过多影响偏差的同时减少方差。这两步实际要做的工作是：训练网络，选择网络或者准备更多数据，现在我们有工具可以做到在减少偏差或方差的同时，不对另一方产生过多不良影响。 L041. over fittingregularizationL2 regularization L1 regularizaion: w will be sparse L1 正则化最后得到 w 向量中将存在大量的 0 为什么只正则化参数w？为什么不再加上参数b 呢？你可以这么做，只是我习惯省略不写，因为通常w是一个高维参数矢量，w已经可以表达高偏差问题，可能w包含有很多参数，我们不可能拟合所有参数，而只是b单个数字，所以w几乎涵盖所有参数，而不是，如果加了参数b，其实也没太大影响，因为b只是众多参数中的一个，所以我通常省略不计，如果你想加上这个参数，完全没问题。 2. 矩阵范数被称作“弗罗贝尼乌斯范数”，用下标标注F 反向传播时，填上正则化的一项 因此L2正则化也被称为“权重衰减”。 to get more training data L05 :Why Regularization Reduces Overfitting我们添加正则项，它可以避免数据权值矩阵过大，这就是弗罗贝尼乌斯范数，为什么压缩范数，或者弗罗贝尼乌斯范数或者参数可以减少过拟合？我们尝试消除或至少减少许多隐藏单元的影响，最终这个网络会变得更简单.Regularization其实是让函数变得简化。 直观上理解就是如果正则化设置得足够大，权重矩阵被设置为接近于0的值，直观理解就是把多隐藏单元的权重设为0，于是基本上消除了这些隐藏单元的许多影响。如果是这种情况，这个被大大简化了的神经网络会变成一个很小的网络，小到如同一个逻辑回归单元，可是深度却很大，它会使这个网络从过度拟合的状态更接近左图的高偏差状态。 总结一下，如果正则化参数变得很大，w参数很小，z也会相对变小，此时忽略的b影响，z会相对变小，实际上，z的取值范围很小，这个激活函数tanh，也就是曲线函数会相对呈线性，整个神经网络会计算离线性函数近的值，这个线性函数非常简单，并不是一个极复杂的高度非线性函数，不会发生过拟合。 L2 regularization的不足：要通过不断的选用不同的λ进行测试，计算量加大了。 L06 : Dropout Regularization1. 工作原理 如果上面这幅图存在over fitting。复制这个神经网络，dropout会遍历网络的每一层。假设网络中的每一层，每个节点都以抛硬币的方式设置概率，每个节点得以保留和消除的概率都是0.5，设置完节点概率，我们会消除一些节点，然后删除掉从该节点进出的连线，最后得到一个节点更少，规模更小的网络，然后用backprop方法进行训练。 我们针对每个训练样本训练规模极小的网络，最后你可能会认识到为什么要正则化网络，因为我们在训练极小的网络。 2. inverted dropout（反向随机失活）对第L 1234keep_prob = 0.8 # 设置神经元保留概率dl = np.random.rand(al.shape[0], al.shape[1]) &lt; keep_probal = np.multiply(al, dl)al /= keep_prob 最后一步al /= keep_prob是因为 a[l]a[l]中的一部分元素失活（相当于被归零），为了在下一层计算时不影响 $Z[l+1]=W[l+1]a[l]+b[l+1]$的期望值，因此除以一个keep_prob。举例解释我们假设第三隐藏层上有50个单元或50个神经元，在一维上是50，我们通过因子分解将它拆分成维的，保留和删除它们的概率分别为80%和20%，这意味着最后被删除或归零的单元平均有10（50×20%=10）个，现在我们看下$z^{[4]}$，，我们的预期是$z^{[4]}=w^{[4]}a^{[3]}$，$a^{[3]}$减少20%，也就是说中有$a^{[3]}$20%的元素被归零，为了不影响的$a^{[4]}$期望值，我们需要用$w^{[4]}a^{[3]}/keep_prob$，它将会修正或弥补我们所需的那20%，$a^{[3]}$的期望值不会变，划线部分就是所谓的dropout方法。 L07 : Understanding Dropout直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，dropout将产生收缩权重的平方范数的效果，和之前讲的L2正则化类似；实施dropout的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；L2对不同权重的衰减是不同的，它取决于激活函数倍增的大小。 计算视觉中的输入量非常大，输入太多像素，以至于没有足够的数据，所以dropout在计算机视觉中应用得比较频繁，有些计算机视觉研究人员非常喜欢用它，几乎成了默认的选择，但要牢记一点，dropout是一种正则化方法，它有助于预防过拟合，因此除非算法过拟合，不然我是不会使用dropout的，所以它在其它领域应用得比较少，主要存在于计算机视觉领域，因为我们通常没有足够的数据，所以一直存在过拟合，这就是有些计算机视觉研究人员如此钟情于dropout函数的原因。直观上我认为不能概括其它学科。dropout将产生收缩权重的平方范数的效果。当然，不同的层，值可以设置成不同，如果你觉得某一层容易过拟合，把值设置小一点。 dropout 的一大缺点是成本函数无法被明确定义。因为每次迭代都会随机消除一些神经元结点的影响，因此无法确保成本函数单调递减。因此，使用 dropout 时，先将keep_prob全部设置为 1.0 后运行代码，确保 $J(w,b)$函数单调递减，再打开 dropout。 L08 : Other Regularization Methods 数据扩增（Data Augmentation）：通过图片的一些变换（翻转，局部放大后切割等），得到更多的训练集和验证集。 早停止法（Early Stopping）：将训练集和验证集进行梯度下降时的成本变化曲线画在同一个坐标轴内，当训练集误差降低但验证集误差升高，两者开始发生较大偏差时及时停止迭代，并返回具有最小验证集误差的连接权和阈值，以避免过拟合。这种方法的缺点是无法同时达成偏差和方差的最优。 但对我来说early stopping的主要缺点就是你不能独立地处理这两个问题，因为提早停止梯度下降，也就是停止了优化代价函数，因为现在你不再尝试降低代价函数，所以代价函数的值可能不够小，同时你又希望不出现过拟合，你没有采取不同的方式来解决这两个问题，而是用一种方法同时解决两个问题，这样做的结果是我要考虑的东西变得更复杂。 Early stopping的优点是，只运行一次梯度下降，你可以找出的w较小值，中间值和较大值，而无需尝试正则化超级参数的很多值。 L09 ： Normalizing inputs 零均值 $u=\frac{1}{m}\sum x^{(i)}$,$x-u$ 归一化方差； $\delta^2=\frac{1}{m}(x^{(i)})^2$,每个特征的方差，每个特征数据除以它，就归一化方差了 why 在不使用标准化的成本函数中，如果设置一个较小的学习率，可能需要很多次迭代才能到达全局最优解；而如果使用了标准化，那么无论从哪个位置开始迭代，都能以相对较少的迭代次数找到全局最优解。 L10 : Vanishing /Exploding Gradients训练神经网络，尤其是深度神经所面临的一个问题就是梯度消失或梯度爆炸，也就是你训练神经网络的时候，导数或坡度有时会变得非常大，或者非常小，甚至于以指数方式变小，这加大了训练的难度。 在深度神经网络中，激活函数将以指数级递减，虽然我只是讨论了激活函数以与相关的指数级数增长或下降，它也适用于与层数相关的导数或梯度函数，也是呈指数级增长或呈指数递减。 假定 g(z)=z,b[l]=0g(z)=z,b[l]=0，对于目标输出有： $y^=W[L]W[L−1]…W[2]W[1]X$ 对于$ W[l]$的值大于 1 的情况，激活函数的值将以指数级递增； 对于 $W[l]$的值小于 1 的情况，激活函数的值将以指数级递减。 对于导数同理。因此，在计算梯度时，根据不同情况梯度函数会以指数级递增或递减，导致训练导数难度上升，梯度下降算法的步长会变得非常小，需要训练的时间将会非常长。 L11 : Weight initialization in a deep network为了预防值z过大或过小，你可以看到n越大，你希望w越小，因为z是wx+b的和,最合理的方法$w_i=1/n$ 因此，实际上，你要做的就是设置某层权重矩阵 $w^{[l]}=n p . random. randn (shape) * np.sqrt \left(\frac{1}{n^{[l-1]}}\right)$ 当多个节点时，也一样的看，使得这个节点$z^{L}$不要太大，单独看每个节点既可以 relu : var(w(i)) = 2/n or $\frac{2}{n^{[l-1]}*n^{[l]}}$ tanh: var(w(i)) = 1/n 通过设置初始化化权重矩阵，使得不会增长太快或者太慢 L12 ： Numerical Approximations of Gradients单边误差 $f^{\prime}(\theta)=\lim _{\varepsilon \rightarrow 0} \frac{f(\theta+\varepsilon)-(\theta)}{\varepsilon}$ 误差$O(\varepsilon)$ 双边误差 $f^{\prime}(\theta)=\lim _{\varepsilon \rightarrow 0}=\frac{f(\theta+\varepsilon)-(\theta-\varepsilon)}{2 \varepsilon}$ $O\left(\varepsilon^{2}\right)$ L 13 Gradient Checking梯度检验帮我们节省了很多时间，也多次帮我发现backprop实施过程中的bug，接下来，我们看看如何利用它来调试或检验backprop的实施是否正确。 首先要做的就是，把所有参数转换成一个巨大的向量数据，你要做的就是把矩阵w转换成一个向量，把所有矩阵w转换成向量之后，做连接运算，得到一个巨型向量$\theta$，该向量表示为参数$\theta$，代价函数J是所有W和b的函数，现在你得到了一个的代价函数（即）。接着，你得到与和顺序相同的数据，你同样可以把$dW^{[l]}$,和$db^{[l]}$ 转换成一个新的向量，用它们来初始化大向量$d\theta$，它与$\theta$具有相同维度。 梯度的逼近值 d \theta_{\text { approx }}[i]=\frac{J\left(\theta_{1}, \theta_{2}, \ldots . \theta_{i}+\varepsilon, \ldots\right)-J\left(\theta_{1}, \theta_{2}, \ldots . \theta_{i}-\varepsilon, \ldots\right)}{2 \varepsilon} 现在你已经了解了梯度检验的工作原理，它帮助我在神经网络实施中发现了很多bug，希望它对你也有所帮助。 L 14 : Gradient Checking Implementation notes 不要在训练中使用梯度检验，它只用于调试（debug）。使用完毕关闭梯度检验的功能；太慢了 如果算法的梯度检验失败，要检查所有项，并试着找出 bug，即确定哪个 dθapprox[i] 与 dθ 的值相差比较大； 当成本函数包含正则项时，也需要带上正则项进行检验； 梯度检验不能与 dropout 同时使用。因为每次迭代过程中，dropout 会随机消除隐藏层单元的不同子集，难以计算 dropout 在梯度下降上的成本函数 J。建议关闭 dropout，用梯度检验进行双重检查，确定在没有 dropout 的情况下算法正确，然后打开 dropout； Summary回顾这一周，我们讲了如何配置训练集，验证集和测试集，如何分析偏差和方差，如何处理高偏差或高方差以及高偏差和高方差并存的问题，如何在神经网络中应用不同形式的正则化，如正则化和**dropout**，还有加快神经网络训练速度的技巧，最后是梯度检验。 C2W2 :Optimization AlgorithmL 01 : Mini Batch Gradient Descent Vectorization Mini batch not entire training set bady training set i，$x^{\{i\}}$ mini batch training set mini batch gradient descent L 02 : Understanding Mini-Batch Gradient Decent 左图，随着iterations increased, it should decrease .if it ever goes up on iteration,something is wrong. 右图 : it’s as if on every iteration you’re training on a different training set or really training on a different mini batch. It should trend downwards, but it’s also going to be a little bit noisier.So if you plot J{t}, as you’re training mini batch in descent it may be over multiple epochs,you might expect to see a curve like this. Choosing your mini-batch size 1. 优缺点 通过减小学习率，噪声会被改善或有所减小，但随机梯度下降法的一大缺点是，你会失去所有向量化带给你的加速，因为一次性只处理了一个训练样本，这样效率过于低下，所以实践中最好选择不大不小的mini-batch尺寸，实际上学习率达到最快。你会发现两个好处，一方面，你得到了大量向量化，上个视频中我们用过的例子中，如果mini-batch大小为1000个样本，你就可以对1000个样本向量化，比你一次性处理多个样本快得多。另一方面，你不需要等待整个训练集被处理完就可以开始进行后续工作，再用一下上个视频的数字，每次训练集允许我们采取5000个梯度下降步骤，所以实际上一些位于中间的mini-batch大小效果最好。 使用batch梯度下降法时，每次迭代你都需要历遍整个训练集，可以预期每次迭代成本都会下降，所以如果成本函数是迭代次数的一个函数，它应该会随着每次迭代而减少，如果在某次迭代中增加了，那肯定出了问题，也许你的学习率太大。 在随机梯度下降法中，从某一点开始，我们重新选取一个起始点，每次迭代，你只对一个样本进行梯度下降，大部分时候你向着全局最小值靠近，有时候你会远离最小值，因为那个样本恰好给你指的方向不对，因此随机梯度下降法是有很多噪声的，平均来看，它最终会靠近最小值，不过有时候也会方向错误，因为随机梯度下降法永远不会收敛，而是会一直在最小值附近波动，但它并不会在达到最小值并停留在此。 用mini-batch梯度下降法，我们从这里开始，一次迭代这样做，两次，三次，四次，它不会总朝向最小值靠近，但它比随机梯度下降要更持续地靠近最小值的方向，它也不一定在很小的范围内收敛或者波动，如果出现这个问题，可以慢慢减少学习率，我们在下个视频会讲到学习率衰减，也就是如何减小学习率。 batch : too long,too time 随机： lose speeding ,噪声大 mini-batch和stochastic都存在噪声问题，且在local optima附近会徘徊。但设置合适大小的mini-batch size，噪声和徘徊问题可接受的范围内。 size=1,又叫随机梯度下降法 stochastic gradient descent how如何选择mini-batch size（这是一个hyperparameter）： 小数据量，比如总的样本只有几千个，完全可以直接用batch gradient descent 大数量，mini-batch size倾向于选择2^n个，比如64, 128, 256等 mini-batch 与CPU/GPU memory的内存容量。 In practice of course the mini batch size is another hyper parameter that you might do a quick search over to try to figure out which one is most sufficient of reducing the cost function j. 按照上面的方法 L 03: Exponentially Weighted AveragesIn order to understand those algorithms, you need to be able they use something called exponentially weighted averages. Also called exponentially weighted moving averages in statistics. 1. 指数加权平均数（Exponentially weighted averages） $\theta _i$表示每一日的温度值，蓝色的点，$v_t$表示加权平均后的,红色 权平均方法是：每天的温度值加权值$vt$设置为前一天的温度加权值$vt−1$和当天的温度实际值$θt$做加权平均： v_{t}=\beta v_{t-1}+(1-\beta) \theta_{t}由于以后我们要考虑的原因，在计算时可视$v_T$大概是$\frac{1}{(1-\beta)}$的每日温度的加权平均， 如果是$\beta$=0.9，这是十天的平均值，红色 如果$\beta$=0.98,是50天的结果，绿色 如果$beta$=0.5,是2day的结果，黄色 由于仅平均了两天的温度，平均的数据太少，所以得到的曲线有更多的噪声，有可能出现异常值，但是这个曲线能够更快适应温度变化。 当 $\beta$较大时，指数加权平均值适应地更缓慢一些。 $ L 04 : Understanding Exponentially Weighted Averages假如β=0.9，每个v的计算如下： \begin{aligned} v_{100} &=0.9 v_{99}+0.1 \theta_{100} \\ v_{99} &=0.9 v_{98}+0.1 \theta_{99} \\ v_{98} &=0.9 v_{97}+0.1 \theta_{98} \end{aligned}递推可得： v_{100}=0.1 \theta_{100}+0.1 * 0.9 \theta_{99}+0.1 *(0.9)^{2} \theta_{98}+\ldots指数的衰减规律 一般的 v_{t}=\sum_{i=1}^{t}(1-\beta) \beta^{t-i} \theta_{i}无穷级数求和： \sum_{t=1}^{n}(1-\beta) \beta^{t}=1因此可以近似的认为所有项的系数之和正好为100%。 即，$vt$是对t日之前所有的实际温度的加权平均,权重是指数递减的。 十天后，曲线高度下降到了1/3,赋予权重$\beta^{t-i}$ 0.9^{10}~=0.35~=1/e一般认为，$v_t$近似前$\frac{1}{1-\beta}$的加权平均值 L05 : Bias correction in exponentially weighted averages指数加权平均的偏差修正 由于计算$v1$的时候，并没有历史值做加权，这个时候令其前一个加权值$v0=0$，则会导致$v_1$远小于$\theta_1$,依次类推，在靠近前面的值会出现显著的小于实际值的情况 因此做一个修正 v_{t}=\frac{\beta v_{t-1}+(1-\beta) \theta_{t}}{1-\beta^{t}}你会发现随着$\beta^t$增加，接近于0，所以当t很大的时候，偏差修正几乎没有作用，因此当t较大的时候，紫线基本和绿线重合了。不过在开始学习阶段，你才开始预测热身练习，偏差修正可以帮助你更好预测温度，偏差修正可以帮助你使结果从紫线变成绿线。 因为在Machine Learning中看重的是很多次迭代后的结果，初期的偏差影响并不大。 L 06 : Gradient Descent With Momentum动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法， 当慢慢下降到最小值，上下波动的梯度下降法的速度减缓，无法使用更大的学习率， 在纵轴上，希望学校慢一点，不需要摆动，横着上，加快学校，基于此就有了Gradient descent with momentum。 \begin{array}{c}{v_{d W} :=\beta v_{d W}+(1-\beta) d W} \\ {v_{d b} :=\beta v_{d b}+(1-\beta) d b} \\ {w=w-\alpha v_{d W}} \\ {b=b-\alpha v_{d b}}\end{array}这样，可以让gradient更平滑 对于上图垂直方向，原来是会上下震荡，但引入了exponentially weighted average，相当于对前面的震荡进行了平均，结果就是上下震荡互相抵消了。而水平方向都是向右没有震荡，因此平均后还是向右。最终导致呈现上图红色的下降路线。 L 07 : RMSpropRMSprop (Root Mean Square Propagation，均方根传递)，与momentum一样，也是降低梯度的抖动。而是平抑不同大小梯度的更新速率。实际上 作用在α上的 回忆一下我们之前的例子，如果你执行梯度下降，虽然横轴方向正在推进，但纵轴方向会有大幅度摆动，为了分析这个例子，假设b纵轴代表参数，横轴代表参数W，可能有w1，或者w2其它重要的参数，为了便于理解，被称为b和w。 我们希望学习速度快，而在垂直方向，也就是例子中的方向，我们希望减缓纵轴上的摆动，所以有了$S_{d W} $和$ S_{d b}$，我们希望$S_{d W} $会相对较小，所以我们要除以一个较小的数，而希望$ S_{d b}$又较大，所以这里我们要除以较大的数字，这样就可以减缓纵轴上的变化。 这些微分，垂直方向的要比水平方向的大得多，所以斜率在方向特别大，所以这些微分中，db较大，dw较小，因为函数的倾斜程度，在纵轴上，也就是b方向上要大于在横轴上，也就是方向上W。db的平方较大，所以$Sdb$也会较大，而相比之下，dw会小一些，亦或dw平方会小一些，因此$Sdw$会小一些，结果就是纵轴上的更新要被一个较大的数相除，就能消除摆动，而水平方向的更新则被较小的数相除。 RMSprop的影响就是你的更新最后会变成这样（绿色线），纵轴方向上摆动较小，而横轴方向继续推进。还有个影响就是，你可以用一个更大学习率，然后加快学习，而无须在纵轴上垂直方向偏离。 实际中dw是一个高维度的参数向量，db也是一个高维度参数向量，但是你的直觉是，在你要消除摆动的维度中，最终你要计算一个更大的和值，这个平方和微分的加权平均值，所以你最后去掉了那些有摆动的方向。所以这就是RMSprop，全称是均方根，因为你将微分进行平方，然后最后使用平方根。 解释平方： 垂直方向，比较陡，梯度比较大，但我们又希望它下降的慢。因此对梯度除以一个较大的值，所以用梯度的平方的平均来表示。让不同的参数拥有不同的learning rate。 从某种角度看，RMSprop会根据当前的梯度自动调整参数的learning rate，梯度大降低learning rate，梯度小的时候提高learning rate，从而一方面避免了震荡，另一方面避免在平坦的地方徘徊太久。 为了避免出现分母为0 \begin{array}{c}{s_{d w}=\beta s_{d w}+(1-\beta)(d w)^{2}} \\ {s_{d b}=\beta s_{d b}+(1-\beta)(d b)^{2}} \\ {w :=w-\alpha \frac{d w}{\sqrt{s_{d w}+\varepsilon}}} \\ {b :=b-\alpha \frac{d b}{\sqrt{s_{d b}+\varepsilon}}}\end{array}$\varepsilon$取$10^{-8}$不错的选择. 补充： RMSProp算法对梯度计算了微分平方加权平均数。这种做法有利于消除了摆动幅度大的方向，用来修正摆动幅度，使得各个维度的摆动幅度都较小。另一方面也使得网络函数收敛更快 L 08 Adam optimization algorithmAdam（Adaptive Moment Estimation，自适应矩估计）就是momentum和RMSprop的结合。momentum负责平滑梯度，而RMSprop负责调解learning rate。 1. Adama. 引入的变量有： $v$ : 计算同momentum算法，将梯度进行指数加权平均 $s$: 计算同RMSprop，将梯度的平方进行指数加权平均 $β1$ : 计算vv的加权参数 $β2$ : 计算ss的加权参数 b. 在迭代前，初始化参数v和s v_{d W}=0, s_{d W}=0, v_{d b}=0, s_{d b}=0c. 对第t次梯度下降的迭代 a. 首先计算dw和db的v和s \begin{array}{c}{v_{d W}=\beta_{1} v_{d W}+\left(1-\beta_{1}\right) d W} \\ {s_{d W}=\beta_{2} s_{d W}+\left(1-\beta_{2}\right)(d W)^{2}} \\ {v_{d b}=\beta_{1} v_{d b}+\left(1-\beta_{1}\right) d b} \\ {s_{d b}=\beta_{2} s_{d b}+\left(1-\beta_{2}\right)(d b)^{2}}\end{array}d. 修正 v_{d W}^{\text {corrected}}=\frac{v_{d W}}{1-\left(\beta_{1}\right)^{t}}\\ \begin{aligned} s_{d W}^{\text {corrected}} &=\frac{s_{d W}}{1-\left(\beta_{2}\right)^{t}} \\ v_{d b}^{\text {corrected}} &=\frac{v_{d b}}{1-\left(\beta_{1}\right)^{t}} \\ s_{d b}^{\text {corrected}} &=\frac{s_{d b}}{1-\left(\beta_{2}\right)^{t}} \end{aligned}e. 最后更新参数W和b W=W-\alpha \frac{v_{d W}^{\text {corrected}}}{\sqrt{s_{d W}^{\text { corrected }}+\varepsilon}}\\ b=b-\alpha \frac{v_{d b}^{\text {corrected}}}{\sqrt{s_{d b}^{\text { corrected }}+\varepsilon}}超参的选择： α：需要调优 β1: 通常选择为0.9 β2: 通常选择为0.999 ε: 一般不需要调优，选择一个小数，比如10−8 你可以尝试一系列值α，然后看哪个有效 L09 : Learning Rate Decay why 为什么要做learning rate decay？ 较大的learning rate虽然在算法开始阶段会加快收敛速度，但在收敛接近到优化点的时候，算法会在优化点附近震荡，如下图： 2.如何做learning rate decay？ 思路很简单，就是引入一个函数，让α随着迭代（比如min-batch的epoch）递减。为此可以采用的decay函数有： 倒数： \alpha :=\frac{1}{1+\text { decay rate * epoch num}} \alpha L 10: The Problem of local Optima事实上，如果你要创建一个神经网络，通常梯度为零的点并不是这个图中的局部最优点，实际上成本函数的零梯度点，通常是鞍点。 但是一个具有高维度空间的函数，如果梯度为0，那么在每个方向，它可能是凸函数，也可能是凹函数。如果你在2万维空间中，那么想要得到局部最优，所有的2万个方向都需要是这样，但发生的机率也许很小，也许是$2^{-20000}$，因此更有可能遇到有些方向的曲线会这样向上弯曲，另一些方向曲线向下弯，而不是所有的都向上弯曲，因此在高维度空间，你更可能碰到鞍点。所有，担心收敛到local optima，真是人们想多了，实际上并没有想象的那么多local optima。在高维空间，几乎不太可能被困在一个local optima，这是一个好消息。 因此，在高维空间遇到的问题是高原问题（Problem of plateaus） Adam算法可以加速学习 W3 Hyperparameter tuningL01 Tuning process 到目前为止，我们接触到的hyperparameter有： learning rate: αα momentum 参数: ββ Adam参数: β1β1和 β2β2以及εε 神经网络层数: L 神经网络隐藏层neuron数：n[l]n[l] learning rate decay参数 min-batch size 这些hyperparameter重要性排序： 最重要的： learning rate: αα 比较重要的： momentum 参数: ββ 神经网络层数: L 神经网络隐藏层neuron数：n[l]n[l] 次重要的： 神经网络隐藏层neuron数 learning rate decay参数 基本不需调整的 β1β1和 β2β2以及ε 1. Try random values : Don’t use a grid why: 举个例子，假设超参数1是（学习速率），取一个极端的例子，假设超参数2是Adam算法中，分母中的$\varepsilon$。在这种情况下，a的取值很重要，而$\varepsilon$取值则无关紧要。如果你在网格中取点，接着，你试验了a的5个取值，那你会发现，无论$\varepsilon$取何值，结果基本上都是一样的。所以，你知道共有25种模型，但进行试验的值只有5个，我认为这是很重要的。 对比而言，如果你随机取值，你会试验25个独立的a,$\varepsilon$，似乎你更有可能发现效果做好的那个。 2. 由粗糙到精细的策略 L 02: Using an Appropriate Scale to pick hyperparameters$a$取值0.0001,1,如果你画一条从0.0001到1的数轴，沿其随机均匀取值，那90%的数值将会落在0.1到1之间，结果就是，在0.1到1之间，应用了90%的资源，而在0.0001到0.1之间，只有10%的搜索资源，这看上去不太对。 同时在范围内搜索，也不是均匀分布（uniformly random）的，通常有这个参数的scale，比如对数scale。 反而，用对数标尺搜索超参数的方式会更合理，因此这里不使用线性轴，分别依次取0.0001，0.001，0.01，0.1，1，在对数轴上均匀随机取点，这样，在0.0001到0.001之间，就会有更多的搜索资源可用，还有在0.001到0.01之间等等。 L 03 : Hyperparameter tuning i practice 不同的算法和场景，对超参的scale敏感性可能不一样. 根据计算资源和数据量，可以采取两种策略来调参 Panda（熊猫策略）：对一个模型先后修改参数，查看其表现，最终选择最好的参数。就像熊猫一样，一次只抚养一个后代。 Caviar（鱼子酱策略）：计算资源足够，可以同时运行很多模型实例，采用不同的参数，然后最终选择一个好的。类似鱼类，一次下很多卵，自动竞争成活。 L 04: Normalizing Activations in a Network1. Implementing Batch NormalizingBatch归一化,Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更加庞大，工作效果也很好，也会是你的训练更加容易，甚至是深层网络。 可以normalize $a^{[l]},z^{[l]}$,选择$z^{[L]}$ 设置 γ 和 β 的原因是，如果各隐藏层的输入均值在靠近 0 的区域，即处于激活函数的线性区域，不利于训练非线性神经网络，从而得到效果较差的模型。因此，需要用 γ 和 β 对标准化后的结果做进一步处理。 需要注意的是，β和γ不是超参，而是梯度下降需学习的参数。 L 05 : Fitting Batch Norm Into Neural Networks 注意 先前我说过每层的参数是$w^{[l]}$和$b^{[l]}$，还有$\beta^{[l]}$和$b^{[l]}$，请注意计算的方式如下，$z^{[l]}=w^{[l]} a^{[l-1]}+b^{[l]}$，但Batch归一化做的是，它要看这个mini-batch，先将$z^{[l]}$归一化，结果为均值0和标准方差，再由$\beta$和b重缩放，但这意味着，无论$b^{[l]}$的值是多少，都是要被减去的，因为在Batch归一化的过程中，你要计算的$z^{[l]}$均值，再减去平均值，在此例中的mini-batch中增加任何常数，数值都不会改变，因为加上的任何常数都将会被均值减去所抵消. 最后，请记住的维$z^{[l]}$，因为在这个例子中，维数会是$\left(n^{[l]}, 1\right)$，的尺寸为，如果是l层隐藏单元的数量，那$ \beta^{[l]}$和$ \gamma^{[l]}$的维度也是$\left(n^{[l]}, 1\right)$，因为这是你隐藏层的数量，你有隐藏单元，所以$\gamma^{[l]}$和$ \beta^{[l]}$用来将每个隐藏层的均值和方差缩放为网络想要的值。 L 06 Why Doest Batch Norm Work? 首先，起到了normalization的作用，同对输入数据X的normalization作用类似。 让每一层的学习，一定程度解耦了前层参数和后层参数，让各层更加独立的学习。无论前一层如何变，本层输入的数据总是保持稳定的均值和方差。（主要原因） 所以使你数据改变分布的这个想法，有个有点怪的名字“Covariate shift”，想法是这样的，如果你已经学习了到 的映射，如果 的分布改变了，那么你可能需要重新训练你的学习算法。这种做法同样适用于，如果真实函数由 到 映射保持不变，正如此例中，因为真实函数是此图片是否是一只猫，训练你的函数的需要变得更加迫切，如果真实函数也改变，情况就更糟了。 关于第二点，如果实际应用样本和训练样本的数据分布不同（例如，橘猫图片和黑猫图片），我们称发生了“Covariate Shift”。这种情况下，一般要对模型进行重新训练。Batch Normalization 的作用就是减小 Covariate Shift 所带来的影响，让模型变得更加健壮，鲁棒性（Robustness）更强。 即使输入的值改变了，由于 Batch Normalization 的作用，使得均值和方差保持不变（由 γ 和 β 决定），限制了在前层的参数更新对数值分布的影响程度，因此后层的学习变得更容易一些。Batch Normalization 减少了各层 W 和 b 之间的耦合性，让各层更加独立，实现自我训练学习的效果。 另外，Batch Normalization 也起到微弱的正则化（regularization）效果。因为在每个 mini-batch 而非整个数据集上计算均值和方差，只由这一小部分数据估计得出的均值和方差会有一些噪声，因此最终计算出的 z~(i)z~(i)也有一定噪声。类似于 dropout，这种噪声会使得神经元不会再特别依赖于任何一个输入特征。 因为 Batch Normalization 只有微弱的正则化效果，因此可以和 dropout 一起使用，以获得更强大的正则化效果。通过应用更大的 mini-batch 大小，可以减少噪声，从而减少这种正则化效果。 最后，不要将 Batch Normalization 作为正则化的手段，而是当作加速学习的方式。正则化只是一种非期望的副作用，Batch Normalization 解决的还是反向传播过程中的梯度问题（梯度消失和爆炸）。 L 07 : Batch Norm At Test Time问题：BN算法在训练时是一个批次的数据训练，能算出每一层Z的均值和方差；而在测试时，输入的则是单个数据，单条数据没法做均值和方差的计算，怎么在测试期输入均值和方差呢? 实际应用中一般不使用这种方法，而是使用之前学习过的指数加权平均的方法来预测测试过程单个样本的 μ 和 $σ^2$ 计算$z_{\text { norm }}^{(\hat{2})}$，用$\mu$ 和$ \sigma^{2}$的指数加权平均，用你手头的最新数值来做调整，然后你可以用左边我们刚算出来的和你在神经网络训练过程中得到的$\beta$和$\sigma$参数来计算你那个测试样本的z值。 L 08 : Softmax Regression1. [Multi-class classification] 最后一层是概率，之和为1，要用到Softmax层，Softmax激活函数的特殊之处在于，因为需要将所有可能的输出归一化，就需要输入一个向量，最后输出一个向量。 2. Softmax example没有隐藏层的softmax,代表一些决策边界 L 09 Training SoftMax classifier Softmax这个名称的来源是与所谓hardmax对比,Softmax回归或Softmax激活函数将logistic激活函数推广到类，而不仅仅是两类，结果就是如果C=2，那么C=2的Softmax实际上变回了logistic回归， Loss Function J\left(w^{[1]}, b^{[1]}, \ldots \ldots\right)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right) 3. Gradient descent with softmax 最后一层求导，softmax激活函数 J\left(w^{[1]}, b^{[1]}, \ldots \ldots\right)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)L11 TensorFlow1. 基本流程使用tensorflow，只要告诉tensorflow forward prop，它自己就会做backprop，因此不用自己实现backprop 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npimport tensorflow as tf#导入TensorFlow​w = tf.Variable(0,dtype = tf.float32)#接下来，让我们定义参数w，在TensorFlow中，你要用tf.Variable()来定义参数​#然后我们定义损失函数：​cost = tf.add(tf.add(w**2,tf.multiply(- 10.,w)),25)#然后我们定义损失函数J然后我们再写：​train = tf.train.GradientDescentOptimizer(0.01).minimize(cost)#(让我们用0.01的学习率，目标是最小化损失)。​#最后下面的几行是惯用表达式:​init = tf.global_variables_initializer()​session = tf.Session()#这样就开启了一个TensorFlow session。​session.run(init)#来初始化全局变量。​#然后让TensorFlow评估一个变量，我们要用到:​session.run(w)​#上面的这一行将w初始化为0，并定义损失函数，我们定义train为学习算法，它用梯度下降法优化器使损失函数最小化，但实际上我们还没有运行学习算法，所以#上面的这一行将w初始化为0，并定义损失函数，我们定义train为学习算法，它用梯度下降法优化器使损失函数最小化，但实际上我们还没有运行学习算法，所以session.run(w)评估了w，让我：：​print(session.run(w))​所以如果我们运行这个，它评估等于0，因为我们什么都还没运行。#现在让我们输入：​$session.run(train)，它所做的就是运行一步梯度下降法。#接下来在运行了一步梯度下降法后，让我们评估一下w的值，再print：​print(session.run(w))#在一步梯度下降法之后，w现在是0.1。 2. 如何用训练数据placeholder 在实际的训练过程中，要用不同的样本反复放到一个待优化函数中的，这个时候就可以用tensorflow的placeholder实现,在run的时候，对应给出feed_dict，表名占位符x的实际值。 123456789101112131415161718192021import numpy as npimport tensorflow as tf # 导入Tensorflowcoefficient = np.array([[2.],[-10.],[25.]])w = tf.Variable(0, dtype=tf.float32)x = tf.placeholder(tf.float32, [3,1]) # 3x1大小的placeholdercost = w**x[0][0] - x[1][0]*w + x[2][0] # 要优化的cost function（即forward prop的形式）train = tf.train.GradientDescentOptimizer(0.01).minimize(cost) init = tf.global_variables_initializer()session = tf.Session()session.run(init)print(session.run(w))session.run(train, feed_dict=&#123;x:coefficient&#125;) # x占位符替换为coefficientprint(session.run(w))for i in range(1000): session.run(train, feed_dict=&#123;x:coefficient&#125;) # # x占位符替换为coefficientprint(session.run(w)) 3. 计算流TensorFlow程序的核心是计算损失函数，然后TensorFlow自动计算出导数，以及如何最小化损失，因此这个等式或者这行代码所做的就是让TensorFlow建立计算图， with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。建立计算流的过程，前向传播的过程，operation Summaryhow to systematically organize the hyper parameter search process and batch normalization and framework http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Improving_Deep_Neural_Networks/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2 http://www.ai-start.com/dl2017/html/lesson2-week1.html#header-n3 http://dl-notes.imshuai.com/#/c2w1?id=_4-heros-of-deep-learning-yoshua-bengio-interview https://www.youtube.com/watch?v=4Ct3Yujl1dk&amp;list=PLkDaE6sCZn6Hn0vK8co82zjQtt3T2Nkqc&amp;index=14]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩铅DailyLifeStyle]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BD%A9%E9%93%85DailyLifeStyle%2F</url>
    <content type="text"><![CDATA[Day one1. 工具简单介绍 彩铅 水溶性，油性 彩铅纸 铅笔 B 2B&lt;4B黑的程度 H 4H&lt;8H软度 橡皮 软橡皮 硬橡皮 电动橡皮擦 铅笔刀 可跳档类型 勾线笔 针管笔 （樱花） 笔套 高光笔 可以用修正液替换（三棱) 纸擦笔 玛丽 刷子 画板 速写板 2. 颜色三原色： 红 黄 蓝 色相 颜色 饱和度 鲜艳程度 明度 明暗程度 邻近色 对比色 红-绿 蓝-橙 紫-黄 暖色和冷色 3. 排线 一个方向 往同一个方向排，无连接 来回 相连接，一条线 不同方向排列 注意：力度和间距 4. 平涂力度一致 5. 渐变力度不一致]]></content>
      <categories>
        <category>娱乐生活</category>
      </categories>
      <tags>
        <tag>彩铅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F04%2F13%2Fmachine%20learning%20test%2F</url>
    <content type="text"><![CDATA[Logistics Regression 如何凸显你是一个对逻辑回归已经非常了解的人呢。那就是用一句话概括它！逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。 ​ 这里面其实包含了5个点 1：逻辑回归的假设，2：逻辑回归的损失函数，3：逻辑回归的求解方法，4：逻辑回归的目的，5:逻辑回归如何分类。这些问题是考核你对逻辑回归的基本了解。 逻辑回归的基本假设 任何的模型都是有自己的假设，在这个假设下模型才是适用的。逻辑回归的 第一个 基本假设是 假设数据服从伯努利分布。 伯努利分布有一个简单的例子是抛硬币，抛中为正面的概率是p,抛中为负面的概率是 1-p,在逻辑回归这个模型里面是假设 $h_θ(x)$为样本为正的概率， $1−h_θ(x)$为样本为负的概率。那么整个模型可以描述为$h_θ(x;θ)=p$ 逻辑回归的第二个假设是假设样本为正的概率是 $p=\frac{1}{1+e^{w^Tx}}$ 所以逻辑回归的最终形式 $h_θ(x;θ)=\frac{1}{1+e^{w^Tx}}$ 逻辑回归的损失函数 逻辑回归的损失函数是它的极大似然函数 $Lθ(x)=\pi_{i=1}^{m}h_θ(xi;θ)^y_i∗(1−h_θ(xi;θ))^{1−y_i}$ 逻辑回归的求解方法 由于该极大似然函数无法直接求解，我们一般通过对该函数进行梯度下降来不断逼急最优解。在这个地方其实会有个加分的项，考察你对其他优化方法的了解。因为就梯度下降本身来看的话就有随机梯度下降，批梯度下降，small batch 梯度下降三种方式，面试官可能会问这三种方式的优劣以及如何选择最合适的梯度下降方式。 简单来说 批梯度下降会获得全局最优解，缺点是在更新每个参数的时候需要遍历所有的数据，计算量会很大，并且会有很多的冗余计算，导致的结果是当数据量大的时候，每个参数的更新都会很慢。 随机梯度下降是以高方差频繁更新，优点是使得sgd会跳到新的和潜在更好的局部最优解，缺点是使得收敛到局部最优解的过程更加的复杂。 小批量梯度下降结合了sgd和batch gd的优点，每次更新的时候使用n个样本。减少了参数更新的次数，可以达到更加稳定收敛结果，一般在深度学习当中我们采用这种方法。 其实这里还有一个隐藏的更加深的加分项，看你了不了解诸如Adam，动量法等优化方法。因为上述方法其实还有两个致命的问题。 第一个是如何对模型选择合适的学习率。自始至终保持同样的学习率其实不太合适。因为一开始参数刚刚开始学习的时候，此时的参数和最优解隔的比较远，需要保持一个较大的学习率尽快逼近最优解。但是学习到后面的时候，参数和最优解已经隔的比较近了，你还保持最初的学习率，容易越过最优点，在最优点附近来回振荡，通俗一点说，就很容易学过头了，跑偏了。 第二个是如何对参数选择合适的学习率。在实践中，对每个参数都保持的同样的学习率也是很不合理的。有些参数更新频繁，那么学习率可以适当小一点。有些参数更新缓慢，那么学习率就应该大一点。这里我们不展开，有空我会专门出一个专题介绍。 逻辑回归的目的 该函数的目的便是将数据二分类，提高准确率。 逻辑回归如何分类 逻辑回归作为一个回归(也就是y值是连续的)，如何应用到分类上去呢。y值确实是一个连续的变量。逻辑回归的做法是划定一个阈值，y值大于这个阈值的是一类，y值小于这个阈值的是另外一类。阈值具体如何调整根据实际情况选择。一般会选择0.5做为阈值来划分。 3.对逻辑回归的进一步提问​ 逻辑回归虽然从形式上非常的简单，但是其内涵是非常的丰富。有很多问题是可以进行思考的 逻辑回归的损失函数为什么要使用极大似然函数作为损失函数？ 损失函数一般有四种，平方损失函数，对数损失函数，HingeLoss0-1损失函数，绝对值损失函数。将极大似然函数取对数以后等同于对数损失函数。在逻辑回归这个模型下，对数损失函数的训练求解参数的速度是比较快的。至于原因大家可以求出这个式子的梯度更新 $w_j=w_j−(y^i−h_w(x^i;w))∗x_j^i\theta$ 这个式子的更新速度只和$x_j,y_j 相关。和sigmod函数本身的梯度是无关的。这样更新的速度是可以自始至终都比较的稳定。 为什么不选平方损失函数的呢？其一是因为如果你使用平方损失函数，你会发现梯度更新的速度和sigmod函数本身的梯度是很相关的。sigmod函数在它在定义域内的梯度都不大于0.25。这样训练会非常的慢。 逻辑回归在训练的过程当中，如果有很多的特征高度相关或者说有一个特征重复了100遍，会造成怎样的影响？ 先说结论，如果在损失函数最终收敛的情况下，其实就算有很多特征高度相关也不会影响分类器的效果。 但是对特征本身来说的话，假设只有一个特征，在不考虑采样的情况下，你现在将它重复100遍。训练以后完以后，数据还是这么多，但是这个特征本身重复了100遍，实质上将原来的特征分成了100份，每一个特征都是原来特征权重值的百分之一。 如果在随机采样的情况下，其实训练收敛完以后，还是可以认为这100个特征和原来那一个特征扮演的效果一样，只是可能中间很多特征的值正负相消了。 为什么我们还是会在训练的过程当中将高度相关的特征去掉？ 去掉高度相关的特征会让模型的可解释性更好 可以大大提高训练的速度。如果模型当中有很多特征高度相关的话，就算损失函数本身收敛了，但实际上参数是没有收敛的，这样会拉低训练的速度。其次是特征多了，本身就会增大训练的时间。 4.逻辑回归的优缺点总结​ 面试的时候，别人也经常会问到，你在使用逻辑回归的时候有哪些感受。觉得它有哪些优缺点。 ​ 在这里我们总结了逻辑回归应用到工业界当中一些优点： 形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，某个特征的权重值比较高，那么这个特征最后对结果的影响会比较大。 模型效果不错。在工程上是可以接受的（作为baseline)，如果特征工程做的好，效果不会太差，并且特征工程可以大家并行开发，大大加快开发的速度。 训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。并且逻辑回归的分布式优化sgd发展比较成熟，训练的速度可以通过堆机器进一步提高，这样我们可以在短时间内迭代好几个版本的模型。 资源占用小,尤其是内存。因为只需要存储各个维度的特征值，。 方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值(大于某个阈值的是一类，小于某个阈值的是一类)。 ​ 但是逻辑回归本身也有许多的缺点: 准确率并不是很高。因为形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布。 很难处理数据不平衡的问题。举个例子：如果我们对于一个正负样本非常不平衡的问题比如正负样本比 10000:1.我们把所有样本都预测为正也能使损失函数的值比较小。但是作为一个分类器，它对正负样本的区分能力不会很好。 处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，或者进一步说，处理二分类的问题 。 逻辑回归本身无法筛选特征。有时候，我们会用gbdt来筛选特征，然后再上逻辑回归。 模型、策略、算法Codings]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F04%2F13%2Fmachine%20learning%2F</url>
    <content type="text"><![CDATA[英伟达:芯片，GPU 开发框架：tensorflow，pytorch caffe 监督学习学习目的是学习一个输入到输出的映射，称为模型。模型的集合就是假设空间。 模型：概率模型；非概率模型； 学习过程：搜索过程]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow]]></title>
    <url>%2F2019%2F04%2F11%2Ftensorflow%2F</url>
    <content type="text"><![CDATA[official definition What is tensorflowflow of tensors “TensorFlow is an open source software library for numerical computation using dataflow graphs. Nodes in the graph represents mathematical operations, while graph edges represent multi-dimensional data arrays (aka tensors) communicated between them. The flexible architecture allows you to deploy computation to one or more CPUs or GPUs in a desktop, server, or mobile device with a single API.”* A major difference between numpy and TensorFlow is that TensorFlow follows a lazy programming paradigm. It first builds a graph of all the operation to be done, and then when a “session” is called, it “runs” the graph. It’s built to be scalable, by changing internal data representation to tensors (aka multi-dimensional arrays). Building a computational graph can be considered as the main ingredient of TensorFlow. It’s easy to classify TensorFlow as a neural network library, but it’s not just that. Yes, it was designed to be a powerful neural network library. But it has the power to do much more than that. You can build other machine learning algorithms on it such as decision trees or k-Nearest Neighbors. You can literally do everything you normally would do in numpy! It’s aptly called “numpy on steroids” The advantages of using TensorFlow are: It has an intuitive construct, because as the name suggests it has “flow of tensors”. You can easily visualize each and every part of the graph. Easily train on cpu/gpu for distributed computing Platform flexibility. You can run the models wherever you want, whether it is on mobile, server or PC. scikit-learn 123456# define hyperparamters of ML algorithmclf = svm.SVC(gamma=0.001, C=100.)# train clf.fit(X, y)# test clf.predict(X_test) The usual workflow of running a program in TensorFlow is as follows: Build a computational graph, this can be any mathematical operation TensorFlow supports. Initialize variables, to compile the variables defined previously Create session(会话）, this is where the magic starts! Run graph in session, the compiled graph is passed to the session, which starts its execution. Close session, shutdown the session. Lets write a small program to add two numbers! 12345678910111213141516171819# import tensorflowimport tensorflow as tf# build computational grapha = tf.placeholder(tf.int16)b = tf.placeholder(tf.int16)addition = tf.add(a, b)# initialize variablesinit = tf.initialize_all_variables()# create session and run the graphwith tf.Session() as sess: sess.run(init) print "Addition: %i" % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)# close sessionsess.close() A typical implementation of Neural Network would be as follows: Define Neural Network architecture to be compiled Transfer data to your model Under the hood, the data is first divided into batches, so that it can be ingested. The batches are first preprocessed, augmented and then fed into Neural Network for training The model then gets trained incrementally Display the accuracy for a specific number of timesteps After training save the model for future use Test the model on a new data and check how it performs 三类非常重要的变量占位符tensorFlow中接收值的方式为占位符(placeholder)，创建placeholder 123- # b = tf.placeholder(tf.float32, [None, 1], name='b')第二个参数值为[None, 1]，其中None表示不确定，即不确定第一个维度的大小，第一维可以是任意大小。特别对应tensor数量(或者样本数量)，输入的tensor数目可以是32、64… placeholder: A way to feed data into the graphsfeed_dict: A dictionary to pass numeric values to computational graph 常量tf.constant()`定义常量 1const = tf.constant(2.0, name='const') 变量 ​ 使用tf.Variable()定义变量 1c = tf.Variable(1.0, dtype=tf.float32, name='c') TensorFlow中所有的变量必须经过初始化才能使用，**初始化方式分两步： 定义初始化operation 12# 1. 定义init operationinit_op = tf.global_variables_initializer() 运行初始化operation 12# 2. 运行init operation sess.run(init_op) reference https://jacobbuckman.com/post/tensorflow-the-confusing-parts-1/ https://www.toptal.com/machine-learning/tensorflow-machine-learning-tutorial https://github.com/aymericdamien/TensorFlow-Examples video:https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/ course: https://classroom.udacity.com/courses/ud187 tensorflow: GOOGLE 开源、Deep learning 练数成金C1 tensorboard ：a tool;visual network;debug alter dir of jupyter 顺便改了下新下载的路径（GOOD） CPU or GPU C2graphs 代表计算任务，节点（op)，一个op可以获得o个或者多个tensor,输出1个或者多个tensor Session(会话)的上下文（context)中执行 tensor表示数据,n维数组 C3 简单的回归神经网络（拟合二次函数），貌似学了理论没有实践，还真是忘得快啊 手写体分类、Softmax函数 softmax函数可以给不同的对象分配概率，softmax($x_i$)=$\frac{exp(x_i)}{\sum_j{exp(x_j)}}$ 如输出[1,2,5] ,$p1=\frac{exp(1)}{exp(1)+exp(2)+exp(5)}$,$p2=\frac{exp(2)}{exp(1)+exp(2)+exp(5)}$,$p1=\frac{exp(5)}{exp(1)+exp(2)+exp(5)}$ Keras 安装 backend 基于什么做运算（tensorflow or theano) import keras 查看 底层搭建 a） /.keras/keras.json 相关的配置信息 b) 终端改，单次 import os os.environ[‘KERAS_BACKEND’]= ‘tensorflow’ import keras For example model :Sequential layer : Dense activation 训练算法：model.compile(参数optimizer=’梯度下降法的变种’ , loss=’rms/‘) 训练：model. fit (x,y) model.train_on_batch evaluate:model.evaluate prediction: model.predict(x_test, batch_size=128) https://github.com/MorvanZhou/tutorials/blob/master/kerasTUT/5-classifier_example.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 4 - Regressor exampleimport numpy as npnp.random.seed(1337) # for reproducibilityfrom keras.models import Sequential # 按顺序建立from keras.layers import Dense # 全连接层import matplotlib.pyplot as plt# create some dataX = np.linspace(-1, 1, 200)np.random.shuffle(X) # randomize the dataY = 0.5 * X + 2 + np.random.normal(0, 0.05, (200, ))# plot dataplt.scatter(X, Y)plt.show()X_train, Y_train = X[:160], Y[:160] # first 160 data pointsX_test, Y_test = X[160:], Y[160:] # last 40 data points# build a neural network from the 1st layer to the last layermodel = Sequential()model.add(Dense(units=1, input_dim=1)) # choose loss function and optimizing methodmodel.compile(loss='mse', optimizer='sgd')# trainingprint('Training -----------')for step in range(301): cost = model.train_on_batch(X_train, Y_train) if step % 100 == 0: print('train cost: ', cost)# testprint('\nTesting ------------')cost = model.evaluate(X_test, Y_test, batch_size=40)print('test cost:', cost)W, b = model.layers[0].get_weights()print('Weights=', W, '\nbiases=', b)# plotting the predictionY_pred = model.predict(X_test)plt.scatter(X_test, Y_test)plt.plot(X_test, Y_pred)plt.show() 51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556"""To know more or get code samples, please visit my website:https://morvanzhou.github.io/tutorials/Or search: 莫烦PythonThank you for supporting!"""# please note, all tutorial code are running under python3.5.# If you use the version like python2.7, please modify the code accordingly# 5 - Classifier exampleimport numpy as npnp.random.seed(1337) # for reproducibilityfrom keras.datasets import mnistfrom keras.utils import np_utilsfrom keras.models import Sequentialfrom keras.layers import Dense, Activationfrom keras.optimizers import RMSprop# download the mnist to the path '~/.keras/datasets/' if it is the first time to be called# X shape (60,000 28x28), y shape (10,000, )(X_train, y_train), (X_test, y_test) = mnist.load_data()# data pre-processingX_train = X_train.reshape(X_train.shape[0], -1) / 255. # normalizeX_test = X_test.reshape(X_test.shape[0], -1) / 255. # normalizey_train = np_utils.to_categorical(y_train, num_classes=10)y_test = np_utils.to_categorical(y_test, num_classes=10)# Another way to build your neural netmodel = Sequential([ Dense(32, input_dim=784), Activation('relu'), Dense(10), Activation('softmax'),])# Another way to define your optimizerrmsprop = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)# We add metrics to get more results you want to seemodel.compile(optimizer=rmsprop, loss='categorical_crossentropy', metrics=['accuracy'])print('Training ------------')# Another way to train the modelmodel.fit(X_train, y_train, epochs=2, batch_size=32)print('\nTesting ------------')# Evaluate the model with the metrics we defined earlierloss, accuracy = model.evaluate(X_test, y_test)print('test loss: ', loss)print('test accuracy: ', accuracy) 6 CNN卷积神经网络不是对 https://www.cnblogs.com/skyfsm/p/6790245.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990"""To know more or get code samples, please visit my website:https://morvanzhou.github.io/tutorials/Or search: 莫烦PythonThank you for supporting!"""# please note, all tutorial code are running under python3.5.# If you use the version like python2.7, please modify the code accordingly# 6 - CNN example# to try tensorflow, un-comment following two lines# import os# os.environ['KERAS_BACKEND']='tensorflow'import numpy as npnp.random.seed(1337) # for reproducibilityfrom keras.datasets import mnistfrom keras.utils import np_utilsfrom keras.models import Sequentialfrom keras.layers import Dense, Activation, Convolution2D, MaxPooling2D, Flattenfrom keras.optimizers import Adam# download the mnist to the path '~/.keras/datasets/' if it is the first time to be called# training X shape (60000, 28x28), Y shape (60000, ). test X shape (10000, 28x28), Y shape (10000, )(X_train, y_train), (X_test, y_test) = mnist.load_data()# data pre-processingX_train = X_train.reshape(-1, 1,28, 28)/255.X_test = X_test.reshape(-1, 1,28, 28)/255.y_train = np_utils.to_categorical(y_train, num_classes=10)y_test = np_utils.to_categorical(y_test, num_classes=10)# Another way to build your CNNmodel = Sequential()# Conv layer 1 output shape (32, 28, 28)model.add(Convolution2D( batch_input_shape=(None, 1, 28, 28), filters=32, kernel_size=5, strides=1, padding='same', # Padding method data_format='channels_first',))model.add(Activation('relu'))# Pooling layer 1 (max pooling) output shape (32, 14, 14)model.add(MaxPooling2D( pool_size=2, strides=2, padding='same', # Padding method data_format='channels_first',))# Conv layer 2 output shape (64, 14, 14)model.add(Convolution2D(64, 5, strides=1, padding='same', data_format='channels_first'))model.add(Activation('relu'))# Pooling layer 2 (max pooling) output shape (64, 7, 7)model.add(MaxPooling2D(2, 2, 'same', data_format='channels_first'))# Fully connected layer 1 input shape (64 * 7 * 7) = (3136), output shape (1024)model.add(Flatten())model.add(Dense(1024))model.add(Activation('relu'))# Fully connected layer 2 to shape (10) for 10 classesmodel.add(Dense(10))model.add(Activation('softmax'))# Another way to define your optimizeradam = Adam(lr=1e-4)# We add metrics to get more results you want to seemodel.compile(optimizer=adam, loss='categorical_crossentropy', metrics=['accuracy'])print('Training ------------')# Another way to train the modelmodel.fit(X_train, y_train, epochs=1, batch_size=64,)print('\nTesting ------------')# Evaluate the model with the metrics we defined earlierloss, accuracy = model.evaluate(X_test, y_test)print('\ntest loss: ', loss)print('\ntest accuracy: ', accuracy)]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tensorlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep Learning Neural Network and Deep Learning]]></title>
    <url>%2F2019%2F04%2F11%2FDeep%20Learning.ai_Neural%20Networks%20and%20Deep%20Learning%2F</url>
    <content type="text"><![CDATA[Course one : Neural Networks and Deep Learning(Course 1 of the Deep Learning Specialization)C1W1C1W1L01: WelcomeAI is the new Electricity! Course 1: Neural Networks and Deep Learning Course 2: Improving Deep Neural Networks: Hyperparameter tuning,Regularization and Optimization Course 3: Structuring your Machine Learning project Course 4: Convolutional Neural Networks Course 5: Natural Langurge Processing: Building sequence models C1W1L02 : What is Neural NetworkDeep Learning = training (very large) neural network For example of house prize prediction : the simplest neural network如果现在有六栋房子的信息，分别是房子的大小(size of house)和对应的价格(prize),绘制出如下的。自然的想法：线性回归，得到拟合的直线。值得注意的是，房价不可能是负数吧！因此下图中蓝色的线，大致就是我们所需要的函数。这个对应一个最简单神经网络（neural network） 上述是一个tiny little neural network，更大的，更复杂的神经网络是 把很多最简单的single neural堆积(stacking)到一起。 For example of house prize prediction : stacking the neural上面这个例子，仅仅考虑特征是size,实际情况上，与房屋相关的特征还有number of bedrooms、zip code、wealth, number of bedrooms and size affect family size. The zip code is a feature that tells you you know walkability. The wealth tells you how good is the school quality hidden layer 用输入层计算得到，因此说输入层与中间层紧密连接起来了 The actual application of neural networkshidden layer 与上一层的连接情况并不是手工确定，每一层都是上一层所有的输入函数，所以建立的神经网络如下： The remarkable thing about neural network Given enough data about X&amp;Y (x,y) which good at freaking out functions :map x to y Most powerful in supervised learning C2W1CL03 : Supervised Learning with Neural Network常见的监督学习截止到目前，Neural Network的成功应用基本都在Supervised Learning。比如：Ad，Images vision, Audio to Text, Machine translation, Autonomous Driving 常见的神经网络的设计 卷积神经网络：Convolutional Neural Network (CNN) 通常有用图像数据 递归神经网络： Recurrent Neural Network (RNN) 通常用于time series 对应复杂的应用中，定制一些复杂的混合的神经网络结构 结构化和非结构化数据 处理非结构化数据是很难的，与结构化数据比较，让计算机理解非结构化数据很难 C1W1L04: Why is deep learning taking offAnswer: scale If you want to hit this very high level of performance ,firstly, you need to be able train a big enough neural network in order to take advantage of the huge amount of data and second you need to be out here on the x axes you do need a lot of data. If you do not have a lot training data is often up to your skill at hand engineering features that determines the foreman.在这个小的训练集中，各种算法的优先级事实上定义的也不是很明确，所以如果你没有大量的训练集，那效果会取决于你的特征工程能力，那将决定最终的性能。 这个图形区域的左边，各种算法之间的优先级并不是定义的很明确，最终的性能更多的是取决于你在用工程选择特征方面的能力以及算法处理方面的一些细节. 只是在某些大数据规模非常庞大的训练集，也就是在右边这个会非常的大时，我们能更加持续地看到更大的由神经网络控制其它方法. The Reason the scale of data the speed of computation such as GPUS innovation of algorithm 许多算法方面的创新，一直是在尝试着使得神经网络运行的更快 switch sigmoid function to relu function 在这个区域，也就是这个sigmoid函数的梯度会接近零，所以学习的速度会变得非常缓慢，因为当你实现梯度下降以及梯度接近零的时候，参数会更新的很慢，所以学习的速率也会变的很慢，而通过改变这个被叫做激活函数的东西，神经网络换用这一个函数，叫做ReLU的函数（修正线性单元），ReLU它的梯度对于所有输入的负值都是零，因此梯度更加不会趋向逐渐减少到零。 训练你的神经网络的过程，很多时候是凭借直觉的，往往你对神经网络架构有了一个想法，于是你尝试写代码实现你的想法，然后让你运行一个试验环境来告诉你，你的神经网络效果有多好，通过参考这个结果再返回去修改你的神经网络里面的一些细节，然后你不断的重复上面的操作，当你的神经网络需要很长时间去训练，需要很长时间重复这一循环，在这里就有很大的区别，根据你的生产效率去构建更高效的神经网络。当你能够有一个想法，试一试，看效果如何。在10分钟内，或者也许要花上一整天，如果你训练你的神经网络用了一个月的时间，有时候发生这样的事情，也是值得的，因为你很快得到了一个结果。在10分钟内或者一天内，你应该尝试更多的想法，那极有可能使得你的神经网络在你的应用方面工作的更好、更快的计算，在提高速度方面真的有帮助，那样你就能更快地得到你的实验结果。 Summary早上花了2h小时学习第一周的视频，先看一遍视频的字幕，逐字逐句的理解，虽然很多时候都是自己乱猜的，大概清楚讲的什么！然后再看大牛的笔记，然后再看一篇结合PPT。下午也看了半个多小时。问题：1. 自己的英文水平不够，这个需要大大的提高讷。2. 其实只要看别人的笔记就可以知道内容，但是还是想听andow ng的讲解。3. 视频都比较短，每个视频设计的知识点或者内容不多，1到3个，分成知识点做笔记还是不错的 这一周的内容，也就是今天我学习的知识简单和容易理解。学习了神经网络的大致结构，神经网络的应用领域，深度学习为什么取得快速的发展的三点原因，尤其是数据scale与其他方法和神经网络规模的大致性能关系 C1W2C1W2L01: Binary ClassificationIn this week, we’re going to go over the basics of neural network programming. We are going to study handle data without for loop. forward password for propagation backward pass or what’s called a backward propagation step Why the computations in learning in a neural network can be organized in this board propagation and a separate backward propagation by using logistic regression to convey(传达) theses ideas. Binary ClassificationInput； an image . three separate matrices corresponding red green and blue color channels of this image. 如果你的图片大小为64x64像素，那么你就有三个规模为64x64的矩阵，分别对应图片中红、绿、蓝三种像素的强度值 unroll all of these pixel intensity values into a feature vector pixel intensity values of this image notation (x,y)： a pair X comma Y $M_{train}$: M subscript train 每条测试集在矩阵中都是以列向量的形式存在 Matrix capital Model : hypothesis Function :Logistic RegressionSo given an input X and the parameters W and b, how do we generate the output Y hat? Well, one thing you could try, that doesn’t work, would be to have Y hat be w transpose X plus B, kind of a linear function of the input X. And in fact, this is what you use if you were doing linear regression. But this isn’t a very good algorithm for binary classification because you want Y hat to be the chance that Y is equal to one. So,Y hat should really be between zero and one. This is what the sigmoid function looks like. sigmoid function \sigma(z) = \frac{1}{1+e^{-z}}因为你想让$\hat{y}$表示实际值$y$等于1的机率的话， 应该在0到1之间。这是一个需要解决的问题，因为可能比1要大得多，或者甚至为一个负值。对于你想要的在0和1之间的概率来说它是没有意义的，因此在逻辑回归中，我们的输出应该是等于由上面得到的线性函数式子作为自变量的sigmoid函数中，公式如上图最下面所示，将线性函数转换为非线性函数。 注意：原来$w,b$是分开在，这里就合并，引入变量$x_0=1$,对应偏置$b$, Strategy：Cost functionFirstly : Loss function L(\hat{y},y)=\frac{1}{2}\sum{(y_i-\hat{y_i})^2}这个优化问题不是凸优化问题(non-convex)，因此不选用这个 Secondly， L(y,\hat{y})=-(ylog^{\hat{y}}+(1-y)log^{1-\hat{y}}) Algorithm: Gradient Descent Gradient Descent算法步骤： Initialize $w$, $b$ to zero repeat： $w :=w−\alpha \frac{∂J(w,b)}{∂w}$ $b :=b-\alpha \frac{∂J(w,b)}{∂b}$ C1W2L05 &amp; C1W2L06 Derivatives求导，这个是微积分的内容，不用写了！ C1W2L07： Computation GraphC1W2L08 : Derivatives with compution graphs链式法则 \frac{\partial L}{\partial v}=\frac{\partial L}{\partial u}\frac{\partial u}{\partial v}C1W2L09 : Logistic Regression Gradient Descentsingle training exampleYou’ve seen the loss function that measures how well you’re doing on the single training example. You’ve also seen the cost function that measures how well your parameters w and b are doing on your entire training set. You’ve heard me say that the computations of a neural network are organized in terms of a forward pass or a forward propagation step, in which we compute the output of the neural network, followed by a backward pass or back propagation step, which we use to compute gradients or compute derivatives. \frac{\partial L}{\partial w}=\frac{\partial L}{\partial \alpha }\frac{\partial \alpha }{\partial z}\frac{\partial z}{\partial w} \\=-(\frac{y}{a}+\frac{1-y}{1-a})a(1-a)x=(a-y)xC1W2L10 Gradient Descent on m example \min L(w,b)=\sum_{i=1}^{m}L(\alpha_i,y_i)/m\\ \frac{\partial L }{\partial w}=(\sum_{i=1}^{m}\frac{\partial L(a_i,y_i)}{\partial w})/m=(\sum_{i=1}^{m}(a-y_i)x_i)/m\\ \frac{\partial L }{\partial b}=(\sum_{i=1}^{m}\frac{\partial L(a_i,y_i)}{\partial b})/m=(\sum_{i=1}^{m}(a-1)x_i)/m 上面的伪代码告诉我们，需要多次for loop完成代码，但是这会造成运算速度下降！因为我们越来越多地训练非常大的数据集，因此你真的需要你的代码变得非常高效。所以在接下来的几个视频中，我们会谈到向量化，以及如何应用向量化而连一个for循环都不使用。所以学习了这些，我希望你有关于如何应用逻辑回归，或是用于逻辑回归的梯度下降，事情会变得更加清晰 summary今天主要学习了以logistics regression 为例，如何通过链式求导的过程，简单的练习一下，以及再次了解什么是梯度下降法，以及训练学习算法的需要一个损失函数，训练的过程就是求损失函数最优值的过程 C1W2L11: Vectorization1. 什么是Vectorization：将 for loop 尽可能转换为矩阵运算通过numpy内置函数和避开显式的循环(loop)的方式进行向量化，从而有效提高代码速度。 123np.dot(a,b)如果a,b是一维数组，则计算点积如果a,b是多维数据，则矩阵乘法 2. An example of vectorizationvectorization的好处：conciser code, but faster execution 一个简单的对比实验：1,000,000大小的两个向量内积计算，for loop要比Vectorization快300倍。 在Deep Learning时代，vectorization是一项重要的技能。 123456789101112131415161718192021import numpy as np #导入numpy库a = np.array([1,2,3,4]) #创建一个数据aprint(a)# [1 2 3 4]import time #导入时间库a = np.random.rand(1000000)b = np.random.rand(1000000) #通过round随机得到两个一百万维度的数组tic = time.time() #现在测量一下当前时间#向量化的版本c = np.dot(a,b)toc = time.time()print(“Vectorized version:” + str(1000*(toc-tic)) +”ms”) #打印一下向量化的版本的时间​#继续增加非向量化的版本c = 0tic = time.time()for i in range(1000000): c += a[i]*b[i]toc = time.time()print(c)print(“For loop:” + str(1000*(toc-tic)) + “ms”)#打印for循环的版本的时间 3. GPU or CPU 大规模的深度学习再GPU或者图像处理单元运行”，CPU和GPU都有并行化的指令，他们有时候会叫做SIMD指令，这个代表了一个单独指令多维数据，这个的基础意义是，如果你使用了built-in函数,像np.function或者并不要求你实现循环的函数，它可以让python的充分利用并行化计算。 只是在GPU和CPU上面计算，GPU更加擅长SIMD计算，但是CPU事实上也不是太差，可能没有GPU那么擅长吧。SIMD Both CPU and GPU have parallelization instructions(i.e. SIMD, Signle Instruction Multiple Data) C12L12 ： More Vectorization Example矩阵和向量乘法 向量函数 原则：whenever possible, avoid explict for-loops 使用Element wised的矩阵运算，将函数作用在每个矩阵元素上，比如： np.exp() np.log() np.abs() np.maxium() 1/v v**2 C1W2L13: Vectorizing Logistic Regression1. 前向传播 \hat{y}=σ(w^TX+b)=(a(1),a(2),...,a(m−1),a(m))=\\ (\alpha(z_1),\alpha(z_m),...,\alpha(z_m))=\\ (\alpha(w^Tx_1+b),\alpha(w^Tx_2+b),...,\alpha(w^Tx_m+b))=1234import numpy as npz=np.dot(W^T,X)+b# z这里就是python 巧妙的地方，b是实数，但是向量加上实数后，b扩展成向量，被称为广播（brosdcasting） 个人经验： 首先，熟悉每个变量的记号和维度，必要的话，可以画出来，更直观。 先从一个样本做向量化，再把m个样本的操作向量化。 for-loop里面是循环乘法，则向量化一定是一个乘法形式，若对于不确定乘法的左右关系，是否需转置，可以根据目标变量的维度推测。或者先乘起来，再根据目标变量看是否要转置。 C1W2L14 : Vectorzing Logistic Regression’s Gradient Compution backforwd \frac{∂J}{∂w}=\frac{1}{m}X(A−Y)T\\ \frac{∂J}{∂b}=\frac{1}{m}(a(i)−y(i)) 重要的是弄清楚，里面的行列关系，代表的意思，运算时候，先自己理清楚。还有点积、等等运算性质对应的操作，或者对应的内置函数 C1W2L15: Broadcasting in PythonOne Example A.sum(axis = 0)中的参数axis。axis用来指明将要进行的运算是沿着哪个轴执行，在numpy中，0轴是垂直的，也就是列，而1轴是水平的，也就是行。 第二个A/cal.reshape(1,4)指令则调用了numpy中的广播机制。这里使用 3 by 4的矩阵除以1 by 4 的矩阵。技术上来讲，其实并不需要再将矩阵 reshape(重塑)成 ，因为矩阵本身已经是 了。但是当我们写代码时不确定矩阵维度的时候，通常会对矩阵进行重塑来确保得到我们想要的列向量或行向量。重塑操作reshape是一个常量时间的操作，时间复杂度是，它的调用代价极低。 Secondly Example python的广播机制会将常数扩展成4by 1的列向量 其实是将1by*n 的矩阵复制成为mbyn的矩阵 广播机制的举例 axis补充：numpy中，类似sum的函数，经常涉及axis参数，可以取值为0或1，甚至其他。经常记不住，这里我查了了一下，是这样的（原文）： axis的数字，和数组的shape参数的索引是对应的。比如一个数组的shape是(5,6)，则代表5个row，6个column。即在shape中，row和column的个数的索引是0和1。也就第1个坐标，在shape中的第一个元素，索引是0，代表row的方向；第2个坐标，在shape中的第2个元素，索引是1，代表row的方向。 对于sum函数，axis指的是sum“沿着”的方向，经过计算，这个方向的维度因为求和后就消失了，比如sum(axis=0)代表是沿着“row”方向进行求和， 当然axis可以是一个tupe，那就相当于沿着多个多个方向求和。 sum如果不传入axis参数，默认是对所有维度求和。 broadcasting 当两个数组的形状并不相同的时候，我们可以通过扩展数组的方法来实现相加、相减、相乘等操作，这种机制叫做广播（broadcasting）。 三种广播情况 C1W2L16 A Note on Python/numpy vectors本节主要讲Python中的numpy一维数组的特性，以及与行向量或列向量的区别 1. 一维数组的特性首先设置a = np.array.random.randn(5)，这样会生成存储在数组a中的5个高斯随机数变量。之后输出 ，从屏幕上可以得知，此时a 的shape（形状）是一个的结构。这在Python中被称作一个一维数组。它既不是一个行向量也不是一个列向量，这也导致它有一些不是很直观的效果。举个例子，如果我输出一个转置阵，最终结果它会和看起来一样，所以和的转置阵最终结果看起来一样。而如果我输出和的转置阵的内积，你可能会想：乘以的转置返回给你的可能会是一个矩阵。但是如果我这样做，你只会得到一个数。 所以我建议当你编写神经网络时，不要在使用的shape(5,1)是还是(n,)或者一维数组。相反，如果你设置(5,1)，那么这就是5行1列向量。在先前的操作里a和a的转置看起来一样，而现在这样的 a变成一个新的a 的转置，并且它是一个行向量。请注意一个细微的差别，在这种数据结构中，当我们输出a 的转置时有两对方括号，而之前只有一对方括号，所以这就是1行5列的矩阵和一维数组的差别。 2. 行向量和列向量rank 1 array问题：shape是(x,)的数组，既不是行向量，也不是列向量，没法参与正常的矩阵运算，应该总是使用(x,1)或(1,x)的shape来表示向量。但可以通过reshape方法将rank 1 array转换为行向量或列向量。（什么是rank，就是一个数组的维度）一维的数组既不是行向量也不是列向量，转置后，依然是本身。 3. 解决方法12assert(a.shape=（5，1)）# 为了确保你的矩阵或向量所需要的维数时，不要羞于 reshape 操作 C1W2L18 ：Quick Tour of Jupyter/iPython NotebooksC1W2L18: Explanation of Logistic Regression Cost Function对应logistic regression，输出$\hat{y}=p(y=1|x)$,那么$p(y=0|x)=1-\hat{y}$ 综合上面 p(y|x)= \hat{y}^y*(1-\hat{y})^{1-y}对于整个训练集， 假设所有的训练样本服从同一分布且相互独立，也即独立同分布的，所有这些样本的联合概率就是每个样本概率的乘积: p(labels \ in\ training\ set)=\Pi_{i=1}^mp(y_i|x_i)如果利用极大似然法做，找到一组参数，使得样本观测值概率最大 \max log p(label \ in \ training \ set)=log \Pi_{i=1}^mp(y_i|x_i)=\sum -L(\hat{y^i},y^i) \min cost J(w,b)=\frac{1}{m}L(\hat{y^i},y^i)总结一下，为了最小化成本函数，我们从logistic回归模型的最大似然估计的角度出发，假设训练集中的样本都是独立同分布的条件下 Day3 : summary主要学习了python编程的如何才能高效率，内置函数的具有并行性，simd指令，以及一维数组的使用注意事项，logistic regression的lost function的原理证明 C1W3C1W3L01 : Neural Network Overview 许多sigmoid单元堆叠起来形成一个神经网络。 正向传播：输入层到layer one \left.\begin{array}{c}{x} \\ {W^{[1]}} \\ {b^{[1]}}\end{array}\right\} \Longrightarrow z^{[1]}=W^{[1]} x+b^{[1]} \Longrightarrow a^{[1]}=\sigma\left(z^{[1)}\right)layer one 到layer two \left.\begin{array}{r}{a^{(1]}=\sigma\left(z^{[1]}\right)} \\ {W^{[2]}} \\ {b^{[2]}}\end{array}\right\}\begin{array}{l}{\Longrightarrow z^{[2]}=W^{[2]} a^{[1]}+b^{[2]} \Longrightarrow a^{[2]}=\sigma\left(z^{[2]}\right)} \\ {\Longrightarrow L\left(a^{[2]}, y\right)}\end{array}反向传播 \left.\begin{array}{r}{d a^{[1]}=d \sigma\left(z^{[1]}\right)} \\ {d W^{[2]}} \\ {d b^{[2]}}\end{array}\right\}\begin{array}{l}{\Longleftarrow d z^{[2]}=d\left(W^{[2]} \alpha^{[1]}+b^{[2]}\right) \Longleftarrow d a^{[2]}=d \sigma\left(z^{[2]}\right)} \\ {\Longleftarrow d L\left(a^{[2]}, y\right)}\end{array} $W$的行数是本次结点个数，列数是上层节点个数 C1W3L02 : Nerual Network Representations符号说明 C1W3L03： Computation Neural Network OutputA simple training examples 其中，x表示输入特征，a表示每个神经元的输出，W表示特征的权重，上标表示神经网络的层数（隐藏层为1），下标表示该层的第几个神经元。这是神经网络的符号惯例，下同。 神经网络的计算 关于神经网络是怎么计算的，从我们之前提及的逻辑回归开始，如下图所示。用圆圈表示神经网络的计算单元，逻辑回归的计算有两个步骤，首先你按步骤计算出，然后在第二步中你以sigmoid函数为激活函数计算（得出），一个神经网络只是这样子做了好多次重复计算。 说明：$w_i^{[1]}$和$W^{[1]}$的关系，一个按照logistic regression ，一个是矩阵表示。 向量化计算 如果你执行神经网络的程序，用for循环来做这些看起来真的很低效。所以接下来我们要做的就是把这四个等式向量化。向量化的过程是将神经网络中的一层神经元参数纵向堆积起来，例如隐藏层中的纵向堆积起来变成一个(4,3)的矩阵，用符号$W^{[1]}$表示。另一个看待这个的方法是我们有四个逻辑回归单元，且每一个逻辑回归单元都有相对应的参数——向量，把这四个向量堆积在一起，你会得出这4×3的矩阵。 z^{[n]}=W^{[n]}X+b^{[n]} a^{[1]}=\left[ \begin{array}{c}{a_{1}^{[1]}} \\ {a_{2}^{[1]}} \\ {a_{3}^{[1]}} \\ {a_{4}^{[1]}}\end{array}\right]=\sigma\left(z^{[1]}\right) Given input X（a single training set) \begin{array}{c}{z^{[1]}=W^{[1]} a^{[0]}+b^{[1]}} \\ {a^{[1]}=\sigma\left(z^{[1]}\right)} \\ {z^{[2]}=W^{[2]} a^{[1]}+b^{[2]}} \\ {a^{[2]}=\sigma\left(z^{[2]}\right)}\end{array}说明： $W$的第$i$行表示，当前层到上一层的权重行向量，再计算单个的时候，由于是按照logristics regression的方式，所以认为$w_i$是列向量，所以转置成行向量。上面的图也说明了：如何从单个操作到矩阵操作，权重矩阵是怎么构造，怎么表示的。 b是列向量。 C1W3L04: Vectorizing Across Mutilple ExampleDifferent training examples in different columns of the matrix for loop vectorizing : stacking training set in columns x=\left[ \begin{array}{cccc}{\vdots} & {\vdots} & {\vdots} & {\vdots} \\ {x^{(1)}} & {x^{(2)}} & {\dots} & {x} \\ {\vdots} & {\vdots} & {\vdots} & {\vdots}\end{array}\right] 就有 \left\{\begin{array}{l}{A^{[1]}=\sigma\left(z^{[1]}\right)} \\ {z^{[2]}=W^{[2]} A^{[1]}+b^{[2]}} \\ {A^{[2]}=\sigma\left(z^{[2]}\right)}\end{array}\right. 当垂直扫描，是索引到隐藏单位的数字。当水平扫描，将从第一个训练示例中从第一个隐藏的单元到第二个训练样本，第三个训练样本……直到节点对应于第一个隐藏单元的激活值，且这个隐藏单元是位于这个训练样本中的最终训练样本。 从水平上看，矩阵代表了各个训练样本。从竖直上看，矩阵的不同的索引对应于不同的隐藏单元。 C1W3L05 : Explanation for vectorized implement C1W3L06 : Activation Function在讨论优化算法时，有一点要说明：基本已经不用sigmoid激活函数了，tanh函数在所有场合都优于sigmoid函数。 sigmoid函数和tanh函数两者共同的缺点是，在z特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于0，导致降低梯度下降的速度。 在机器学习另一个很流行的函数是：修正线性单元的函数（ReLu），ReLu函数图像是如下图。$ a = max(0,z)$： 所以，只要是正值的情况下，导数恒等于1，当是负值的时候，导数恒等于0。从实际上来说，当使用的导数时，=0的导数是没有定义的。但是当编程实现的时候，的取值刚好等于0.00000001，这个值相当小，所以，在实践中，不需要担心这个值，是等于0的时候，假设一个导数是1或者0效果都可以。 如果输出是0、1值（二分类问题），则输出层选择sigmoid函数，然后其它的所有单元都选择Relu函数。 这是很多激活函数的默认选择，如果在隐藏层上不确定使用哪个激活函数，那么通常会使用Relu激活函数。有时，也会使用tanh激活函数，但Relu的一个缺点是：当z是负值的时候，导数等于0。 这里也有另一个版本的Relu被称为Leaky Relu。 当是负值时，这个函数的值不是等于0，而是轻微的倾斜。 两者的优点是： 第一，在的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个if-else语句，而sigmoid函数需要进行浮点四则运算，在实践中，使用ReLu激活函数神经网络通常会比使用sigmoid或者tanh激活函数学习的更快。 第二，sigmoid和tanh函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而Relu和Leaky ReLu函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，Relu进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而Leaky ReLu不会有这问题) 在ReLu的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。 sigmoid激活函数：除了输出层是一个二分类问题基本不会用它。 tanh激活函数：tanh是非常优秀的，几乎适合所有场合。 ReLu激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用ReLu或者Leaky ReLu。 通常的建议是：如果不确定哪一个激活函数效果更好，可以把它们都试试，然后在验证集或者发展集上进行评价。然后看哪一种表现的更好，就去使用它。 C1W3L07 : Why non-linear activation Functions 通过推导可以得出，如果使用线性激活函数，相当于没有隐藏层。无论你的神经网络有多少层一直在做的只是计算线性函数，所以不如直接去掉全部隐藏层。当当然，在output layer是可以不用activation function，或者用linear activation function；这种情况一般是要求输出实数集结果（比如预测房价）。即便如此，在hidden layer还是要用non-linear activation function。 sigmoid activation function \frac{d}{d z} g(z)=\frac{1}{1+e^{-z}}\left(1-\frac{1}{1+e^{-z}}\right)=g(z)(1-g(z))tanh activation function g(z)=\tanh (z)=\frac{e^{z}-e^{-z}}{e^{x}+e^{-z}} \frac{d}{d z} g(z)=1-(\tanh (z))^{2}Rectified linear unit(RelU) g(z)^{\prime}=\left\{\begin{array}{ll}{0} & {\text { if } z0} \\ {\text {undefined}} & {\text { if } z=0}\end{array}\right.注：通常在z= 0的时候给定其导数1,0；当然=0的情况很少 Leaky linear unit (Leaky ReLU) g(z)=\max (0.01 z, z) g(z)^{\prime}=\left\{\begin{array}{ll}{0.01} & {\text { if } z0} \\ {\text {undefined}} & {\text { if } z=0}\end{array}\right.注：通常在的z=0时候给定其导数1,0.01；当然的情况很少。 C1W3L09 : Gradient Descent For Neural Networks gradient descent的关键是求cost function对参数的偏导数 求导过程使用的是Backpropagation 首先做forward propagation，求解出每一层的输出A (1) z^{[1]}=W^{[1]} x+b^{[1]}\\ (2) a^{[1]}=\sigma\left(z^{[1]}\right)\\(3) z^{[2]}=W^{[2]}=W^{[2]} a^{[1]}+b^{[2]}\\(4) a^{[2]}=g^{[2]}\left(z^{[z]}\right)=\sigma\left(z^{[2]}\right) 然后向后，逐层求解对每一层参数的偏导数 sum，keepdims是防止python输出那些古怪的秩数(n,)，加上这个确保阵矩阵这个向量输出的维度为(n,1）这样标准的形式。 C1WL10: Backpropagation intuition (optional) 实现后向传播有个技巧，就是要保证矩阵的维度相互匹配 其实，对于一个神经元，输入部分：是权重和上一层输出的线性组合；输出：激活函数作用于输入，因此对$W$求偏导时，对激活函数求一次，再对线性组合求一次。对$b$求偏导是，对线性部分求偏导是1,这里用求和。 C1W3L11: Random Initialization` 与logistic regression不同，初始化参数不可固定为0，而是每个参数都要随机初始化。 主要原因是：如果每个参数w和b都是0，则同一层的每个neuron计算结果完全一样（输入一样a，参数一样w，则z一样,symmetry breaking problem）；接下来反向传播时的偏导数也一样，下一轮迭代同一层的每个neuron的w又是一样的。这样整个neural Network上每一层的neuron是同质的，自然不会有好的performance。 .png) 不过，对b参数，可以都初始化为0。 另外需要注意，虽然w是随机初始化，但最好使用较小的随机数。主要是避免让z的计算值过大，导致activation function对z的偏导数趋于0，导致Gradient descent下降较慢。 通常的做法是对random的值乘以一个比率，比如0.01（但具体怎么选这个比率，也要根据情况而定，这应该又是一个超参了）： $W[1]=np.random.randn((2,2))∗0.01$ 因为如果你用tanh或者sigmoid激活函数，或者说只在输出层有一个Sigmoid，如果（数值）波动太大，当你计算激活值时如果很大，就会很大或者很小，因此这种情况下你很可能停在tanh/sigmoid函数的平坦的地方，这些地方梯度很小也就意味着梯度下降会很慢，因此学习也就很慢。 事实上有时有比0.01更好的常数，当你训练一个只有一层隐藏层的网络时（这是相对浅的神经网络，没有太多的隐藏层），设为0.01可能也可以。但当你训练一个非常非常深的神经网络，你可能要试试0.01以外的常数。 summary如何建立一个一层的神经网络了，初始化参数，用前向传播预测，还有计算导数，结合反向传播用在梯度下降中。 1. Define the neural network structure ( # of input units, # of hidden units, etc). 2. Initialize the model's parameters 1. Loop: - Implement forward propagation - Compute loss - Implement backward propagation to get the gradients - Update parameters (gradient descent) C1W4C1W4L01 Deep-layer neural network1. logistics regression and shallow neural network and deep-layer neural network 2. notation神经网络模型 \begin{array}{l}{X \in \mathbb{R}^{n_{x} \times m}} 代表输入的矩阵\\{x^{(i)} \in \mathbb{R}^{n_{x}}} 代表第 i 个样本的列向量\\ {Y \in \mathbb{R}^{n_{y} \times n}} 标记矩阵\\ {y^{(i)} \in \mathbb{R}^{n_{v}}}是第i样本的输出标签\\ W^{[l]} \in \mathbb{R}^{l \times(l-1)}代表第[l]层的权重矩阵\\ b^{[l]} \in \mathbb{R}^{l}代表第[l]层的偏差矩阵\\ {\hat{y}^{(i)} \in \mathbb{R}^{n_{v}}}是预测输出向量\end{array} 通用激活公式： a_{j}^{[l]}=g^{[l]}\left(z_{j}^{[l]}\right)=g^{ | l ]}\left(\sum_{k} w_{j k}^{[l]} a_{k}^{[l-1]}+b_{j}^{[l]}\right)C1W4L02： Forward and Backward propagation1. forward propagation 2. backward propagation \begin{array}{l}{d z^{[l]}=d a^{[l]} * g^{[l]}\left(z^{l l}\right)} \\ {d w^{[l]}=d z^{[l]} \cdot a^{[l-1]}}\\d b^{[l]}=d z^{[l]}\\ d a^{[l-1]}=w^{[l]} \cdot d z^{[l]}\\ d z^{[l]}=w^{[l+1] T} d z^{[l+1]} \cdot g^{[l]^{\prime}}\left(z^{[l]}\right)\end{array}向量化 \begin{array}{l}{d Z^{[l]}=d A^{[l]} * g^{[l]}\left(Z^{[l]}\right)} \\ {d W^{[l]}=\frac{1}{m} d Z^{[l]} \cdot A^{[l-1] T}}\\ \begin{array}{l}{d b^{[l]}=\frac{1}{m} n p \cdot \operatorname{sum}\left(d z^{[l]}, \text { axis }=1, \text {keepdims}=\text {True}\right)} \\ {d A^{[l-1]}=W^{[l] T} \cdot d Z^{[l]}}\end{array}\end{array}summary C1W4L03 : Forward Propagation in d deep network 这里只能用一个显式for循环，从1到，然后一层接着一层去计算。 C1W4L04 Getting matrix dimension right当实现深度神经网络的时候，其中一个常用的检查代码是否有错的方法就是拿出一张纸过一遍算法中矩阵的维数。 $d_w^{[l]}$和$w^{[l]}$维度相同，$db^{[l]}$和$b^{[l]}$维度相同，且w和b向量化维度不变，但z,a以及x的维度会向量化后发生变化。 反向传播的维数检查 在你做深度神经网络的反向传播时，一定要确认所有的矩阵维数是前后一致的，可以大大提高代码通过率。 C1W4L05 Why deep representations?神经网络不需要很大，但是得有深度，也就是隐藏层需要很多， 1. for example of face detector C1W4L06 :Building blocks of a deep neural network 可以看得出，再反向传播的时候，需要用到$Z^{[L]},W^{[L]},b^{[L]}$,因此cash them 正向传播：$Z^{[1]},A^{[1]}…………$,反向传播：$dA^{[L]},dZ{[L]},dW^{[L]}dB^{[L]},dA^{[L-1]}$ C1W4L07：Parameters vs Hyperparameters1 What 2 How Idea—Code—Experiment—Idea这个循环，尝试各种不同的参数，实现模型并观察是否成功，然后再迭代 今天的深度学习应用领域，还是很经验性的过程，通常你有个想法，比如你可能大致知道一个最好的学习率值，可能说最好，我会想先试试看，然后你可以实际试一下，训练一下看看效果如何。然后基于尝试的结果你会发现，你觉得学习率设定再提高到0.05会比较好。如果你不确定什么值是最好的，你大可以先试试一个学习率，再看看损失函数J的值有没有下降。然后你可以试一试大一些的值，然后发现损失函数的值增加并发散了。然后可能试试其他数，看结果是否下降的很快或者收敛到在更高的位置。你可能尝试不同的并观察损失函数这么变了，试试一组值，然后可能损失函数变成这样，这个值会加快学习过程，并且收敛在更低的损失函数值上（箭头标识），我就用这个值了。 在前面几页中，还有很多不同的超参数。然而，当你开始开发新应用时，预先很难确切知道，究竟超参数的最优值应该是什么。所以通常，你必须尝试很多不同的值，并走这个循环，试试各种参数。试试看5个隐藏层，这个数目的隐藏单元，实现模型并观察是否成功，然后再迭代。这页的标题是，应用深度学习领域，一个很大程度基于经验的过程，凭经验的过程通俗来说，就是试直到你找到合适的数值。 所以我经常建议人们，特别是刚开始应用于新问题的人们，去试一定范围的值看看结果如何。然后下一门课程，我们会用更系统的方法，用系统性的尝试各种超参数取值。然后其次，甚至是你已经用了很久的模型，可能你在做网络广告应用，在你开发途中，很有可能学习率的最优数值或是其他超参数的最优值是会变的，所以即使你每天都在用当前最优的参数调试你的系统，你还是会发现，最优值过一年就会变化，因为电脑的基础设施，CPU或是GPU可能会变化很大。所以有一条经验规律可能每几个月就会变。如果你所解决的问题需要很多年时间，只要经常试试不同的超参数，勤于检验结果，看看有没有更好的超参数数值，相信你慢慢会得到设定超参数的直觉，知道你的问题最好用什么数值。 有一条经验规律：经常试试不同的超参数，勤于检查结果，看看有没有更好的超参数取值，你将会得到设定超参数的直觉。 总结：超参数的设定，靠经验，尝试，并调，根据结果调， C1W4L08 : What does this have to do with the brain?# summary : forward prop and back prop1. logistics regression,shallow neural network and deep neural networklogistics regression Z = W^TX+B\\ A = \frac{1}{1+e^{-Z}}\\ L(A,Y)=-\frac{1}{m}(Ylog^A+(1-Y)log^{1-A}\\ \frac{\partial L}{\partial Z}=(A-Y)\\ \frac{\partial L}{\partial W}=X(A-Y)\\说明：X是样本按列堆积，W是列向量 shallow neural network 以二分问题为例 Z^{[1]}=W^{[1]}A^{[0]}+b^{[1]}\\ A^{[1]}=g^{[1]}(Z^{[1]})\\ \ \\ Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}\\ A^{[2]}=g^{[2]}(Z^{[2]})\\ \ \ \\ \ \\ L(A^{[2]},Y)=-\frac{1}{m}(Ylog^{A}+(1-Y)log^{1-A})\\ \frac{\partial L}{\partial Z^{[2]}}=(A^{[2]}-Y)\\ \frac{\partial L}{\partial W^{[2]}}=(A^{[2]}-Y)A^{[1]^T}\\ \frac{\partial L}{\partial b^{[2]}}=(A^{[2]}-Y)1_{1*m}^T\\ \frac{\partial L}{\partial a^{[1]}}=W^{[2]^T}(A^{[2]}-Y)\\ \ \\ \frac{\partial L}{\partial Z^{[1]}}=W^{[2]^T}(A^{[2]}-Y)* g^{'[1]}(Z^{[1]})\\说明：W是按列排$W^{[L]}$是$n^{[L]}*n^{[L-1]}$矩阵，A,Z是按列堆积，记得检查矩阵维数就好了 deep neural network Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}\\ A^{[l]}=g^{[l]}(Z^{[l]})\\ \ \ \\ \ \\ \frac{\partial L}{\partial Z^{[l]}}=\partial A^*g^{'[l]}(Z^{l})\\ \frac{\partial L}{\partial W^{[l]}}=\partial Z^{[l]} A^{[1-1]^T}\\ \frac{\partial L}{\partial b^{[l]}}=\partial Z^{[l]}\\ \frac{\partial L}{\partial a^{[l-1]}}=W^{[l]^T}\partial Z^{[l]}\\ \ \\ \frac{\partial L}{\partial Z^{[l-1]}}=W^{[l]^T}\partial Z^{[l]}* g^{'[l-1]}(Z^{[l-1]})\\2. vectorization 推导的时候要向量化，注意矩阵维数表示，可以从单个推导到mutli 充分利用python的广播属性，和内置函数的并行化 python一维，二维数组的特性 3. 知识结构]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deep_learning.ai深度学习笔记]]></title>
    <url>%2F2019%2F04%2F11%2Fdeep-learning-ai%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C5: Sequence ModelsW1 : Recurrent Neural Networks (循环序列模型)L1 ： Why Sequence Models?循环神经网络（RNN）之类的模型在语音识别、自然语言处理和其他领域中引起变革。 序列模型的列子 L2 : Notation 数学符号NLP 我们用$X^{(i)}$来表示第个i训练样本，所以为了指代第个t元素，或者说是训练样本i的序列中第t个元素用$X^{(i)}$这个符号来表示。如果是序列长度$T_x$，那么你的训练集里不同的训练样本就会有不同的长度，所以$T_x^{(i)}$就代表第个训练样本的输入序列长度。同样$y^{(i)}$代表第i个训练样本中第t个元素，$T_y^{(i)}$就是第i个训练样本的输出序列的长度。 预先有一个词典 L3 : Recurrent Neural Network Model (循环神经网络模型)现在我们讨论一下怎样才能建立一个模型，建立一个神经网络来学习X到Y的映射 $a^{}$通常 是零向量 N模型包含三类权重系数，分别是Wax，Waa，Wya。且不同元素之间同一位置共享同一权重系数。 RNN的正向传播（Forward Propagation）过程为： 循环神经网络用的激活函数经常是tanh，不过有时候也会用ReLU，但是tanh是更通常的选择，我们有其他方法来避免梯度消失问题，我们将在之后进行讲述。选用哪个激活函数是取决于你的输出y，如果它是一个二分问题，那么我猜你会用sigmoid函数作为激活函数，如果是k类别分类问题的话，那么可以选用softmax作为激活函数。不过这里激活函数的类型取决于你有什么样类型的输出y，对于命名实体识别来说y只可能是0或者1，那我猜这里第二个激活函数g可以是sigmoid激活函数。 c4: Backpropagation through time ( 通过时间的反向传播) 参数的关系* 单个元素的Loss function: 该样本所有元素的Loss function为： 然后，反向传播（Backpropagation）过程就是从右到左分别计算L(y^,y)对参数Wa，Wy，ba，by的偏导数。思路与做法与标准的神经网络是一样的。一般可以通过成熟的深度学习框架自动求导，例如PyTorch、Tensorflow等。这种从右到左的求导过程被称为Backpropagation through time L5: Different types of RNNs (不同类型的循环神经网络) L6 : Language model and sequence generation (语言模型和序列生成) L7 : Sampling novel sequences (对新序列采样) Vanishing gradients with RNNs (循环神经网络的梯度消失)首先从左到右前向传播，然后反向传播。但是反向传播会很困难，因为同样的梯度消失的问题，后面层的输出误差（上图编号6所示）很难影响前面层（上图编号7所示的层）的计算。这就意味着，实际上很难让一个神经网络能够意识到它要记住看到的是单数名词还是复数名词，然后在序列后面生成依赖单复数形式的was或者were。而且在英语里面，这中间的内容（上图编号8所示）可以任意长，对吧？所以你需要长时间记住单词是单数还是复数，这样后面的句子才能用到这些信息。也正是这个原因，所以基本的RNN模型会有很多局部影响 http://www.ai-start.com/dl2017/html/lesson5-week1.html https://mp.weixin.qq.com/s?__biz=MzIwOTc2MTUyMg==&amp;mid=2247484029&amp;idx=1&amp;sn=c93b5eddec33dc29dc172a5ea0d76822&amp;chksm=976fa7e0a0182ef61e36d1c32aa0706c4e81e1762a7ee2554165beecde929b72cf026c5b7a64&amp;scene=21#wechat_redirect]]></content>
      <categories>
        <category>学习の历程(Journal of Studying)</category>
      </categories>
      <tags>
        <tag>我的读书笔记</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F07%2F%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[: [TOC] 利用听力材料学英语最高效有效输出应该是稍高于现有水平的、更准确、更得体的表达输出 先记住以下两点，下面我们再一一解析应该要怎么做到。 1. 学习需要反馈，来告诉我们这输出是正确的，可以继续；或者是错误的，需要修正。 2. 将输入内化，变成自己的知识。 我一般会听四遍，但不是全听原文。 第一遍：泛听原文，不要看字幕或脚本，清楚录音的内容。听第一遍的时候我通常连笔记都不做，目的是为了让自己流畅的听完，对听力的内容有一个整体的掌握。 第二遍：先听原文，根据内容段落，开始复述内容，并录音。这一步的目的是强迫自己调用已经学过的知识，组织语言和进行练习。 第三遍，听自己的录音，然后做出修正。这一步很重要，可以让你了解自己的发音问题和语法问题，并把可听出来的语法问题进行修改。通过这一步，我们就可以把简单重复输入的语言材料，转化为有效输出。 第四遍，听原文看字幕和脚本，看把听不懂的地方标注，说明为什么听不懂（比如是因为自己发音不准导致的听不出，或者就是因为这个词没背过、不熟悉）。不熟悉的用法和自己用错的地方总结，背下来，下次试着用。 Tips： 不要选择太难的材料，太难的材料容易使自己丧失学习兴趣。 一开始，不要选择太长的听力材料。10分钟左右最佳。在这里推荐ted，可以选择有字幕或关闭字幕。 在一个相近的时间段内，选择相近题材的材料。比如我会在两个星期内选择“心理”题材的录音。这样我就会有更大的几率用上刚学过的结构和词汇。 及时总结，及时复习已背过的材料，复习的重要性大家都懂，这里就不多说了。 真题听写 材料选择 能够听得懂 70%的材料 2 具体执行方法 先泛听一篇 再循环听几遍 再逐句逐句的听 美剧精听 先看中文听 英文，查 听找 台词，跟读 重复三四至少10]]></content>
  </entry>
  <entry>
    <title><![CDATA[deeplearningvideo]]></title>
    <url>%2F2019%2F04%2F03%2Fdeeplearningvideo%2F</url>
    <content type="text"><![CDATA[Coursera深度学习教程中文笔记 课程概述 https://mooc.study.163.com/university/deeplearning_ai#/c 这些课程专为已有一定基础（基本的编程知识，熟悉Python、对机器学习有基本了解），想要尝试进入人工智能领域的计算机专业人士准备。介绍显示：“深度学习是科技业最热门的技能之一，本课程将帮你掌握深度学习。” 在这5堂课中，学生将可以学习到深度学习的基础，学会构建神经网络，并用在包括吴恩达本人在内的多位业界顶尖专家指导下创建自己的机器学习项目。Deep Learning Specialization对卷积神经网络 (CNN)、递归神经网络 (RNN)、长短期记忆 (LSTM) 等深度学习常用的网络结构、工具和知识都有涉及。 笔记是根据视频和字幕写的，没有技术含量，只需要专注和严谨。 2018-04-14 本课程视频教程地址：https://mooc.study.163.com/university/deeplearning_ai#/c （该视频从www.deeplearning.ai 网站下载，因众所周知的原因，国内用户观看某些在线视频非常不容易，故一些学者一起制作了离线视频，旨在方便国内用户个人学习使用，请勿用于商业用途。视频内嵌中英文字幕，推荐使用potplayer播放。版权属于吴恩达老师所有，若在线视频流畅，请到官方网站观看。） 笔记网站(适合手机阅读) 吴恩达老师的机器学习课程笔记和视频：https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes 深度学习笔记目录第一门课 神经网络和深度学习(Neural Networks and Deep Learning)第一周：深度学习引言(Introduction to Deep Learning) 1.1 欢迎(Welcome) 1.2 什么是神经网络？(What is a Neural Network) 1.3 神经网络的监督学习(Supervised Learning with Neural Networks) 1.4 为什么神经网络会流行？(Why is Deep Learning taking off?) 1.5 关于本课程(About this Course) 1.6 课程资源(Course Resources) 1.7 Geoffery Hinton 专访(Geoffery Hinton interview) 第二周：神经网络的编程基础(Basics of Neural Network programming) 2.1 二分类(Binary Classification) 2.2 逻辑回归(Logistic Regression) 2.3 逻辑回归的代价函数（Logistic Regression Cost Function） 2.4 梯度下降（Gradient Descent） 2.5 导数（Derivatives） 2.6 更多的导数例子（More Derivative Examples） 2.7 计算图（Computation Graph） 2.8 计算图导数（Derivatives with a Computation Graph） 2.9 逻辑回归的梯度下降（Logistic Regression Gradient Descent） 2.10 梯度下降的例子(Gradient Descent on m Examples) 2.11 向量化(Vectorization) 2.12 更多的向量化例子（More Examples of Vectorization） 2.13 向量化逻辑回归(Vectorizing Logistic Regression) 2.14 向量化逻辑回归的梯度计算（Vectorizing Logistic Regression’s Gradient） 2.15 Python中的广播机制（Broadcasting in Python） 2.16 关于 Python与numpy向量的使用（A note on python or numpy vectors） 2.17 Jupyter/iPython Notebooks快速入门（Quick tour of Jupyter/iPython Notebooks） 2.18 逻辑回归损失函数详解（Explanation of logistic regression cost function） 第三周：浅层神经网络(Shallow neural networks) 3.1 神经网络概述（Neural Network Overview） 3.2 神经网络的表示（Neural Network Representation） 3.3 计算一个神经网络的输出（Computing a Neural Network’s output） 3.4 多样本向量化（Vectorizing across multiple examples） 3.5 向量化实现的解释（Justification for vectorized implementation） 3.6 激活函数（Activation functions） 3.7 为什么需要非线性激活函数？（why need a nonlinear activation function?） 3.8 激活函数的导数（Derivatives of activation functions） 3.9 神经网络的梯度下降（Gradient descent for neural networks） 3.10（选修）直观理解反向传播（Backpropagation intuition） 3.11 随机初始化（Random+Initialization） 第四周：深层神经网络(Deep Neural Networks) 4.1 深层神经网络（Deep L-layer neural network） 4.2 前向传播和反向传播（Forward and backward propagation） 4.3 深层网络中的前向和反向传播（Forward propagation in a Deep Network） 4.4 核对矩阵的维数（Getting your matrix dimensions right） 4.5 为什么使用深层表示？（Why deep representations?） 4.6 搭建神经网络块（Building blocks of deep neural networks） 4.7 参数VS超参数（Parameters vs Hyperparameters） 4.8 深度学习和大脑的关联性（What does this have to do with the brain?） 第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)第一周：深度学习的实用层面(Practical aspects of Deep Learning) 1.1 训练，验证，测试集（Train / Dev / Test sets） 1.2 偏差，方差（Bias /Variance） 1.3 机器学习基础（Basic Recipe for Machine Learning） 1.4 正则化（Regularization） 1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?） 1.6 dropout 正则化（Dropout Regularization） 1.7 理解 dropout（Understanding Dropout） 1.8 其他正则化方法（Other regularization methods） 1.9 标准化输入（Normalizing inputs） 1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients） 1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing /Exploding gradients） 1.12 梯度的数值逼近（Numerical approximation of gradients） 1.13 梯度检验（Gradient checking） 1.14 梯度检验应用的注意事项（Gradient Checking Implementation Notes） 第二周：优化算法 (Optimization algorithms) 2.1 Mini-batch 梯度下降（Mini-batch gradient descent） 2.2 理解Mini-batch 梯度下降（Understanding Mini-batch gradient descent） 2.3 指数加权平均（Exponentially weighted averages） 2.4 理解指数加权平均（Understanding Exponentially weighted averages） 2.5 指数加权平均的偏差修正（Bias correction in exponentially weighted averages） 2.6 momentum梯度下降（Gradient descent with momentum） 2.7 RMSprop——root mean square prop（RMSprop） 2.8 Adam优化算法（Adam optimization algorithm） 2.9 学习率衰减（Learning rate decay） 2.10 局部最优问题（The problem of local optima） 第三周超参数调试，batch正则化和程序框架（Hyperparameter tuning, Batch Normalization and Programming Frameworks) 3.1 调试处理（Tuning process） 3.2 为超参数选择和适合范围（Using an appropriate scale to pick hyperparameters） 3.3 超参数训练的实践：Pandas vs. Caviar（Hyperparameters tuning in practice: Pandas vs. Caviar） 3.4 网络中的正则化激活函数（Normalizing activations in a network） 3.5 将 Batch Norm拟合进神经网络（Fitting Batch Norm into a neural network） 3.6 为什么Batch Norm奏效？（Why does Batch Norm work?） 3.7 测试时的Batch Norm（Batch Norm at test time） 3.8 Softmax 回归（Softmax Regression） 3.9 训练一个Softmax 分类器（Training a softmax classifier） 3.10 深度学习框架（Deep learning frameworks） 3.11 TensorFlow（TensorFlow） 第三门课 结构化机器学习项目 (Structuring Machine Learning Projects)第一周：机器学习策略（1）(ML Strategy (1)) 1.1 为什么是ML策略？ (Why ML Strategy) 1.2 正交化(Orthogonalization) 1.3 单一数字评估指标(Single number evaluation metric) 1.4 满足和优化指标 (Satisficing and Optimizing metric) 1.5 训练集、开发集、测试集的划分(Train/dev/test distributions) 1.6 开发集和测试集的大小 (Size of the dev and test sets) 1.7 什么时候改变开发集/测试集和评估指标(When to change dev/test sets and metrics) 1.8 为什么是人的表现 (Why human-level performance?) 1.9 可避免偏差(Avoidable bias) 1.10 理解人类的表现 (Understanding human-level performance) 1.11 超过人类的表现(Surpassing human-level performance) 1.12 改善你的模型表现 (Improving your model performance) 第二周：机器学习策略（2）(ML Strategy (2)) 2.1 误差分析 (Carrying out error analysis) 2.2 清除标注错误的数据(Cleaning up incorrectly labeled data) 2.3 快速搭建你的第一个系统，并进行迭代(Build your first system quickly, then iterate) 2.4 在不同的分布上的训练集和测试集 (Training and testing on different distributions) 2.5 数据分布不匹配的偏差与方差分析 (Bias and Variance with mismatched data distributions) 2.6 处理数据不匹配问题(Addressing data mismatch) 2.7 迁移学习 (Transfer learning) 2.8 多任务学习(Multi-task learning) 2.9 什么是端到端的深度学习？ (What is end-to-end deep learning?) 2.10 是否使用端到端的深度学习方法 (Whether to use end-to-end deep learning) 第四门课 卷积神经网络（Convolutional Neural Networks）第一周 卷积神经网络(Foundations of Convolutional Neural Networks) 1.1 计算机视觉（Computer vision） 1.2 边缘检测示例（Edge detection example） 1.3 更多边缘检测内容（More edge detection） 1.4 Padding 1.5 卷积步长（Strided convolutions） 1.6 三维卷积（Convolutions over volumes） 1.7 单层卷积网络（One layer of a convolutional network） 1.8 简单卷积网络示例（A simple convolution network example） 1.9 池化层（Pooling layers） 1.10 卷积神经网络示例（Convolutional neural network example） 1.11 为什么使用卷积？（Why convolutions?） 第二周 深度卷积网络：实例探究(Deep convolutional models: case studies) 2.1 为什么要进行实例探究？（Why look at case studies?） 2.2 经典网络（Classic networks） 2.3 残差网络（Residual Networks (ResNets)） 2.4 残差网络为什么有用？（Why ResNets work?） 2.5 网络中的网络以及 1×1 卷积（Network in Network and 1×1 convolutions） 2.6 谷歌 Inception 网络简介（Inception network motivation） 2.7 Inception 网络（Inception network） 2.8 使用开源的实现方案（Using open-source implementations） 2.9 迁移学习（Transfer Learning） 2.10 数据扩充（Data augmentation） 2.11 计算机视觉现状（The state of computer vision） 第三周 目标检测（Object detection） 3.1 目标定位（Object localization） 3.2 特征点检测（Landmark detection） 3.3 目标检测（Object detection） 3.4 卷积的滑动窗口实现（Convolutional implementation of sliding windows） 3.5 Bounding Box预测（Bounding box predictions） 3.6 交并比（Intersection over union） 3.7 非极大值抑制（Non-max suppression） 3.8 Anchor Boxes 3.9 YOLO 算法（Putting it together: YOLO algorithm） 3.10 候选区域（选修）（Region proposals (Optional)） 第四周 特殊应用：人脸识别和神经风格转换（Special applications: Face recognition &amp;Neural style transfer） 4.1 什么是人脸识别？(What is face recognition?) 4.2 One-Shot学习（One-shot learning） 4.3 Siamese 网络（Siamese network） 4.4 Triplet 损失（Triplet 损失） 4.5 面部验证与二分类（Face verification and binary classification） 4.6 什么是神经风格转换？（What is neural style transfer?） 4.7 什么是深度卷积网络？（What are deep ConvNets learning?） 4.8 代价函数（Cost function） 4.9 内容代价函数（Content cost function） 4.10 风格代价函数（Style cost function） 4.11 一维到三维推广（1D and 3D generalizations of models） 第五门课 序列模型(Sequence Models)第一周 循环序列模型（Recurrent Neural Networks） 1.1 为什么选择序列模型？（Why Sequence Models?） 1.2 数学符号（Notation） 1.3 循环神经网络模型（Recurrent Neural Network Model） 1.4 通过时间的反向传播（Backpropagation through time） 1.5 不同类型的循环神经网络（Different types of RNNs） 1.6 语言模型和序列生成（Language model and sequence generation） 1.7 对新序列采样（Sampling novel sequences） 1.8 循环神经网络的梯度消失（Vanishing gradients with RNNs） 1.9 GRU单元（Gated Recurrent Unit（GRU）） 1.10 长短期记忆（LSTM（long short term memory）unit） 1.11 双向循环神经网络（Bidirectional RNN） 1.12 深层循环神经网络（Deep RNNs） 第二周 自然语言处理与词嵌入（Natural Language Processing and Word Embeddings） 2.1 词汇表征（Word Representation） 2.2 使用词嵌入（Using Word Embeddings） 2.3 词嵌入的特性（Properties of Word Embeddings） 2.4 嵌入矩阵（Embedding Matrix） 2.5 学习词嵌入（Learning Word Embeddings） 2.6 Word2Vec 2.7 负采样（Negative Sampling） 2.8 GloVe 词向量（GloVe Word Vectors） 2.9 情绪分类（Sentiment Classification） 2.10 词嵌入除偏（Debiasing Word Embeddings） 第三周 序列模型和注意力机制（Sequence models &amp; Attention mechanism） 3.1 基础模型（Basic Models） 3.2 选择最可能的句子（Picking the most likely sentence） 3.3 集束搜索（Beam Search） 3.4 改进集束搜索（Refinements to Beam Search） 3.5 集束搜索的误差分析（Error analysis in beam search） 3.6 Bleu 得分（选修）（Bleu Score (optional)） 3.7 注意力模型直观理解（Attention Model Intuition） 3.8注意力模型（Attention Model） 3.9语音识别（Speech recognition） 3.10触发字检测（Trigger Word Detection） 3.11结论和致谢（Conclusion and thank you） 人工智能大师访谈 吴恩达采访 Geoffery Hinton 吴恩达采访 Ian Goodfellow 吴恩达采访 Ruslan Salakhutdinov 吴恩达采访 Yoshua Bengio 吴恩达采访 林元庆 吴恩达采访 Pieter Abbeel 吴恩达采访 Andrej Karpathy 附件 深度学习符号指南（原课程翻译）]]></content>
      <categories>
        <category>视频学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯分类器]]></title>
    <url>%2F2019%2F03%2F28%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 概率论的知识 条件概率 P(A|B)=P(A\cap B)/P(B)已知B发生的概率，求A发生的概率 全概率 P(B) = \sum_{i=1}^{N}P(B \cap A_i)P(A_i)贝叶斯推断 P(A|B)=P(A)\frac{P(B|A)}{P(B)} P(A_i|B)=P(A_i)\frac{P(B|A_i)}{\sum P(A_i)P(B|A_i)}$P(A)$：Prior probability 先验概率，在B事件发生之前，对A事件做一个判断 $P(A|B)$:Posterior probability 后验概率，在B事件发生之后，对A事件的概率重新评估 $P(B|A)/P(B)$:称为可能性函数，一个调整因子 后验概率=先验概率*调整因子 （可知，调整因此&gt;1,发生概率增大了， 贝叶斯决策论英文：Bayesian decision theory 设有$N$种可能的类别, 即γ=${c_1,c_2,…,c_N}$. $λ_ij$是将一个真实类别为$c_j$的样本判为$c_x$的损失。 基于后验概率可得将样本分类所产生的期望损失, 或者成为条件风险(Conditional Risk) R(C_i|x)=∑_{j=1}^Nλ_{ij}P(c_j|x)于是， 我们的任务就是寻找判定准则h， 令$χ→γ$ 使得最小化总体风险，$R(h)=E_x[R(h(x)|x]$最小. 对于每一个$x$，若$h$都能最小化条件风险，那么总体也被最小化了。 可以简化为对每个样本选择其条件风险最小的分类, 即: h(x)=arg \min_{c⊂λ}R(c|x)此$h(x)$就是贝叶斯最优分类器。 $R(h)$为贝叶斯风险(Bayes Risk), $1−R(h)$反映了分类器的最优性能. 具体来说，如果目标是最小化分类错误率， \lambda_{ij}=\begin{cases} 0\ \ i==j\\1 \ \ \ i!=j \end{cases}则$R(c|x)=1-p(c|x)$，因此可知，$h(x)=\max_{c\in C} p(c|x)$ 对于样本$x$,选择后验概率$P(c|X)$最大的类别为标记。 问题转换为 P(c_i|x)=\frac{P(c_i)P(x|c_i)}{\sum P(x)}求先验概率和似然($P(x|c)$) 其中 $P(c)$表达了样本空间种各类样本所占的比列，根据大数定律，当样本足够充分的独立同分布样本是，可以频率估计 $P(x|c)$,涉及关于x所以属性的联合概率，用频率估计概率可能不太好，对于估计类条件概率的一种宠用策略是先假设具有某种确定的概率分布形式，再基于训练样本对概率分布的参数进行估计。 $P(x|c)$是类条件概率，由某个分布决定，$P(x|\theta_c)$来表示了 频率注意派认为可以通过优化似然函数估计参数。$D_c$类别c的样本集合，独立同分布 P(D_c|\theta_c)=\Pi_{x \in D_c}P(x|\theta_c) LL(\theta_c)=log P(D_c|\theta_c)朴素贝叶斯分类器英文：naive Bayes classifier 假设：属性条件独立性假设，每个属性独立性对分类结果发生影响 P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)\Pi_{i=1}^{d}P(x_i|c)}{P(x)}对于一个$x$，$P(x)$都是相同的，因此贝叶斯模型可写为 h_{nb}(x)=arg max_{c\in y}P(c)\Pi_{i=1}^{d}P(x_i|c)计算过程假设$D_{c_i}$表示第i类的样本集合， $P(c_i)=\frac{|D_{c_i}|}{|D|}$ 如果是离散属性 P(x_i|c_i)=\frac{|D_{c,x_i}|}{|D_{c_i}|}如果是连续属性，$P(x_i|c_i)$服从$N(u_{c,i},\theta_{c,i}^2)$的分布 P(x_i|c)=\frac{1}{\sqrt{2\pi}\theta_{c,i}}exp(-\frac{(x_i-u_i)^2}{2\theta_{c,i}^2}) $P(c_i)\Pi_{i=1}^{N}P(x_i|c_i)$ 注意为了避免其他属性携带的信息被训练集中未出现的属性值抹去，因此用拉普拉斯修正（Laplacian correction) P(c)=\frac{|D_{c_i}|+1}{|D|+N}\\ P(x_i|c)=\frac{|D_{x_i,c}|+1}{|D_c|+N_i}$N$:训练集可能出现的类别数 $N_i$:第i个属性可能的取值数 显然，拉普拉斯修正避免因训练集不充分导出的概率估值为0的情况 朴素贝叶斯的种类再scikit-learn中，一共有三个朴素贝叶斯，分别是 GaussianNB P(x_i|C_i)=\frac{1}{\sqrt{2\pi}\theta_{c,i}}exp(-\frac{(x_i-u_i)^2}{2\theta_{c,i}^2})12345678910111213141516171819202122#导入包import pandas as pdfrom sklearn.naive_bayes import GaussianNBfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_score#导入数据集from sklearn import datasetsiris=datasets.load_iris()#切分数据集Xtrain, Xtest, ytrain, ytest = train_test_split(iris.data, iris.target, random_state=42)#建模clf = GaussianNB()clf.fit(Xtrain, ytrain)#在测试集上执行预测，proba导出的是每个样本属于某类的概率clf.predict(Xtest)clf.predict_proba(Xtest) #每一类计算结果都输出#测试准确率accuracy_score(ytest, clf.predict(Xtest)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import numpy as npimport pandas as pdimport randomdataSet =pd.read_csv('iris.txt',header = None)dataSet.head()def randSplit(dataSet, rate): l = list(dataSet.index) #提取出索引 random.shuffle(l) #随机打乱索引 dataSet.index = l #将打乱后的索引重新赋值给原数据集 n = dataSet.shape[0] #总行数 m = int(n * rate) #训练集的数量 train = dataSet.loc[range(m), :] #提取前m个记录作为训练集 test = dataSet.loc[range(m, n), :] #剩下的作为测试集 dataSet.index = range(dataSet.shape[0]) #更新原数据集的索引 test.index = range(test.shape[0]) #更新测试集的索引train,test=randSplit(dataSet, 0.8)def gnb_classify(train,test): labels = train.iloc[:,-1].value_counts().index #提取训练集的标签种类 mean =[] #存放每个类别的均值 std =[] #存放每个类别的方差 result = [] #存放测试集的预测结果 for i in labels: item = train.loc[train.iloc[:,-1]==i,:] #分别提取出每一种类别 m = item.iloc[:,:-1].mean() #当前类别的平均值 s = np.sum((item.iloc[:,:-1]-m)**2)/(item.shape[0]) #当前类别的方差 mean.append(m) #将当前类别的平均值追加至列表 std.append(s) #将当前类别的方差追加至列表 means = pd.DataFrame(mean,index=labels) #变成DF格式，索引为类标签 stds = pd.DataFrame(std,index=labels) #变成DF格式，索引为类标签 for j in range(test.shape[0]): iset = test.iloc[j,:-1].tolist() #当前测试实例 iprob = np.exp(-1*(iset-means)**2/(stds*2))/(np.sqrt(2*np.pi*stds)) #正态分布公式 prob = train.iloc[:,-1].value_counts()/len(train.iloc[:,-1]) #初始化当前实例总概率 for k in range(test.shape[1]-1): #遍历每个特征 prob *= iprob[k] #特征概率之积即为当前实例概率 cla = prob.index[np.argmax(prob.values)] #返回最大概率的类别 result.append(cla) test['predict']=result acc = (test.iloc[:,-1]==test.iloc[:,-2]).mean() #计算预测准确率 print(f'模型预测准确率为&#123;acc&#125;') return testgnb_classify(train,test)for i in range(20): train,test= randSplit(dataSet, 0.8) gnb_classify(train,test) MultinomialNB先验概率多项式分布的朴素贝叶斯，假设特征是由一共简单多项式分布生成，多项分布可以描述各种类型样本出现的频率，该模型常用于文本分类，特别表示次数。$\lambda$常取值1 P(x_{il}|c)=\frac{x_{il}+\lambda}{m_k+n\lambda}12345678910def loadDataSet(): dataSet=[['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] #切分好的词条 classVec = [0,1,0,1,0,1] #类别标签向量，1代表侮辱性词汇，0代表非侮辱性词汇 return dataSet,classVecdataSet,classVec = loadDataSet() 12345678def createVocabList(dataSet): vocabSet = set() #创建一个空的集合 for doc in dataSet: #遍历dataSet中的每一条言论 vocabSet = vocabSet | set(doc) #取并集 vocabList = list(vocabSet) return vocabListvocabList = createVocabList(dataSet) 12345678def setOfWords2Vec(vocabList, inputSet): returnVec = [0] * len(vocabList) #创建一个其中所含元素都为0的向量 for word in inputSet: #遍历每个词条 if word in vocabList: #如果词条存在于词汇表中，则变为1 returnVec[vocabList.index(word)] = 1 else: print(f" &#123;word&#125; is not in my Vocabulary!" ) return returnVec #返回文档向量 12345678def get_trainMat(dataSet): trainMat = [] #初始化向量列表 vocabList = createVocabList(dataSet) #生成词汇表 for inputSet in dataSet: #遍历样本词条中的每一条样本 returnVec=setOfWords2Vec(vocabList, inputSet) #将当前词条向量化 trainMat.append(returnVec) #追加到向量列表中 return trainMattrainMat = get_trainMat(dataSet) 1234567891011121314151617181920def trainNB(trainMat,classVec): n = len(trainMat) #计算训练的文档数目 m = len(trainMat[0]) #计算每篇文档的词条数 pAb = sum(classVec)/n #文档属于侮辱类的概率 p0Num = np.zeros(m) #词条出现数初始化为0 p1Num = np.zeros(m) #词条出现数初始化为0 p0Denom = 0 #分母初始化为0 p1Denom = 0 #分母初始化为0 for i in range(n): #遍历每一个文档 if classVec[i] == 1: #统计属于侮辱类的条件概率所需的数据 p1Num += trainMat[i] p1Denom += sum(trainMat[i]) else: #统计属于非侮辱类的条件概率所需的数据 p0Num += trainMat[i] p0Denom += sum(trainMat[i]) p1V = p1Num/p1Denom p0V = p0Num/p0Denom return p0V,p1V,pAb #返回属于非侮辱类,侮辱类和文档属于侮辱类的概率p0V,p1V,pAb=trainNB(trainMat,classVec) 1234567891011121314151617181920212223from functools import reducedef classifyNB(vec2Classify, p0V, p1V, pAb): p1 = reduce(lambda x,y:x*y, vec2Classify * p1V) * pAb #对应元素相乘 p0 = reduce(lambda x,y:x*y, vec2Classify * p0V) * (1 - pAb) print('p0:',p0) print('p1:',p1) if p1 &gt; p0: return 1 else: return 0def testingNB(testVec): dataSet,classVec = loadDataSet() #创建实验样本 vocabList = createVocabList(dataSet) #创建词汇表 trainMat= get_trainMat(dataSet) #将实验样本向量化 p0V,p1V,pAb = trainNB(trainMat,classVec) #训练朴素贝叶斯分类器 thisone = setOfWords2Vec(vocabList, testVec) #测试样本向量化 if classifyNB(thisone,p0V,p1V,pAb): print(testVec,'属于侮辱类') #执行分类并打印分类结果 else: print(testVec,'属于非侮辱类') #执行分类并打印分类结果 testVec1 = ['love', 'my', 'dalmation']testingNB(testVec1) BernoulliNB伯努利分布，如果是二元伯努利分布 P(x_{il}|C_i)=P(i|Y=C_i)x_{il}+(1-P(i|Y=C_i))(1-x_{il})如果样本属性大多数属于连续，GaussionNB 如果是离散值，使用MultinomialNB 如果样本特征是二元离散值或者稀疏离散值，BernoulliNB 半朴素贝叶斯信息量、熵、联合熵、条件熵、互信息信息量反应了随机变量取某个值含的可能性大小，或者是含有的信息多少 I(X=x)=-log_2^{p(x）}熵(entropy)反应了信源平均每个符号的信息量,或者是随机变量不确定性的衡量 H(X)=E(I(X))=\sum p(X=x)(-log_2^{p(x)})联合熵反应了多个随机变量的平均信息量 H(X,Y)=\sum p(x,y)(-log_2^{p(x,y)})条件熵（Conditional entropy）反应了已知一个随机变量下，另一个随机变量的不确定性 H(X|Y)=-\sum p(y)H(X|Y=y)=-\sum p(x,y)log_2^{p(x|y)}互信息(mutual information)反应了已知一个随机变量的情况下，另外一个随机变量不确定性减少了多少,可以把互信息看成由于知道 y 值而造成的 x 的不确定性的减小 I(X;Y)=\sum \sum p(x,y)log(\frac{p(x,y)}{p(x)p(y)})\\ =H(X)-H(X|Y)=H(Y)-H(Y|X)如果两个随机变量独立，则互信息为0,因此，互信息可以衡量两个随机变量的相关程度 条件互信息在条件z发生时的条件互信息 I(X;Y|Z) = \sum\sum p(x,y|z)log_2^{\frac{p(x,y|z)}{p(x|z)p(y|z)}} 半朴素贝叶斯适当的考虑一部分属性间的相互依赖关系，这个关系可以用互信息描述 独依赖假设每个属性只有一个其他 的属性.则计算公式改下如下 p(C)\Pi_{i=1}^{d} P(x_i|C_i,pa_i)$pa_i$是属性$x_i$所依赖的属性，被称为$x_i$的父属性 1) SPODE 最简单的方法是：都选一个属性作为父属性 可以通过交叉验证的方法 2) TAN :最大带权生成树 权重：当y划分为$c_k$类时条件熵 I(x_i;y_i|y)=\sum_{x_i,y_i,c_k}p(x_i,y_j|c_k)log^{\frac{p(x_i;y_j|c_k)}{p(x_i|c_k)p(y_i|c_k)}}step 1: 计算任意两个属性之间条件互信息 I(X;Y|Y)=\sum_{i}I(X;Y|c_i)step 2: 以属性为结点构建完全图 step 3: 最大带权生成树，挑选根变量 step 4: 加入类别结点y,增加到每个属性的有向边 条件互信息反应了属性在已知类别下的相关性大小 集成学习AODE选择模型尝试将每个属性作为超父构建SPODE P(c_i|X)正比于 \sum_{i=1,|D_{x_i}>=m}p(c,x_i)\Pi_{j=1}^{d}p(x_j|c_i,x_i)$m$通常取30, P(c,x_i)=\frac{|D_{c,x_i}|+1}{|{D}|+N*N_i}\\ P(x_j|c,x_i)=\frac{|D_{c,x_i,x_j}+1|}{|D_{c,xi}|+N_j}贝叶斯网(Bayesian network)借助有向无环图来刻画属性之间的依赖关系，条件概率表来描述属性的联合概率分布。 一个贝叶斯网络$B$,包括结构$G$和参数$\Theta$ ,$B(G,\Theta)$,如果两个属性有直接依赖关系，用边连接，对于属性$x_i$,其父节点集合$G_i$,则$\Theta$包括每个属性条件概率$\Theta_{x_i|\pi_i}=P_B(x_i|\pi_i)$ 结构 p(x_1,x_2,...,x_n)=\Pi_{i=1}^{n}p_{B}(x_i|\pi_i)=\Pi_{i=1}^{d}\Theta_{xi|\pi_i}\\ =\Pi_{i=1}^{d}P(x_i|Parents(x_i))推断一旦训练好贝叶斯网后，就能回答query,通过一些属性的观测者来推断其他属性变量的取值，其中，已知变量的值观测推测待查询的过程“推断”,已知变量的观测者”证据“]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>贝叶斯分类器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次规划]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[[TOC] KKT(Karush-Kuhn-Tucher)条件 给定优化问题 \min f(x)\\ subject\ to \begin{cases} g_i(x) = 0 (i=1,,,,m\\ h_i(x) =0 (i=m+1,...,n)\\ \lambda_i h_i(x)=0(i=m+1,..,n)二次规划问题问题的数学表达 \min Q(x) = \frac{1}{2}x^THx+g^Tx\\ s.t. a_i^Tx = b_i (i=1,..,m)\\ \ \ \ \ \ \ \ a_i^Tx =x^{*T}H(x-x^{*})+g^T(x-x^{*})=\lambda^TA(x-x^{*})http://www.hankcs.com/ml/lagrange-duality.html#h3-7 SMO ：Sequential minimal optimization支持向量机的对偶问题 \min \frac{1}{2}\sum_{i=1}^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{m}\alpha_i\\ s.t. \sum_{i=1}^{m}\alpha_iy_i=0\\ 0]]></content>
      <categories>
        <category>机器学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>二次规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kaggle]]></title>
    <url>%2F2019%2F03%2F24%2Fkaggle%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn]]></title>
    <url>%2F2019%2F03%2F23%2Fscikit-learn%2F</url>
    <content type="text"><![CDATA[Cross-validation: evaluating estimator performance¶ 12345import numpy as npfrom sklearn.model_selection import train_test_split# 调用train_test_split函数 自动划分数据集 40%for testingX_train, X_test, y_train, y_test = train_test_split(iris.data,iris.target, test_size=0.4, random_state=0) corss validation 1234567from sklearn.model_selection import cross_validatefrom sklearn.metrics import recall_scorescoring = [&apos;precision_macro&apos;, &apos;recall_macro&apos;]clf = svm.SVC(kernel=&apos;linear&apos;, C=1, random_state=0)scores = cross_validate(clf, iris.data, iris.target, scoring=scoring, cv=5, return_train_score=False)sorted(scores.keys()) Cross validation of time series data Tuning the hyper-parameters of an estimatorA search consists of: an estimator (regressor or classifier such as sklearn.svm.SVC()); a parameter space; a method for searching or sampling candidates; a cross-validation scheme; and a score function. Grid Search1234param_grid = [ &#123;&apos;C&apos;: [1, 10, 100, 1000], &apos;kernel&apos;: [&apos;linear&apos;]&#125;, &#123;&apos;C&apos;: [1, 10, 100, 1000], &apos;gamma&apos;: [0.001, 0.0001], &apos;kernel&apos;: [&apos;rbf&apos;]&#125;, ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from __future__ import print_functionfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.model_selection import GridSearchCVfrom sklearn.metrics import classification_reportfrom sklearn.svm import SVCprint(__doc__)# Loading the Digits datasetdigits = datasets.load_digits()# To apply an classifier on this data, we need to flatten the image, to# turn the data in a (samples, feature) matrix:n_samples = len(digits.images)X = digits.images.reshape((n_samples, -1))y = digits.target# Split the dataset in two equal partsX_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.5, random_state=0)# Set the parameters by cross-validationtuned_parameters = [&#123;'kernel': ['rbf'], 'gamma': [1e-3, 1e-4], 'C': [1, 10, 100, 1000]&#125;, &#123;'kernel': ['linear'], 'C': [1, 10, 100, 1000]&#125;]scores = ['precision', 'recall']for score in scores: print("# Tuning hyper-parameters for %s" % score) print() clf = GridSearchCV(SVC(), tuned_parameters, cv=5, scoring='%s_macro' % score) clf.fit(X_train, y_train) print("Best parameters set found on development set:") print() print(clf.best_params_) print() print("Grid scores on development set:") print() means = clf.cv_results_['mean_test_score'] stds = clf.cv_results_['std_test_score'] for mean, std, params in zip(means, stds, clf.cv_results_['params']): print("%0.3f (+/-%0.03f) for %r" % (mean, std * 2, params)) print() print("Detailed classification report:") print() print("The model is trained on the full development set.") print("The scores are computed on the full evaluation set.") print() y_true, y_pred = y_test, clf.predict(X_test) print(classification_report(y_true, y_pred)) print()# Note the problem is too easy: the hyperparameter plateau is too flat and the# output model is the same for precision and recall with ties in quality. Randomized Parameter Optimization123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566print(__doc__)import numpy as npfrom time import timefrom scipy.stats import randint as sp_randintfrom sklearn.model_selection import GridSearchCVfrom sklearn.model_selection import RandomizedSearchCVfrom sklearn.datasets import load_digitsfrom sklearn.ensemble import RandomForestClassifier# get some datadigits = load_digits()X, y = digits.data, digits.target# build a classifierclf = RandomForestClassifier(n_estimators=20)# Utility function to report best scoresdef report(results, n_top=3): for i in range(1, n_top + 1): candidates = np.flatnonzero(results['rank_test_score'] == i) for candidate in candidates: print("Model with rank: &#123;0&#125;".format(i)) print("Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)".format( results['mean_test_score'][candidate], results['std_test_score'][candidate])) print("Parameters: &#123;0&#125;".format(results['params'][candidate])) print("")# specify parameters and distributions to sample fromparam_dist = &#123;"max_depth": [3, None], "max_features": sp_randint(1, 11), "min_samples_split": sp_randint(2, 11), "bootstrap": [True, False], "criterion": ["gini", "entropy"]&#125;# run randomized searchn_iter_search = 20random_search = RandomizedSearchCV(clf, param_distributions=param_dist, n_iter=n_iter_search, cv=5)start = time()random_search.fit(X, y)print("RandomizedSearchCV took %.2f seconds for %d candidates" " parameter settings." % ((time() - start), n_iter_search))report(random_search.cv_results_)# use a full grid over all parametersparam_grid = &#123;"max_depth": [3, None], "max_features": [1, 3, 10], "min_samples_split": [2, 3, 10], "bootstrap": [True, False], "criterion": ["gini", "entropy"]&#125;# run grid searchgrid_search = GridSearchCV(clf, param_grid=param_grid, cv=5)start = time()grid_search.fit(X, y)print("GridSearchCV took %.2f seconds for %d candidate parameter settings." % (time() - start, len(grid_search.cv_results_['params'])))report(grid_search.cv_results_) step1： 交叉验证（评价模型） step2: 超参数选择，每一组参数：对应一次交叉验证 step 3: 集成学习 也可进行参数的调解 12345678from sklearn.model_selection import cross_val_scorefrom sklearn.datasets import load_irisfrom sklearn.ensemble import AdaBoostClassifieriris = load_iris()clf = AdaBoostClassifier(n_estimators=100)scores = cross_val_score(clf, iris.data, iris.target, cv=5)scores.mean() 1234567891011121314151617181920212223from sklearn import datasetsfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.svm import SVCfrom itertools import productfrom sklearn.ensemble import VotingClassifier# Loading some example datairis = datasets.load_iris()X = iris.data[:, [0, 2]]y = iris.target# Training classifiersclf1 = DecisionTreeClassifier(max_depth=4)clf2 = KNeighborsClassifier(n_neighbors=7)clf3 = SVC(gamma=&apos;scale&apos;, kernel=&apos;rbf&apos;, probability=True)eclf = VotingClassifier(estimators=[(&apos;dt&apos;, clf1), (&apos;knn&apos;, clf2), (&apos;svc&apos;, clf3)], voting=&apos;soft&apos;, weights=[2, 1, 2])clf1 = clf1.fit(X, y)clf2 = clf2.fit(X, y)clf3 = clf3.fit(X, y)eclf = eclf.fit(X, y)]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boosting]]></title>
    <url>%2F2019%2F03%2F22%2FBoosting%2F</url>
    <content type="text"><![CDATA[[TOC] Boosting原理Boosting算法是将“弱学习算法“提升为“强学习算法”的过程。 加法模型 F_n(x;P) = \sum_{t=1}^{n}\alpha_th_t(x;a_t) 前向分步 F_m(x) = F_{m-1}(x)+\alpha_mh_m(x,a_m)如果选取不同损失函数，则产生不同的类型 AdaBoostAdaBoost就是损失函数为指数损失的Boosting算法。 每一次迭代的弱学习$h(x;a_m)$有何不一样，如何学习？ AdaBoost改变了训练数据的权值，也就是样本的概率分布，其思想是将关注点放在被错误分类的样本上，减小上一轮被正确分类的样本权值，提高那些被错误分类的样本权值。 弱分类器权值$β_m$如何确定？ AdaBoost采用加权多数表决的方法，加大分类误差率小的弱分类器的权重，减小分类误差率大的弱分类器的权重。这个很好理解，正确率高分得好的弱分类器在强分类器中当然应该有较大的发言权。 原理理解基于Boosting的理解，对于AdaBoost，我们要搞清楚两点： 每一次迭代的弱学习h(x;am)有何不一样，如何学习？弱分类器权值βm如何确定？对于第一个问题，AdaBoost改变了训练数据的权值，也就是样本的概率分布，其思想是将关注点放在被错误分类的样本上，减小上一轮被正确分类的样本权值，提高那些被错误分类的样本权值。然后，再根据所采用的一些基本机器学习算法进行学习，比如逻辑回归。 对于第二个问题，AdaBoost采用加权多数表决的方法，加大分类误差率小的弱分类器的权重，减小分类误差率大的弱分类器的权重。这个很好理解，正确率高分得好的弱分类器在强分类器中当然应该有较大的发言权。 公式推导指数损失函数 L(Y,f(x))=exp(-Yf(x))权重更新公式: 采用的指数误差函数 l_{exp}(a_th_t|D_t)=E(exp(-f(x)a_th_t(x)))\\ =p(f(x)=h_t(x))e^{-at}+p(f(x)!=h_t(x))e^{at}\\ =e^{-at}(1-\xi)+e^{at}\xi a_t=\frac{1}{2}ln \frac{1-\xi}{\xi}分布更新公式 \begin{aligned} l\left(H_{t-1}(x)+\alpha h_{t}(x) | D\right) &=E_{X \sim D}\left(\exp \left(-y(x)\left(H_{t-1}(x)+\alpha h_{t}(x)\right)\right)\right) \\ &=E_{x \sim D}\left(\exp \left(-y(x) H_{t-1}(x)\right) \exp \left(-y(x) \alpha h_{t}(x)\right)\right) \end{aligned}在泰勒展开$exp(-y(x)h_t(x))$ \begin{aligned} l\left(H_{t-1}(x)+h_{t}(x) | D\right) & \approx E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right)\left(1-\alpha y(x) h_{t}(x)+\frac{\alpha^{2} y^{2}(x) h_{t}^{2}(x)}{2}\right)\right] \\ &=E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right)\left(1-y(x) h_{t}(x)+0.5 \alpha^{2}\right)\right] \end{aligned} \begin{aligned} h(x) &=\arg \min _{h} l\left(H_{t-1}(x)+\alpha h_{t} | D\right) \\ &=\arg \max _{h} E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right) \alpha y(x) h_{t}(x)\right] \\ &=\arg \max _{h}\left[\frac{\exp \left(-y(x) H_{t-1}(x)\right)}{E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right)\right]} y(x) h(x)\right] \end{aligned} 令一个新分布,注意分子是常数 D_{t}(x)=\frac{D(x) \exp \left(-y(x) H_{t-1}(x)\right)^{L}}{E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right)\right]} \begin{aligned} h(x) &=\arg \max _{h} E_{x \sim D,}(y(x) h(x)) \\ &=\arg \max _{h} E_{x \sim D_{t}}(1-2 \mathcal{I}(y(x) \neq h(x))) \\ &=\arg \min _{h} E_{x \sim D_{i}}(\mathcal{I}(y(x) \neq h(x))) \end{aligned}同理可得 \begin{aligned} D_{t+1} &=\frac{D(x) \exp \left(-y(x) H_{t}(x)\right)}{E_{x \sim D}\left[\exp \left(-y(x) H_{t}(x)\right)\right]} \\ &=\frac{D_{t}(x) \cdot E_{x \sim D}\left[\exp \left(-y(x) H_{t-1}(x)\right)\right] \cdot \exp \left(-y(x) H_{t}(x)\right)}{\exp \left(-y(x) H_{t-1}(x)\right) \cdot E_{x \sim D}\left[\exp \left(-y(x) H_{t}(x)\right)\right]} \\ &=D_{t}(x) \exp \left(-y(x) \alpha h_{t}(x)\right) \cdot C . \quad(C i s a \text {constant}) \end{aligned} Z_{t}=\sum_{i}^{m} D_{t}(x) \exp \left(-y(x) \alpha_{t} h_{y}(x)\right)指数误差函数 \begin{aligned} l(H(x) | D) &=\frac{1}{m} \sum_{i}^{m} \exp \left(-y_{i} H\left(x_{i}\right)\right) \\ &=\frac{1}{m} \sum_{i}^{m} \exp \left(-\sum_{j}^{T} \alpha_{j} y_{i} h_{j}\left(x_{i}\right)\right) \\ &=\sum_{i}^{m} D_{1}\left(x_{i}\right) \exp \left(-\sum_{j}^{T} \alpha_{j} y_{i} h_{j}\left(x_{i}\right)\right) \\ &=Z_{1} Z_{2}\left(x_{i}\right) \exp \left(-\sum_{j=2}^{T} \alpha_{j} y_{i} h_{j}\left(x_{i}\right)\right) \\ & \vdots \\ &=\prod_{i=1}^{T} Z_{i} \end{aligned}算法描述总结一下，得到AdaBoost的算法流程： 输入：训练数据集$T={(x1,y1),(x2,y2),(xN,yN)}T={(x1,y1),(x2,y2),(xN,yN)}$，其中，$xi∈X⊆Rnxi∈X⊆Rn，yi∈Y=−1,1yi∈Y=−1,1，$迭代次数M 初始化训练样本的权值分布：$D1=(w1,1,w1,2,…,w1,i),w,i=1,2,…,N$。 对于$m=1,2,…,M$ (a) 使用具有权值分布$D_m$的训练数据集进行学习，得到弱分类器$h_m(x)$ (b) 计算$h_m(x)$在训练数据集上的分类误差率： $e_m=∑_{i=1}^{N}w_m,iI(h_m(xi)≠y_i)$ (c) 计算$h_m(x)$在强分类器中所占的权重： $\alpha_m=\frac{1}{2}log(\frac{1−e_m}{e_m})$ (d) 更新训练数据集的权值分布（这里，$z_m是归一化因子，为了使样本的概率分布和为1）： w_{m+1,i}=\frac{w_{m,i}}exp(−α_my_ih_m(xi))，i=1,2,…,10z_m=∑_{i=1}^{N}w_{m,i}exp(−α_my_ih_m(xi)) 得到最终分类器： F(x)=sign(∑_{i=1}^{N}α_mh_m(x))面经今年8月开始找工作，参加大厂面试问到的相关问题有如下几点： 手推AdaBoost 与GBDT比较 AdaBoost几种基本机器学习算法哪个抗噪能力最强，哪个对重采样不敏感？ 算法流程实例计算Python实现https://www.cnblogs.com/davidwang456/articles/8927029.html 集成学习]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Boosting, AdaBoost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持向量回归]]></title>
    <url>%2F2019%2F03%2F19%2FSVR%2F</url>
    <content type="text"><![CDATA[[TOC] 支持向量机用于分类:硬间隔和软件间隔支持向量机。尽可能分对 支持向量机回归： 希望$f(x)$与$y$尽可能的接近。 支持向量机基本思想英文名:support vector regression 简记：SVR 标准的线性支持向量回归模型学习的模型: f(x)=w^Tx+b假设能容忍$f(x)$与$y$之间差别绝对值$\xi$,这就以$f(x)=w^Tx+b$形成了一个$2\xi$的间隔带，因此模型 \min \frac{1}{2}w^Tw\\ s.t -\xi]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>支持向量机回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持向量机(SVM) ----- 分类器]]></title>
    <url>%2F2019%2F03%2F17%2FSVMClassifiar%2F</url>
    <content type="text"><![CDATA[[TOC] 预备的数学知识约束优化问题原问题,带等式约束，也带不等式约束的一般约束问题 \begin{cases} \min_{x}f(x)\\ s.t \begin{cases} m_i(x)>=0, i=1,..,m\\ n_j(x)=0，j=1,..,m\\ \end{cases} \end{cases}\tag{1}构造lagrange乘子法 L(x,\lambda_i,\eta_j)= f(x)-\sum_{i=1}^{m}\lambda_im_i(x)-\sum_{j=1}^{n}\eta_j \tag{2} \begin{cases} \min_{x} max_{\lambda_i,\eta_j} L(R^p)\\ s.t \lambda_i>=0 \end{cases}上述两个问题的等价性证明 如果x不满足约束$m_i(x)$,则$\lambda_i&gt;=0$,同时$m_i(x)&lt;$,则$L(R^{p},\lambda,\eta)$趋近无穷，反之，则存在最大值 min_{x} max_{\lambda,\eta}=min_{x}(max f满足条件,max f不满足约束)\\=min_{x} max_{\lambda,\eta}{f满足条件}对偶问题: 关于$\lambda,\eta$的最大化问题 max min L(x,\lambda,\eta)\\ s.t \lambda_i>=0弱对偶问题：对偶问题&lt;=原问题 证明: $max_{x} min(\lambda \eta ) L&lt;=min_{\eta,\lambda } max_{x} L$ \underbrace{\min_{x}L(x,\lambda,\eta)}_{A(\lambda,\eta)}0\end{cases}注意，$y_i(w^Tx_i+b)&gt;0$,所以$\exists r&gt;0, min(y_i(w^Tx_i+b))=r$,可令$r=1$,这是对超平面范数的固定作用，因为$y=w^Tx+b$和$y=2w^T+2b$是同一个超平面，总能找到缩放$w,b$使得，可以将$r$缩放到1 \Longrightarrow\begin{cases} max \frac{1}{||w||}\\ st. y_i(w^Tx_i+b)>=1\end{cases}\Longrightarrow\begin{cases} \min \frac{1}{2}w^Tw\\ st. y_i(w^Tx_i+b)>=1\end{cases}这是一个土二次规划问题 第二宝 对偶利用lagrange乘子法得出对偶问题 带约束 \begin{cases} \min \frac{1}{2}w^Tw\\ st. y_i(w^Tx_i+b)-1>=0\end{cases}\Longrightarrow L(w,b,\lambda）=\frac{1}{2}w^Tw-\sum_{i=1}^{N}\lambda_i(1-y_i(w^Tx_i+b)无约束 \begin{cases}min_{w,b} max_{\lambda}L(w,b,\lambda) \\ s.t \lambda_i>=0\end{cases}此时关于$w,b$无约束的。 对$(L(w,b,\lambda))$ 对$w$,$b$求偏导 \frac{\partial L}{\partial w}=w+\sum_{i=1}^{N}y_ix_i\lambda_i=0 \Longrightarrow w=-\sum_{i=1}^{N}y_ix_i\lambda_i\\ \frac{\partial L}{\partial b}=-\sum_{i=1}^{N}\lambda_iy_i=0带回$L(w,b,\lambda)$,可得对偶问题 \begin{cases} max_{\lambda}L(w,b,\lambda ) =-\frac{1}{2}\sum_i^N\sum_j^N\lambda_i \lambda_jy_iy_jx_i^Tx_j +\sum_i^N\lambda_i \\ s .t. \sum_{i=1}^N\lambda_iy_i,\lambda_i>=0\end{cases} \Longrightarrow\\\begin{cases} min_{\lambda}L(w,b,\lambda ) =\frac{1}{2}\sum_i^N\sum_j^N\lambda_i \lambda_jy_iy_jx_i^Tx_j -\sum_i^N\lambda_i \\ s .t. \sum_{i=1}^N\lambda_iy_i,\lambda_i>=0\end{cases}原问题和对偶问题有相同解的充要条件满足 KKT \begin{cases} \frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0,\frac{\partial L}{\partial \lambda}=0\\ \lambda_i(y_i(w^Tx_i+b)-1)=0\\ \lambda_i>=0\\ y_i(w^Tx_i+b)-1>=0 \end{cases}如果存在$(x_k,y_k)=+1or -1$使得$y_i(w^Tx_i+b)-1=0$即可求解$b=y_k-\sum_{i=0}^{N}\lambda_ix_i^Tx_k$ 代入模型 f(x)=sign(\sum_i^Na_iy_ix_i^Tx+y_k-\sum_{i=0}^{N}\lambda_ix_i^Tx_k)注意，对于任意的训练样本，总有$\lambda_i=0$或者$y_if(x_i)=1$,如果$\lambda_i&gt;0$,说明样本点落在最大间隔的边界上，这些点就是支持向量，这条边界$w^Tx+b=1or-1$ soft-marign 软间隔 想法：允许一部分样本可以不被正确分类 优化目标 \min_{w,b} \frac{1}{2}w^Tw+loss一些损失函数 0-1损失 个数 loss=\sum_{i=1}^NI\{y_i(w^Tx+b)=0,\\ 1-y_i(w^tx_i+b), y_i(w^Tx_i+b)=1-\xi_i\\ \xi_i>=0 \end{cases} 指数损失（exponential loss ) l_{exp}(z)=exp(-z) 对率损失logistic loss l_{log}(z)=log(1+exp(-z)） 核方法核函数的定义设 $\chi$为输入空间（Input Space）， $\mathrm{H}$为特征空间(Feature Space,一定是希尔伯特空间），存在一个映射 \varphi : \chi \rightarrow \mathrm{H}对任意的 $x, y \in \mathrm{X}$，函数 $K(x, y)$，满足 K(x, y)=则称 $K(x, y)$为核函数。可以看出，我们并不需要知道输入空间和特征空间满足的映射关系 ，只需要知道核函数就可以算出，输入空间中任意两点映射到特征空间的内积。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回归树]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%9B%9E%E5%BD%92%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 分类树与回归树分类树用于分类问题。分类决策树在选取划分点，用信息熵、信息增益、或者信息增益率、或者基尼系数为标准。Classification tree analysis is when the predicted outcome is the class to which the data belongs. 回归决策树用于处理输出为连续型的数据。回归决策树在选取划分点，就希望划分的两个分支的误差越小越好。 Regression tree analysis is when the predicted outcome can be considered a real number (e.g. the price of a house, or a patient’s length of stay in a hospital)。 回归树英文名字：Regression Tree 原理介绍决策树最直观的理解其实就是，输入特征空间($R^n$)，然后对特征空间做划分，每一个划分属于同一类或者对于一个输出的预测值。那么这个算法需要解决的问题是1. 如何决策边界(划分点)？2. 尽可能少的比较次数(决策树的形状) 如上图，每一个非叶子对于某个特征的划分。 最小二乘回归树生成算法Q1: 选择划分点？遍历所有的特征($n$),对于每一个特征对应$s_i$个取值，尝试完所有特征，以及特征所以有划分，选择使得损失函数最小的那组特征以及特征的划分取值。 Q2: 叶节点的输出？取每个区域所以结果的平均数作为输出 节点的损失函数的形式 \min _{j, s}\left[\min _{c_{1}} Loss(y_i,c_1)+\min _{c_{2}} Loss(y_i,c_2)\right]节点有两条分支，$c1$是左节点的平均值，$c2$是右节点的平均值，换句话说，分一次划分都是使得划分出的两个分支的误差和最小。最终得到函数是分段函数 CART算法输入： 训练数据集 输出：回归树$f(x)$ 选择最优的特征$j$和分切点$s$ \min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right] 对于选定的$(j,s)$划分区域，并确定该区域的预测值 对两个区域递归1. 2. 直到满足停止条件 返回生成树 注：分切点选择：先排序，二分。 Python代码节点类属性：左右节点、loss、特征编号或者特征、分割点 12345678class Node(object): def __init__(self, score=None): # 构造函数 self.score = score self.left = None self.right = None self.feature = None self.split = None 回归树类构造方法 1234class RegressionTree(object): def __init__(self): self.root = Node() self.height = 0 给定特征、划分点，返回计算MAPE 12345678910111213141516def _get_split_mse(self, X, y, idx, feature, split): ''' X:训练样本输入 y:训练样本输出 idx:该分支对应的样本编号 feaure: 特征 split: 划分点 ''' split_x1=X[X[idex,feature]&lt;split] split_y1=y[X[idex,feature]&lt;split] split_x2=X[X[idex,feature]&gt;=split] split_y2=y[X[idex,feature]&gt;=split] split_avg = [np.mean(split_y1), np.mean(split_y2)] split_mape = [np.sum((split_y1-split_avg[0])**2),np.sum((split_y2-split_avg[1])**2)] return split_mse, split, split_avg 计算给定特征的最佳分割点 遍历特征某一列的所有的不重复的点，找出MAPE最小的点作为最佳分割点。如果特征中没有不重复的元素则返回None。 12345678910def _choose_split_point(self, X, y, idx, feature): feature_x = X[idx,feature] uniques = np.unique(feature_x) if len(uniques)==1: return Noe mape, split, split_avg = min( (self._get_split_mse(X, y, idx, feature, split) for split in unique[1:]), key=lambda x: x[0]) return mape, feature, split, split_avg 选择特征遍历全部特征，计算mape,然后确定特征和对应的切割点，注意如果某个特征的值是一样的，则返回None12345678910111213141516171819def _choose_feature(self, X, y, idx): m = len(X[0]) split_rets = [x for x in map(lambda x: self._choose_split_point( X, y, idx, x), range(m)) if x is not None] if split_rets == []: return None _, feature, split, split_avg = min( split_rets, key=lambda x: x[0]) idx_split = [[], []] while idx: i = idx.pop() xi = X[i][feature] if xi &lt; split: idx_split[0].append(i) else: idx_split[1].append(i) return feature, split, split_avg, idx_split 对应叶子节点，打印相关的信息1234def _expr2literal(self, expr): feature, op, split = expr op = "&gt;=" if op == 1 else "&lt;" return "Feature%d %s %.4f" % (feature, op, split) 建立好二叉树以后，遍历操作12345678910111213141516171819def _get_rules(self): que = [[self.root, []]] self.rules = [] while que: nd, exprs = que.pop(0) if not(nd.left or nd.right): literals = list(map(self._expr2literal, exprs)) self.rules.append([literals, nd.score]) if nd.left: rule_left = [] rule_left.append([nd.feature, -1, nd.split]) que.append([nd.left, rule_left]) if nd.right: rule_right =[] rule_right.append([nd.feature, 1, nd.split]) que.append([nd.right, rule_right]) 建立二叉树的过程，也就是训练的过程 控制深度 控制节叶子节点的最少样本数量 至少有一个特征是不重复的12345678910111213141516171819202122232425def fit(self, X, y, max_depth=5, min_samples_split=2): self.root = Node() que = [[0, self.root, list(range(len(y)))]] while que: depth, nd, idx = que.pop(0) if depth == max_depth: break if len(idx) &lt; min_samples_split or set(map(lambda i: y[i,0], idx)) == 1: continue feature_rets = self._choose_feature(X, y, idx) if feature_rets is None: continue nd.feature, nd.split, split_avg, idx_split = feature_rets nd.left = Node(split_avg[0]) nd.right = Node(split_avg[1]) que.append([depth+1, nd.left, idx_split[0]]) que.append([depth+1, nd.right, idx_split[1]]) self.height = depth self._get_rules() 打印叶子节点12345def print_rules(self): for i, rule in enumerate(self.rules): literals, score = rule print("Rule %d: " % i, ' | '.join( literals) + ' =&gt; split_hat %.4f' % score) 预测单样本 123456789101112def _predict(self, row): nd = self.root while nd.left and nd.right: if row[nd.feature] &lt; nd.split: nd = nd.left else: nd = nd.right return nd.score # 预测多条样本def predict(self, X): return [self._predict(Xi) for Xi in X] 1234567891011121314 def main(): print("Tesing the accuracy of RegressionTree...") X_train=np.array([[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]) y_train=np.array([[5.56 ],[5.7],[5.91],[6.4 ],[6.8],[7.05],[8.9],[8.7 ],[9 ],[9.05]]) reg = RegressionTree() print(reg) reg.fit(X=X_train, y=y_train, max_depth=3) reg.print_rules()main() 简单的例子训练数据 x 1 2 3 4 5 6 7 8 9 10 y 5.56 5.7 5.91 6.4 6.8 7.05 8.9 8.7 9 9.05 根据上表，只有一个特征$x$. 选择最优的特征$j$和分切点$s$ | 分切点(s) | 1.5 | 2.5 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 8.5 | 9.5 || ————- | ——- | ——- | —— | —— | —— | —— | —— | ——- | ——- || $c_1$ | 5.56 | 5.63 | 5.72 | 5.89 | 6.07 | 6.24 | 6.62 | 6.88 | 7.11 || $c_2$ | 7.5 | 7.73 | 7.99 | 8.25 | 8.54 | 8.91 | 8.92 | 9.03 | 9.05 || loss | 15.72 | 12.07 | 8.36 | 5.78 | 3.91 | 1.93 | 8.01 | 11.73 | 15.74 | 当分切点取$s=6.5$,损失最小$l(s=6.5)=1.93$,此时划分出两个分支，分别是$R_1=\{1,2,3,4,5,6\}$,$c_1=6.42$,$R_2=\{7,8,9,10\}$,$c_2=8.91$ a) 对R1继续划分 | x | 1 | 2 | 3 | 4 | 5 | 6 || —— | —— | —— | —— | —— | —— | —— || y | 5.56 | 5.7 | 5.91 | 6.4 | 6.8 | 7.05 | | 分切点(s) | 1.5 | 2.5 | 3.5 | 4.5 | 5.5 || ————- | ——— | ——- | ——— | ——— | ——— || $c_1$ | 5.56 | 5.63 | 5.72 | 5.89 | 6.07 || $c_2$ | 6.37 | 6.54 | 6.75 | 6.93 | 7.05 || loss | 1.3087 | 0.754 | 0.2771 | 0.4368 | 1.0644 | 当分切点取$s=3.5$,损失函数$l(s=3.6)=0.2771$(假设此时满足停止条件）,此时得到两个分支，分别是$R_1=\{1,2,3\}$，$c_1=5.72$,$R_2={4,,5,6}$,$c_2=6.75$ b) 对R2继续划分 | x | 7 | 8 | 9 | 10 || —— | —— | —— | —— | —— || y | 8.9 | 8.7 | 9 | 9.05 | | 分切点(s) | 7.5 | 8.5 | 9.5 || ————- | ——— | ——— | ——— || $c_1$ | 8.9 | 8.8 | 8.87 || $c_2$ | 8.92 | 9.03 | 9.05 || loss | 0.0717 | 0.0213 | 0.0467 | 当分切点取$s=8.5$,损失函数$l(s=8,5)=0.0213$(假设此时满足停止条件）,此时得到两个分支，分别是$R_1=\{7,8\}$，$c_1=8.8$,$R_2=\{9,10\}$,$c_2=9.03$ 函数表达式 $$ \begin{equation} f(x)=\left\{ \begin{aligned} 5.72 &amp; &amp; x&lt;3.5\\ 6.7 5&amp; &amp;3.5&lt;=x&lt;6.5\\ 8.8&amp; &amp;6.5&lt;=x&lt;8.5\\ 9.03&amp; &amp;8.5&lt;=x&lt;10\\ \end{aligned} \right. \end{equation} $$ Python库1class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False) 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-"""Created on Wed Mar 13 19:59:53 2019@author: 23230"""import numpy as npfrom sklearn.tree import DecisionTreeRegressorimport matplotlib.pyplot as pltX=np.array([[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]])y=np.array([[5.56 ],[5.7],[5.91],[6.4],[6.8],[7.05],[8.9],[8.7],[9 ],[9.05]])# Fit regression modelregr_1 = DecisionTreeRegressor(max_depth=2)regr_2 = DecisionTreeRegressor(max_depth=3)regr_3 = DecisionTreeRegressor(max_depth=4)regr_1.fit(X, y)regr_2.fit(X, y)regr_3.fit(X, y)X_test = np.copy(X)y_1 = regr_1.predict(X_test)y_2 = regr_2.predict(X_test)y_3 = regr_3.predict(X_test) # Plot the resultsplt.figure()plt.scatter(X, y, s=20, edgecolor="black",c="darkorange", label="data")plt.plot(X_test, y_1, color="cornflowerblue",label="max_depth=2", linewidth=2)plt.plot(X_test, y_2, color="yellowgreen", label="max_depth=4", linewidth=2)plt.plot(X_test, y_3, color="r", label="max_depth=8", linewidth=2)plt.xlabel("data")plt.ylabel("target")plt.title("Decision Tree Regression")plt.legend()]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>回归树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP算法]]></title>
    <url>%2F2019%2F03%2F05%2FBP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 需要的微积分知识1.1 导数对于一元函数，在导数存在的情况下，在某一点的导数，也就是该点的斜率。对于多元函数，对于某一点求导，则需要指明方向，两个特殊的方向，1. 偏导：在坐标轴方向的导数 2. 梯度的方向:总有一个方向是变化最快的。 1.2 求导的链式法则 $x \in R$, $z=g(f(x))$, $y=f(x)$ \frac{\partial z}{\partial x}=\frac{\partial z}{\partial y} \frac{\partial y}{\partial x} $ x \in R^m $, $f(x)$是$R^M$到$R^n$的映射，$g(f)$是$R^n$到R的映射 \frac{\partial g}{\partial x_i}=\sum_j^n \frac{\partial g}{\partial f_i} \frac{\partial f_i}{\partial x_i} 如果使用向量表示 \nabla_x^z=(\frac{\partial f}{\partial x})^T \nabla_y^z2. 梯度下降法2.1 梯度梯度其实本质也是一个向量，对于函数$f(X,y)$在$(W,y)$这一点的梯度 $(\frac{\partial f}{\partial X},\frac{\partial f}{\partial y})$梯度的几何意义：在该店变化增加最快的地方 2.2 梯度算法的解释图来自吴恩达的机器学习课程颜色偏红(A)的地方开始，根据梯度的负方向通过9次更新，达到了最小值(B)。现在给定一个点$A(\theta_0,\theta_1)$,干嘛呢，我们想从A到B点（最小值点),类似人类下山，需要知道往那个方向吧、走大多一步呢？方向：梯度的负方向 $ \delta=(\frac{\partial L}{\partial \theta_0},\frac{\partial L}{\partial \theta_1})$)步长：学习率（$\alpha$)因此，计算一次里目标更近了 $(\theta_0,\theta_1)=(\theta_0,\theta_1)-\alpha \dot (\delta)$在重复上两步，直到满意为止。 3.误差反向传播算法3.1 理论推导 3.1.1 符号说明上图是一个L层的神经网络，输入层为第一层，隐藏层：2至$L-1$层，输出层L 令 输入向量 $\vec{X}$ \vec{X} = (x_1,x_2,...,x_{m-1},x_m)输出向量 $\vec{Y}$ \vec{Y}=(y_1,y_2,...,y_{n-1},y_n)$$a 第j层隐藏层的输出向量 $\vec{h^{(j)}}$ $$\vec{h^{(j)}}=(h_1^{(j)},h_2^,...,h_{t-1}^{(j)},h_tj^{(j)})其中，$tj$:表示第j的隐藏层个数第$(l-1)$层的第i个神经元到第$l$层的第j个神经元的连接权重：$w_{ij}^{(l)}$，则第$(l-1)$层神经元到第$l$层神经元的连接权重矩阵 W^{(l)}=\left( \begin{matrix}w_{11}^{(l)}& \cdots & w_{1(tj)}\\ & \dots &\\ w_{s(l-1)}^{l}&\cdots&w_{s(l-1)s(l)}^{l} \end{matrix}\right)3.1.2 推导过程3.1.2.1 误差定义的误差函数,常见的衡量性指标见 戳我,这里选择的误差平方和最小第$i$个输出的误差,假设实际输出$(d(1),d(2),…,d(n))$：,一个输入样本对应的误差 E(i)=\frac{1}{2}\sum_{k=1}^n(y(i)-d(i))^2=\frac{1}{2}||y-d||^2所有训练样本($N$)的误差： E(i)=\frac{1}{2}\sum_{j=1}^{N}(\sum_{k=1}^n(y(i)-d(i))^2)=\frac{1}{2N}\sum_{j=1}^{N}(||y(i)-d(i)||^2)因此， E = \frac{1}{2N}\sum_{i=1}^N(||y(i)-d(i)||^2)其实，神经网络的输出是关于节点的复合函数。代价函数是关于$W$和$b$的函数。 3.1.2.2 正向传播输入层$\hat{X}$： X =(x_1,x_2,x_3,...,x_m)当有$N$个训练样本时，可用矩阵表示 X=\left( \begin{matrix} x_{11} &x_{12}&...&x_{1m}\\ x_{21} & x_{22}&...&x_{2m}\\ \vdots & \vdots&\dots&\vdots\\ x_{N1} & \vdots&\vdots&x_{Nm}\\ \end{matrix} \right)第二层 $h^{(2)}$,一共$s2$个节点:第i个节点的计算 h^{(2)}(i)=f(\sum_{j=1}^{s2}x(j)*w_{ji}^{(l)}+b_i)=f(x*w(:,i)+b_i)矩阵表示 h^{(2)}=f(x*W^{(l)}+b^{(2)})第i层 矩阵形式 h^{(l)}=f(h^{(l-1)}*W^{(l)}+b)3.1.2.3 反向传播梯度下降法更新权重，不断迭代到最优解。对$w_{ij}$求导数可得,可更新$w_{ij}$更新公式： w_{ij}=w_{ij}-\alpha \frac{\partial E}{\partial w_{ij}}当然简单的情况下，可直接写出公式，当太复杂的时候，引入BP简化求导 方便书写公式，对于第i的输入$h^{(i-1)}*W^{(i)}+b^{(i)}$记作$net^{(i)}$,其中，第$i$的输入和输出的关系，$输入=f(输出)$下面开始推导 首先，对于$L$层， 对于$W^{(L)}$，先看对$W_{ij}^{(L)}$求导， \frac{\partial E}{\partial W_{ij}^{(L)}} =\frac{\partial E}{\partial y(j)} * \frac{\partial y(i)}{\partial net_{j}^{L}} * \frac{\partial net_{j}^{L}}{\partial W_{ij}^{(L)}}\\ =(y(j)-d(j))*f(x)^{'}|_{x=net_j^{(L)}}h_i^{(L-1)}令$\delta_i^{(L)}=y(i)-d(i)$ 上述给出了单个分量的求偏导的结果，对于$W^{(L)}$ \frac{\partial E}{\partial W^{(L)}} =\left[\begin{matrix} \frac{\partial E}{\partial W_{11}^{(L)}} & \frac{\partial E}{\partial W_{12}^{(L)}}&\dots & \frac{\partial E}{\partial W_{1n}^{(L)}}\\ \frac{\partial E}{\partial W_{21}^{(L)}} & \frac{\partial E}{\partial W_{22}^{(L)}}&\dots& \frac{\partial E}{\partial W_{2n}^{(L)}}\\ \vdots& \dots& \dots& \dots\\ \frac{\partial E}{\partial W_{sL,1}^{(L)}} & \frac{\partial E}{\partial W_{sL,2}^{(L)}}&\dots& \frac{\partial E}{\partial W_{sL,n}^{(L)}} \end{matrix}\right] \\= \left[ \begin{matrix} h^{(L-1)}_1\\h^{(L-1)}_2\\ \dots\\h^{(L-1)}_n \end{matrix} \right] *\left[\begin{matrix} \delta_1^{(L)}f(x)^{'}|_{x=net_1^{(L)}}\\ \delta_2^{(L)}f(x)^{'}|_{x=net_2^{(L)}}\\ \dots\\ \delta_n^{(L)}f(x)^{'}|_{x=net_n^{(L)}} \end{matrix}\right] ^T =h^{(L-1)}S^{(L)}其中， S^{(L)}=\left[\begin{matrix} \delta_1^{(L)}f(x)^{'}|_{x=net_1^{(L)}}\\ \delta_2^{(L)}f(x)^{'}|_{x=net_2^{(L)}}\\ \dots\\ \delta_n^{(L)}f(x)^{'}|_{x=net_n^{(L)}} \end{matrix}\right]^T同理可得， \frac{\partial E}{\partial b_k^{(L)}}=(y(j)-d(j))*f(x)^{'}|_{x=net_j^{(L)}}其次，对于隐含层$L-1$层，对$W_{ij}^{(L)}$求导 \frac{\partial E}{\partial W_{ij}^{(L-1)}} =\sum_{k=1}^{n}\frac{\partial E}{\partial y(k)} * \frac{\partial y(k)}{\partial net_{k}^{L}} * \frac{\partial net_{k}^{L}}{\partial f(net_j^{(L-1)})}*\frac{\partial f(net_j^{(L-1)})}{\partial net_j^{(L-1)}}*\frac{\partial net_j^{(L-1)}}{\partial W_{ij}^{(L-1)}}\\ =\sum_{k=1}^{n} (y(j)-d(j))*f(x)^{'}|_{x=net_j^{(L)}}W_{kj}^{(L)}f(x)^{'}|_{x=net_j^{L-1}}h_i^{L-2}\\ =\sum_{k=1}^{n}S_i^{(L)}W_{kj}^{(L)}f(x)^{'}|_{x=net_j^{L-1}}h_i^{L-2}\\写出矩阵形式,对$W^{(L-1)}$ \frac{\partial E}{\partial W^{(L-1)}}=\left[\begin{matrix} h^{(L-2)}_1\\h^{(L-2)}_2\\\vdots\\h^{(L-2)}_{s(L-2)}\end{matrix}\right] \left[\begin{matrix} \delta_1^{(L)}f(x)^{'}|_{x=net_1^{(L)}}\\ \delta_2^{(L)}f(x)^{'}|_{x=net_2^{(L)}}\\ \dots\\ \delta_n^{(L)}f(x)^{'}|_{x=net_n^{(L)}} \end{matrix}\right]^T \left[\begin{matrix} W_{11}^{(L)} & W_{12}^{(L)}&\dots & W_{1n}^{(L)}\\ W_{21}^{(L)} & W_{22}^{(L)}&\dots& W_{2n}^{(L)}\\ \vdots& \dots& \dots& \dots\\ W_{s(L-1),1}^{(L)} & W_{s(L-1),2}^{(L)}&\dots& W_{s(L-1),n}^{(L)} \end{matrix}\right]^T \\ \left[ \begin{array}{ccc}{f^{'(L-1)}\left(net^{(L-1)}_{(1)}\right)} & {0} & {0}&{0} \\ {0} & {f^{'(L-1)}\left(net^{(L-1)}_{(2)}\right)} & {0} &{0}\\ 0 & \dots & \vdots & 0\\{0} & {0} & {0}&{f^{(L-1)}\left(ne t_{s(L-1)}^{(L-1)}\right)}\end{array}\right]\\ =h^{(L-2)}S^{(L-1)} S^{(L-1)}=\left(\left[\begin{matrix} f(x)^{'(L)}|_{x=net_1^{(L)}}&0& \dots& 0\\ 0&f(x)^{'}|_{x=net_2^{(L)}}0& \dots& 0\\ 0&\dots&\dots&0\\ 0&0&0&f(x)^{'(L)}|_{x=net_n^{(L)}} \end{matrix}\right]\left[\begin{matrix} \delta_1^{(L)}\\\delta_2^{(L)}\\\vdots\\\delta_n^{(L)}\end{matrix}\right] \right)^T\\ \left[\begin{matrix} W_{11}^{(L)} & W_{12}^{(L)}&\dots & W_{1n}^{(L)}\\ W_{21}^{(L)} & W_{22}^{(L)}&\dots& W_{2n}^{(L)}\\ \vdots& \dots& \dots& \dots\\ W_{s(L-1),1}^{(L)} & W_{s(L-1),2}^{(L)}&\dots& W_{s(L-1),n}^{(L)}* \end{matrix}\right]^T \left[ \begin{array}{ccc}{f^{'(L-1)}\left(net^{(L-1)}_{(1)}\right)} & {0} & {0}&{0} \\ {0} & {f^{'(L-1)}\left(net^{(L-1)}_{(2)}\right)} & {0} &{0}\\ 0 & \dots & \vdots & 0\\{0} & {0} & {0}&{f^{(L-1)}\left(ne t_{s(L-1)}^{(L-1)}\right)}\end{array}\right]\\ =S^{(L)}\left[\begin{matrix} W_{11}^{(L)} & W_{12}^{(L)}&\dots & W_{1n}^{(L)}\\ W_{21}^{(L)} & W_{22}^{(L)}&\dots& W_{2n}^{(L)}\\ \vdots& \dots& \dots& \dots\\ W_{s(L-1),1}^{(L)} & W_{s(L-1),2}^{(L)}&\dots& W_{s(L-1),n}^{(L)}* \end{matrix}\right]^T\left[ \begin{array}{ccc}{f^{'(L-1)}\left(net^{(L-1)}_{(1)}\right)} & {0} & {0}&{0} \\ {0} & {f^{'(L-1)}\left(net^{(L-1)}_{(2)}\right)} & {0} &{0}\\ 0 & \dots & \vdots & 0\\{0} & {0} & {0}&{f^{(L-1)}\left(ne t_{s(L-1)}^{(L-1)}\right)}\end{array}\right]*\\对$1&lt;l&lt;L$,求$W^{(l)}$的偏导, 最后，根据上述的推导喔，很容易得出$S^{(l)}$和$S^{(l+1)}$, S^{(l)}=S^{(l+1)}W^{(l+1)^T}F^{'(l)}(net^{(l)})\\ S^{(L)}=(Y-\hat{Y})F^{'(L)}(net^{(L)}) \frac{\partial E}{\part W^{(l)}}=\left[\begin{matrix}h^{(l-1)}_1\\h^{(l-1)}_2 \\\dots \\h^{(l-1)}_{sl}\end{matrix}\right]S^{(l+1)} \left[\begin{matrix}W_{11}^{(l+1)}&W_{12}^{(l+1)} &\dots& W_{2(sl+1)}^{(l+1)}\\ W_{21}^{(l+1)}&W_{22}^{(l+1)} &\dots& W_{2(sl+1)}^{(l+1)}\\ \dots&\dots&\dots&\dots\\ W_{sl1}^{(l+1)}&W_{sl2}^{(l+1)} &\dots& W_{sl(sl+1)}^{(l+1)}\\ \end{matrix} \right]^T\left[\begin{matrix} \part f^{'(l)}(net_1^{l})&0&\dots & 0\\ 0\\0 &\part f^{'(l)}(net_2^{l})&\dots&0\\ 0 & 0&\dots&0\\ 0&0&\dots&\part f^{'(l)}(net_l^{l})\end{matrix}\right]3.2 BP算法的小结算法分为两个阶段：前向阶段和后向传播阶段 后向阶段算法： Step 1: 计算$\hat{y}^{(L)}$ Step 2: for l =L:2 ​ 计算$S^{(l)}=S^{(l+1)}W^{(l+1)}F’(net^{(l)})$ ​ 计算 $\Delta W^{(l)}=h^{(l-1)}S^{(l)} $ ​ 计算$W^{(l)}=W^{(l)}-\delta \Delta W^{(l)}$ 3.3 Python实现3.3.1 最简单三层网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071'''不用任何框架，自己写一个三层的神经网络# input-3,hidden-4 output-1'''import numpy as npnp.random.seed(1)# Input MatrixX = np.array([[0, 0, 1], [0, 1, 1], [1, 0 ,1], [1, 1, 1],])# Output Matrixy = np.array([[0], [1], [1], [0]])# Nonlinear functiondef sigmoid(X,derive=False): if not derive: return 1 / (1 + np.exp(-X)) else: return X*(1-X)# reludef relu(X,derive = False): if not derive: return np.maximum(0,X) else: return (X&gt;0).astype(float) # Weight biasW1 = 2 * np.random.random((3, 4))-1b1 = 0.1 * np.ones((4,)) W2 = 2 * np.random.random((4,1))-1b2 = 0.1 * np.ones((1,)) rate = 0.1noline = relu# Trainingtrain_times = 200 for time in range(train_times): # Layer one A1 = np.dot(X,W1)+b1 Z1 = noline(A1) # Layer two A2 = np.dot(Z1, W2)+b2 Z2 = noline(A2) cost = -y+Z2 # Calc deltas S2= cost*noline(A2,True) delta_W2 = np.dot(Z1.T,S2) bias2 = S2.sum(axis=0) S1 = np.dot(S2, W2.T)*noline(A1,True) delta_W1= np.dot(X.T, S1) bias1 = S1.sum(axis=0) # update W1 = W1-rate*delta_W1 b1 = b1-rate*bias1 W2 = W2-rate*delta_W2 b2 = b2-rate*bias2 print('error',np.mean(((y-Z2)*(y-Z2))**2))print("prediction",Z2) 3.4 附录： Name Abbreviation Mean absolute percentage error MAPE Root mean squares percentage error RMSPE Mean absolute percentage error MAE Mean squares error MSE Index of agreement IA Theil U statistic 1 U1 Theil U statistic 2 U2 Correlation coefficient R MAPE = $\frac{1}{n} \sum_{k=1}^{n}\left|\frac{x^{(0)}(k)-\hat{x}^{(0)}(k)}{x^{(0)}(k)}\right| \times 100$RMSPE = $\sqrt{\frac{1}{n} \sum_{k=1}^{n}\left(\frac{\hat{x}^{(0)}(k)-x^{(0)}(k)}{x^{(0)}(k)}\right)^{2}} \times 100$MAE = $\frac{1}{n} \sum_{k=1}^{n}\left|\hat{x}^{(0)}(k)-x^{(0)}(k)\right|$MSE = $\frac{1}{n} \sum_{k=1}^{n}\left(\hat{x}^{(0)}(k)-x^{(0)}(k)\right)^{2}$IA = $1-\frac{\sum_{k=1}^{n}\left(\hat{x}^{(0)}(k)-x^{(0)}(k)\right)^{2}}{\sum_{k=1}^{n} \left( \left| \hat{x}^{(0)}(k)-\overline{x} \right|+\left| x^{(0)}(k)-\overline{x}\right| \right)^{2}}$U1 = $\frac{\sqrt{\frac{1}{n} \sum_{k=1}^{n}\left(x^{(0)}(k)-x^{(0)}(k)\right)^{2}}}{\sqrt{\frac{1}{n} \sum_{k=1}^{n} x^{(0)}(k)^{2}}+\sqrt{\frac{1}{n} \sum_{k=1}^{n} x^{(0)}(k)^{2}}}$U2 = $\frac{\left[\sum_{k=1}^{n}\left(\hat{x}^{(0)}(k)-x^{(0)}(k)\right)^{2}\right]^{1 / 2}}{\left[\sum_{k=1}^{n} x^{(0)}(k)^{2}\right]^{1 / 2}}$R = $\frac{\operatorname{Cov}(\hat{x}^{(0)}, x^{(0)})}{\sqrt{\operatorname{Var}[\hat{x}^{(0)}] \operatorname{Var}[x^{(0)}]}}$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>BP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主要是分享决策的基本知识点，重点在分类决策树上，对于回归的决策树后面在给出。希望大家和我一起做知识的传播者啦！:smile: :smiley: :grin: :open_mouth: [TOC] 决策树英文名字：Descision Tree 什么是决策树举个校园相亲的例子，今天校园的小猫(女)和小狗(男)准备配对，小猫如何才能在众多的优质🐶的心仪的狗呢？于是呢？有一只特乖巧的小猫找到了你，你正在学习机器学习，刚好学习了决策树，准备给这只猫猫挑选优质狗，当然，你不仅仅是直接告诉猫哪些狗是合适你的？你更应该详细的给猫讲解决策树是如何根据它提出的标准选出的符合要求的狗呢？猫给出如下信息：年龄=0.5 6.5&lt;=体重&lt;=8.5;心仪; 年龄&gt;=0.5 体重&gt;8.5 长相好 心仪;其余情况不心仪; 根据上述条件可以构造一颗树：上面的图就是决策树，最终的结果是心仪或者不心仪。决策树算法以树形结构表示数据分类的结果 基本概念决策树属于也只能非参数学习算法、可以用于解决(多)分类问题，回归问题。 回归问题的结果，叶子结点的平均值是回归问题的解。根节点：决策树具有数据结构里面的二叉树、树的全部属性非叶子节点 ：（决策点） 代表测试的条件，数据的属性的测试叶子节点 ：分类后获得分类标记分支： 测试的结果 数学问题-熵-Gini系数什么是熵：熵的概念源于物理学，用于度量一个热力学系统的无序程度。信息熵：不得不提香农这个大写的人啦！信息论里面的知识。在信息论里面，信息熵衡量信息量的大小，也就是对随机变量不确定度的一个衡量。熵越大，不确定性越大；对于某个单符号无记忆信源，发出符号($x_i$)的概率是$p_i$,概率越大，符号的信息量就越小，香农公式 $I(x_i)=-log_{p_i}$。信源所含的信息熵就是信息量的期望]$H(x)=-\sum p_i*log_{p_i}$Gini系数： $Gimi(p) = 1-\sum_{k=1}^{K}p_k^2$ 决策树如何构建的问题自我提问阶段： 每个节点的位置如何确定？特征的选择：每次选入的特征作为分裂的标准，都是使得决策树在这个节点的根据你自己选择的标准（信息熵最小、信息增益最大、gini系数最小）. 每个节点在哪个值上做划分，确定分支结构呢？遍历划分的节点的分界值操作来解决这个问题 可以想象，我们构造的决策树足够庞大，决策树可以把每一个样本都分对，那么决策树的泛化能力就可以很差了为了解决这个问题，就需要剪枝操作了 训练算法基于信息熵的构造当选择某个特征作为节点时，我们就希望这个特征的信息熵越小越好，那么不确定性越小。计算特征的信息熵公式如下： H(x) = -p_i(x)log^{p_i(x)} = -\frac{n_j}{S}log^{\frac{n_j}{S}}$n_j$: 第j个类别，在样本中出现的频数$S$: 样本个数对于离散属性，直接计算信息熵，连续属性，就需要划分区间，按区间计算信息熵。 基于某一层的数据集 a. 遍历计算所有属性，遍历相应属性以不同值为分截点的信息熵 b. 选择信息熵最小的作为节点 如果到达终止条件，返回相应信息，否则，按照分支重复步骤1ID3算法： 信息增益最大化C:类别H(C)=-\sum_{i=1}^{m}p_i log _2^{p_i}按照D组划分CH(C/D)=\sum_{i=1}^{v}\frac{|C_i|}{|C|}H(C_i)信息增益gain(D) = gain(C)-H(C/D)这里我就以网上给出的数据为例，给出根据信息熵构成决策树的计算过程。 确定特征，统计属性值和分解结果，总共四个特征，四种特征的统计结果如下图： 根据历史数据，在不知到任何情况下，计算数据本身的熵为 - \frac{9}{14}log_2 \frac{9}{14}-\frac{5}{14}log_2\frac{5}{14}=0.940 计算每个特征做为节点的信息熵以天气为例，天气三种属性，当Outlook = sunny时，H(x) = $-\frac{2}{5}log_2\frac{2}{5}-\frac{3}{5}log_2\frac{3}{5}$; 当Outlook= overcast,$H(x)=0$,当Outlook = rainy ,$H(x) = 0.971$所以，当选天气作为节点时，此时$H(x)=\frac{5}{14}0.971+\frac{4}{14}0+\frac{5}{14}*0.971 = 0.693$,gain(天气) = 0.247同理，可得gain(温度) =0.029 gain(湿度)=0.152，gain(风)=0.048因此选择天气节点，在递归实现其他节点的选择。信息增益的方法偏向选择具有大量值的属性，也就是说某个属性特征索取的不同值越多，那么越有可能作为分裂属性，这样是不合理的； C4.5: 信息增益率如果这里考虑了一列ID,每个ID出现一次，所以算出的信息增益大。$ H(x) = 0$,信息增益最大化了，可以引入信息增益率 C(T) = \frac{信息增益}{H(T)} =\frac{H(C)-H(C/T)}{H(T)}CART:基尼(Gini)系数G = 1-\sum_{i=l_k}^{k}p_i^2$$,也是对随机变量不确定性的一个衡量，gini越大，不确定性越大 ### 连续属性的处理方法 选取分解点的问题： 分成不同的区间（二分、三分....)，分别计算增益值，然后比较选择。 将需要处理的样本（对应根节点）或样本子集（对应子树）按照连续变量的大小从小到大进行排序 假设该属性对应不同的属性值共N个，那么总共有N-1个可能的候选分割值点，每个候选的分割阈值点的值为上述排序后的属性值中两两前后连续元素的中点 ## 评价 评价函数： $$C(T) = \sum_{releaf} N_t*H(T)$ N_t$：每个叶子节点里面含有的样本个数$H(T)$:叶子节点含有的信息熵 过拟合如果决策树过于庞大，分支太多，可能造成过拟合。对应训练样本都尽可能的分对，也许样本本身就存在异常点呢？I. 预剪枝：边构建，边剪枝 指定深度d 节点的min_sample 节点熵值或者gini值小于阙值熵和基尼值的大小表示数据的复杂程度，当熵或者基尼值过小时，表示数据的纯度比较大，如果熵或者基尼值小于一定程度数，节点停止分裂。 当所以特征都用完了 指定节点个数当节点的数据量小于一个指定的数量时，不继续分裂。两个原因：一是数据量较少时，再做分裂容易强化噪声数据的作用；二是降低树生长的复杂性。提前结束分裂一定程度上有利于降低过拟合的影响。 II. 后剪枝： 构建好后，然后才开始裁剪 C_\alpha(T) = C(T)+\alpha|T_{leaf}|在构造含一棵树后，选一些节点做计算，看是否需要剪枝 决策树单个节点选择的代码实现简单实现了单个节点决策构造过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182def split(X,y,d,value):'''在d纬度上，按照value进行划分''' index_a =(X[:,d]&lt;=value) index_b =(X[:,d]&gt;value) return X[index_a],X[index_b],y[index_a],y[index_b]from collections import Counterfrom math import log from numpy as npdef entropy(y): counter = Counter(y) # 字典 res = 0.0 for num in counter.values(): p = num/len(y) res+=-p*log(p) return resdef gain(X,y,d,v): X_l,X_r,y_l,y_r = split(X,y,d,v) e = len(y_l)/len(y)*entropy(y_l)+len(y_r)/len(y)*entropy(y_r) return (entropy(y)-e)def gainratio(X,y,d,v): X_l,X_r,y_l,y_r = split(X,y,d,v) gain =entropy(y) - len(y_l)/len(y)*entropy(y_l)+len(y_r)/len(y)*entropy(y_r) return gain/(entropy(y_l)+entropy(y_r))def gini(y): counter = Counter(y) res = 1.0 for num in counter.values(): p = num / len(y) res += -p**2 return res #X_l,X_r,y_l,y_r = split(X,y,d,v) #return 1-(len(y_l)/len(y))**2-(len(y_r)/len(y))**2def try_split(X,y): best_entropy = float('inf') best_d,best_v=-1,-1 for d in range(X.shape[1]): sorted_index = np.argsort(X[:,d]) for i in range(1, len(X)): if (X[sorted_index[i],d] != X[sorted_index[i-1],d]): v = (X[sorted_index[i-1],d]+X[sorted_index[i],d])/2 X_l,X_r,y_l,y_r = split(X,y,d,v) # 信息熵 e = entropy(y_l)+entropy(y_r) #gini e = gini(y_l) + gini(y_r) # 信息增益 e = -gain(X,y,d,v) if e &lt; best_entropy: best_entropy, best_d,best_v = e,d,v return best_entropy, best_d, best_v# 手动来划分data =np.array([[ 0.3 , 5 , 2 , 0 ],[ 0.4 , 6 , 0 , 0 ],[ 0.5 , 6.5 , 1 , 1 ],[ 0.6 , 6 , 0 , 0 ],[ 0.7 , 9 , 2 , 1 ],[ 0.5 , 7 , 1 , 0 ],[ 0.4 , 6 , 0 , 0 ],[ 0.6 , 8.5 , 0 , 1 ],[ 0.3 , 5.5 , 2 , 0 ],[ 0.9 , 10 , 0 , 1 ],[ 1 , 12 , 1 , 0 ],[ 0.6 , 9 , 1 , 0 ],])X =data[:,0:3]y = data[:,-1]# 手动来划分best_entropy, best_d, best_v = try_split(X, y)print(best_entropy, best_d, best_v)X1_l, X1_r, y1_l, y1_r = split(X,y,best_d,best_v)print(X1_l, X1_r, y1_l, y1_r)best_entropy2, best_d2, best_v2 = try_split(X1_r, y1_r)X2_l, X2_r, y2_l, y2_r = split(X1_r,y1_r,best_d2,best_v2)entropy(y2_l) Python sklean里面tree模块里面的DecisionTreeClassifier1234from sklearn import treeclf =tree.DecisionTreeClassifier(max_depth=1,criterion ='gini') # criterion='entropy|gini'clf = clf.fit(X,y) 训练好一颗决策树之后，我们可以使用export_graphviz导出器以Graphviz格式导出树。1234import graphviz dot_data = tree.export_graphviz(clf, out_file=None,) graph = graphviz.Source(dot_data) graph.render("data") 在运行时可以出错：ExecutableNotFound: failed to execute [‘dot’, ‘-Tpdf’, ‘-O’, ‘data’], make sure the Graphviz executables are on your systems’ PATH原因：graphviz本身是一个软件，需要额外下载，并将其bin加入环境变量之中。下载]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希腊字母]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[$\alpha$ $\beta$ $\gamma$ $\Gamma$ $\delta$ $\Delta$ $\epsilon$ $\varepsilon$ $\zeta$ $\eta$ $\theta$ $\Theta$ $\vartheta$ $\iota$ $\kappa$ $\lambda$ $\Lambda$ $\mu$ $\nu$ $\xi$ $\Xi$ $\pi$ $\Pi$ $\varpi$ $\rho$ $\varrho$ $\sigma$ $\Sigma$ $\varsigma$ $\tau$ $\upsilon$ $\Upsilon$ $\phi$ $\Phi$ $\varphi$ $\chi$ $\psi$ $\Psi$ $\Omega$ $\omega$ alpha beta gamma delta epsilon theta]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>希腊字母</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吴恩达]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%90%B4%E6%81%A9%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[Neural Networks and Deep Learning 4 周]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主要是分享决策的基本知识点，重点在分类决策树上，对于回归的决策树后面在给出。希望大家和我一起做知识的传播者啦！:smile: :smiley: :grin: :open_mouth: [TOC] 决策树英文名字：Descision Tree 什么是决策树举个校园相亲的例子，今天校园的小猫(女)和小狗(男)准备配对，小猫如何才能在众多的优质🐶的心仪的狗呢？于是呢？有一只特乖巧的小猫找到了你，你正在学习机器学习，刚好学习了决策树，准备给这只猫猫挑选优质狗，当然，你不仅仅是直接告诉猫哪些狗是合适你的？你更应该详细的给猫讲解决策树是如何根据它提出的标准选出的符合要求的狗呢？猫给出如下信息：年龄=0.5 6.5&lt;=体重&lt;=8.5;心仪; 年龄&gt;=0.5 体重&gt;8.5 长相好 心仪;其余情况不心仪; 根据上述条件可以构造一颗树： 上面的图就是决策树，最终的结果是心仪或者不心仪。决策树算法以树形结构表示数据分类的结果 基本概念决策树属于也只能非参数学习算法、可以用于解决(多)分类问题，回归问题。 回归问题的结果，叶子结点的平均值是回归问题的解。根节点：决策树具有数据结构里面的二叉树、树的全部属性非叶子节点 ：（决策点） 代表测试的条件，数据的属性的测试叶子节点 ：分类后获得分类标记分支： 测试的结果 数学问题-熵-Gini系数什么是熵：熵的概念源于物理学，用于度量一个热力学系统的无序程度。信息熵：不得不提香农这个大写的人啦！信息论里面的知识。在信息论里面，信息熵衡量信息量的大小，也就是对随机变量不确定度的一个衡量。熵越大，不确定性越大；样本纯度越大越好。对于某个单符号无记忆信源，发出符号($x_i$)的概率是$p_i$,概率越大，符号的信息量就越小，香农公式 $I(x_i)=-log_{p_i}$。信源所含的信息熵就是信息量的期望]$H(x)=-\sum p_i*log_{p_i}$Gini系数： $Gimi(p) = 1-\sum_{k=1}^{K}p_k^2$ 决策树如何构建的问题自我提问阶段： 每个节点的位置如何确定？特征的选择：每次选入的特征作为分裂的标准，都是使得决策树在这个节点的根据你自己选择的标准（信息熵最小、信息增益最大、gini系数最小）. 选取的标准：尽快能的划分出结果，使得分的结果最好。 每个节点在哪个值上做划分，确定分支结构呢？遍历划分的节点的分界值操作来解决这个问题 可以想象，我们构造的决策树足够庞大，决策树可以把每一个样本都分对，那么决策树的泛化能力就可以很差了为了解决这个问题，就需要剪枝操作了 训练算法基于信息熵的构造当选择某个特征作为节点时，我们就希望这个特征的使得分类结果信息熵越小越好，那么不确定性越小。计算特征的信息熵公式如下： H(x) = -p_i(x)log^{p_i(x)} = -\frac{n_j}{S}log^{\frac{n_j}{S}}$n_j$: 第j个类别，在样本中出现的频数$S$: 样本个数对于离散属性，直接计算信息熵，连续属性，就需要划分区间，按区间计算信息熵。 基于某一层的数据集 a. 遍历计算所有属性，遍历相应属性以不同值为分截点的信息熵 b. 选择信息熵最小的作为节点 如果到达终止条件，返回相应信息，否则，按照分支重复步骤1ID3 算法： 信息增益最大化 建立在奥卡姆剃刀的基础上。 思想 集合C的信息熵 H(C)=-\sum_{i=1}^{m}p_i log _2^{p_i}按照D组划分C，数据集C的条件熵， H(C/D)=\sum_{i=1}^{v}\frac{|C_i|}{|C|}H(C_i) = \sum_{i=1}^{v}\frac{|C_i|}{|C|}\sum_{j = 1}^{m}\frac{|C_{ik}|}{|C_i|}log_2\frac{|C_{ik}|}{|C_2|}信息增益 = 信息熵-条件熵 gain(C,D) = gain(C)-H(C/D)这里我就以网上给出的数据为例，给出根据信息熵构成决策树的计算过程。 确定特征，统计属性值和分解结果，总共四个特征，四种特征的统计结果如下图： 根据历史数据，在不知到任何情况下，计算数据本身的熵为- \frac{9}{14}log_2 \frac{9}{14}-\frac{5}{14}log_2\frac{5}{14}=0.940 计算每个特征做为节点的信息熵以天气为例，天气三种属性，当Outlook = sunny时，H(x) = $-\frac{2}{5}log_2\frac{2}{5}-\frac{3}{5}log_2\frac{3}{5}$; 当Outlook= overcast,$H(x)=0$,当Outlook = rainy ,$H(x) = 0.971$所以，当选天气作为节点时，此时$H(x)=\frac{5}{14}0.971+\frac{4}{14}0+\frac{5}{14}*0.971 = 0.693$,gain(天气) = 0.247同理，可得gain(温度) =0.029 gain(湿度)=0.152，gain(风)=0.048因此选择天气节点，在递归实现其他节点的选择。信息增益的方法偏向选择具有大量值的属性，也就是说某个属性特征索取的不同值越多，那么越有可能作为分裂属性，这样是不合理的； 缺点 没有剪纸策略，容易过拟合 信息增益准则表现出对取值较多的特征，列如编号，生日这种 没有考虑缺失值 C4.5: 信息增益率C4.5 相对于ID3的缺点改进如下： 引入了剪纸策略 对于具有缺失值特征，用没有缺失的样本子集所占比重来折算； 引入信息增益率作为划分标准 连续特征离散化 缺失值处理。 以不同概率划分到不同节点中 如果这里考虑了一列ID,每个ID出现一次，所以算出的信息增益大。$ H(x) = 0$,信息增益最大化了，可以引入信息增益率 C(T) = \frac{信息增益}{H(T)} =\frac{H(C)-H(C/T)}{H(T)}CART:基尼(Gini)系数G = 1-\sum_{i=l_k}^{k}p_i^2$$,也是对随机变量不确定性的一个衡量，gini越大，不确定性越大 ### 连续属性的处理方法 选取分解点的问题： 分成不同的区间（二分、三分....)，分别计算增益值，然后比较选择。 将需要处理的样本（对应根节点）或样本子集（对应子树）按照连续变量的大小从小到大进行排序 假设该属性对应不同的属性值共N个，那么总共有N-1个可能的候选分割值点，每个候选的分割阈值点的值为上述排序后的属性值中两两前后连续元素的中点。 阙值：threshold ## 评价 评价函数： $$C(T) = \sum_{releaf} N_t*H(T)$ N_t$：每个叶子节点里面含有的样本个数$H(T)$:叶子节点含有的信息熵 过拟合如果决策树过于庞大，分支太多，可能造成过拟合。对应训练样本都尽可能的分对，也许样本本身就存在异常点呢？I. 预剪枝：边构建，边剪枝 指定深度d 节点的min_sample 节点熵值或者gini值小于阙值熵和基尼值的大小表示数据的复杂程度，当熵或者基尼值过小时，表示数据的纯度比较大，如果熵或者基尼值小于一定程度数，节点停止分裂。 当所有7特征都用完了 指定节点个数当节点的数据量小于一个指定的数量时，不继续分裂。两个原因：一是数据量较少时，再做分裂容易强化噪声数据的作用；二是降低树生长的复杂性。提前结束分裂一定程度上有利于降低过拟合的影响。 II. 后剪枝： 构建好后，然后才开始裁剪 C_\alpha(T) = C(T)+\alpha|T_{leaf}|在构造含一棵树后，选一些节点做计算，看是否需要剪枝。 后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但同时其训练时间会大的多 熵 bias生日这种属性，把属性分的太多了，分的越细，往往熵越大。 决策树单个节点选择的代码实现简单实现了单个节点决策构造过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182def split(X,y,d,value):'''在d纬度上，按照value进行划分''' index_a =(X[:,d]&lt;=value) index_b =(X[:,d]&gt;value) return X[index_a],X[index_b],y[index_a],y[index_b]from collections import Counterfrom math import log from numpy as npdef entropy(y): counter = Counter(y) # 字典 res = 0.0 for num in counter.values(): p = num/len(y) res+=-p*log(p) return resdef gain(X,y,d,v): X_l,X_r,y_l,y_r = split(X,y,d,v) e = len(y_l)/len(y)*entropy(y_l)+len(y_r)/len(y)*entropy(y_r) return (entropy(y)-e)def gainratio(X,y,d,v): X_l,X_r,y_l,y_r = split(X,y,d,v) gain =entropy(y) - len(y_l)/len(y)*entropy(y_l)+len(y_r)/len(y)*entropy(y_r) return gain/(entropy(y_l)+entropy(y_r))def gini(y): counter = Counter(y) res = 1.0 for num in counter.values(): p = num / len(y) res += -p**2 return res #X_l,X_r,y_l,y_r = split(X,y,d,v) #return 1-(len(y_l)/len(y))**2-(len(y_r)/len(y))**2def try_split(X,y): best_entropy = float('inf') best_d,best_v=-1,-1 for d in range(X.shape[1]): sorted_index = np.argsort(X[:,d]) for i in range(1, len(X)): if (X[sorted_index[i],d] != X[sorted_index[i-1],d]): v = (X[sorted_index[i-1],d]+X[sorted_index[i],d])/2 X_l,X_r,y_l,y_r = split(X,y,d,v) # 信息熵 e = entropy(y_l)+entropy(y_r) #gini e = gini(y_l) + gini(y_r) # 信息增益 e = -gain(X,y,d,v) if e &lt; best_entropy: best_entropy, best_d,best_v = e,d,v return best_entropy, best_d, best_v# 手动来划分data =np.array([[ 0.3 , 5 , 2 , 0 ],[ 0.4 , 6 , 0 , 0 ],[ 0.5 , 6.5 , 1 , 1 ],[ 0.6 , 6 , 0 , 0 ],[ 0.7 , 9 , 2 , 1 ],[ 0.5 , 7 , 1 , 0 ],[ 0.4 , 6 , 0 , 0 ],[ 0.6 , 8.5 , 0 , 1 ],[ 0.3 , 5.5 , 2 , 0 ],[ 0.9 , 10 , 0 , 1 ],[ 1 , 12 , 1 , 0 ],[ 0.6 , 9 , 1 , 0 ],])X =data[:,0:3]y = data[:,-1]# 手动来划分best_entropy, best_d, best_v = try_split(X, y)print(best_entropy, best_d, best_v)X1_l, X1_r, y1_l, y1_r = split(X,y,best_d,best_v)print(X1_l, X1_r, y1_l, y1_r)best_entropy2, best_d2, best_v2 = try_split(X1_r, y1_r)X2_l, X2_r, y2_l, y2_r = split(X1_r,y1_r,best_d2,best_v2)entropy(y2_l) Python sklean里面tree模块里面的DecisionTreeClassifier1234from sklearn import treeclf =tree.DecisionTreeClassifier(max_depth=1,criterion ='gini') # criterion='entropy|gini'clf = clf.fit(X,y) 训练好一颗决策树之后，我们可以使用export_graphviz导出器以Graphviz格式导出树。1234import graphviz dot_data = tree.export_graphviz(clf, out_file=None,) graph = graphviz.Source(dot_data) graph.render("data") 在运行时可以出错：ExecutableNotFound: failed to execute [‘dot’, ‘-Tpdf’, ‘-O’, ‘data’], make sure the Graphviz executables are on your systems’ PATH原因：graphviz本身是一个软件，需要额外下载，并将其bin加入环境变量之中。下载]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的读书笔记]]></title>
    <url>%2F2019%2F02%2F28%2FSVD%2F</url>
    <content type="text"><![CDATA[目录 :smile::one: 简单说一下特征值、特征向量与特征分解&nbsp;&nbsp; I. 特征值、特征向量与特征分解&nbsp;&nbsp; II. 几何意义&nbsp;&nbsp; III. 如何实现通过Matlab、Python实现:two:详细解说SVD&nbsp;&nbsp; I. 几何意义&nbsp;&nbsp; I. 奇异值分解的推导过程&nbsp;&nbsp; I. SVD算例&nbsp;&nbsp; I. 如何通过Matlab和Python:three:应用举例&nbsp;&nbsp; I. 特征值、特征向量与特征分解:four:特征分解、奇异值分解的区别&nbsp;&nbsp; I. 特征分解、奇异值分解的区别 简单说一下特征值、特征向量与特征分解 特征值、特征向量与特征分解Theory:对于一个正阵$M$，满足如下： Mx=\lambda x其中$\lambda$被成为特征值，满足$||M-\lambda E||=0$再有$(M-\lambda E)x=0$，可计算其特征向量。如果有了特征值和特征向量后呢，则可以将矩阵$M$用特征分解： M=W\sum W^{-1}$W={w_1,w_2,…,w_n}$分别是特征值$\lambda_1,\lambda_2,…,\lambda_n$对应的特征向量构成的方阵 几何意义 对应矩阵M,其对应的线性变化 Mx = x'上面这个式子，$Mx，x’$是一个向量，$x,x’$可能是不共线的(如图(b))，如果向量$Mx,x’$满足$Mx=x’=\lambda x$,则如图(b)，这说明了这个变换就是对向量x做一个拉伸或者压缩。 如何实现通过Matlab、Python实现数学推导： Mx = \lambda xMx-\lambda x=(M-\lambda E)x=0齐次线性方程组有非零解，则$||M-\lambda E||=0$可求得特征向量再带回，可得特征向量。Matlab:123d = eig(M) % 求取矩阵M的特征值，向量形式存储[V,D] = eig(M) % 计算M的特征值对角阵D和特征向量V，使得MV = VD成立[V,D] = eig(M,'nobalance') %当矩阵M中有与截断误差数量级相差不远的值时，该指令可能更精确。'nobalance'起误差调节作用 Pythonnumpy科学计算库提供相应的方法1234import numpy as npx = np.diag((1,2,3)) # 这是你想要求取特征值的数组a,b = numpy.linalg.elg(x) # 特征值赋值给a,对应的特征向量赋值给b 详细解说SVDSVD的英文全称： Singular Value Decomposition，中文名字：奇异值分解 几何意义图来源以二维空间为例几何意义就是把一个单位正交的网格，转换为另外一个单位正交的网格 假如选取了一组单位正交基{$\vec{v}_1$,$\vec{v}_2$},刚好矩阵$M$的线性变化$M\vec{v}_1 $,$M\vec{v}_2 $ 也正交，用$\vec{u}_1,\vec{u}_2 $分别表示$M\vec{v}_1 $,$M\vec{v}_2 $ 的单位向量，用$\lambda_1,\lambda_2 $表示$M\vec{v}_1 $,$M\vec{v}_2$的长度，描述网格在这些特定方向上的拉伸量，也被称作矩阵M的奇异值。$M\vec{v}_1 =\lambda_1\vec{u}_1 $$M\vec{v}_2 =\lambda_2\vec{u}_2 $对任意给定的向量 $\vec{x}$ ,则有 \mathbf{x}=\left(\mathbf{v}_{1} \cdot \mathbf{x}\right) \mathbf{v}_{1}+\left(\mathbf{v}_{2} \cdot \mathbf{x}\right) \mathbf{v}_{2} 再将M的线性变换 \begin{aligned} M \mathbf{x} &=\left(\mathbf{v}_{1} \cdot \mathbf{x}\right) M \mathbf{N}_{1}+\left(\mathbf{v}_{2} \cdot \mathbf{x}\right) M \mathbf{v}_{2} \\ M \mathbf{x} &=\left(\mathbf{v}_{1} \cdot \mathbf{x}\right) \sigma_{1} \mathbf{u}_{1}+\left(\mathbf{v}_{2} \cdot \mathbf{x}\right) \sigma_{2} \mathbf{u}_{2} \end{aligned} \begin{array}{c}{M \mathbf{x}=\mathbf{u}_{1} \sigma_{1} \mathbf{v}_{1}^{\top} \mathbf{x}+\mathbf{u}_{2} \sigma_{2} \mathbf{v}_{2}^{\top} \mathbf{x}} \\ {M=\mathbf{u}_{1} \sigma_{1} \mathbf{v}_{1}^{\top}+\mathbf{u}_{2} \sigma_{2} \mathbf{v}_{2}^{\top}}\end{array} so M=U \Sigma V^{T}奇异值分解的推导过程$u=(u_1,u_2,…,u_m)$$v=(v_1,v_2,…,v_n)$$u,v$都是空间的基,是正交矩阵 $u^Tu=E,v^Tv = E$任何一个矩阵$M_{m*n}$，$rank(M)=k$，一定存在ＳＶＤ,换句话说，M可以将一组单位正交基映射到另一组单位正交基。答案是肯定的证明如下：在n为空间中，有一组单位正交基{$\vec{v}_1,\vec{v}_2,…,\vec{v}_n$},线性变化作用以后 {M\vec{v}_1,M\vec{v}_2,...,M\vec{v}_n}也是正交的，则有 (M\vec{v}_i,M\vec{v}_j) = (M\vec{x}_i)^TM\vec{v}_j=\vec{v}_i^TM^TM\vec{v}_j=0注意喔，$M^TM$是矩阵喔，则会有$M^TM\vec{v}_j=\lambda \vec{v}_j$接下去， \begin{aligned} v_{i}^{T} M^{T} \mathrm{M} v_{j}=& v_{i}^{T} \lambda_{j} v_{j} \\ &=\lambda_{j} v_{i}^{T} v_{j} \\ &=\lambda_{j} v_{i}\dot v_{j}=0 \end{aligned} 上述就证明了是有的：任何一个矩阵，都可以将一组单位正交基转换成另外一组正交基。 当$i=j$,$=\lambda_i \vec{v}_i \vec{v}_i=\lambda_i$ 进行一些单位化，记$u_i=\frac{A\vec{v}_i}{|M\vec{v}_i|}=\frac{1}{\sqrt{\lambda_i}}M\vec{v}_i$则 A v_{i}=\sigma_{i} u_{i}, \sigma_{i}(\operatorname{奇异值})=\sqrt{\lambda_{i}}, 0 \leq i \leq \mathrm{k}, \mathrm{k}=\operatorname{Rank}(\mathrm{A}) 当$k &lt; i &lt;= m$时，对$u1，u2，…，uk$进行扩展$u(k+1),…,um$，使得$u1，u2，…，um$为$m$维空间中的一组正交基.也可对$\vec{v}_1,\vec{v}_2,…,\vec{v}_k$进行扩展，扩展的$\vec{v}_{k+1},…,\vec{v}_{n}$存在零子空间里面。 M\left[ \begin{array}{lll}{\vec{v}_{1}} & {\cdots} & {\vec{v}_{k}}\end{array}\right| \vec{v}_{k+1} \quad \cdots \quad \vec{v}_{m} ]= \left[ \begin{array}{c}{\vec{u}_{1}^{T}} \\ {\vdots} \\ {\frac{\vec{u}_{k}^{T}}{\vec{u}_{k+1}}} \\ {\vdots} \\ {\vec{u}_{n}^{T}}\end{array}\right] \left[ \begin{array}{ccc|c}\sigma_{1} & & 0 & 0\\ & {\ddots} & \sigma_{k} & 0 \\ \hline 0 & & 0 &0\end{array}\right] M=\left[ \begin{array}{lll}{\vec{u}_{1}} & {\cdots} & {\vec{u}_{k}}\end{array}\right] \left [ \begin{array}{ccc}\sigma_{1} & & \\ & {\ddots} & \\ & & {\sigma_{k}}\end{array}\right] \left[ \begin{array}{c}{\vec{v}_{1}^{T}} \\ {\vdots} \\ {\vec{v}_{k}^{T}}\end{array}\right]+ \left[ \begin{array}{ccc}{\vec{u}_{k+1}} & {\cdots} & {\vec{u}_{m}}\end{array}\right] \left[\begin{array}{c} 0 \end{array} \right] \left[ \begin{array}{c}{\vec{v}_{k+1}^{T}} \\ {\vdots} \\ {\vec{v}_{n}^{T}}\end{array}\right]SVD算例U：$AA^T$的特征值和特征向量，用单位化的特征向量构成 UV: $A^TA$ 的特征值和特征向量，用单位化的特征向量构成 V$\sum_{mn} $ :将$ AA^{T} $或者 A^{T}A 的特征值求平方根，然后构成 Σ以矩阵$A = \left[\begin{matrix} 1 &amp; 1\\1 &amp;1\\ 0 &amp;0\\\end{matrix} \right]$第一步 U ，下面是一种计算方法对矩阵 A A^{T}=\left[ \begin{array}{lll}{2} & {2} & {0} \\ {2} & {2} & {0} \\ {0} & {0} & {0}\end{array}\right] 特征分解， 特征是4，0，0 特征向量是 $\left[\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}, 0\right]^{T},\left[-\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}, 0\right]^{T},[0,0,1]^{T}$,可得到 U=\left[ \begin{array}{ccc}{\frac{1}{\sqrt{2}}} & {-\frac{1}{\sqrt{2}}} & {0} \\ {\frac{1}{\sqrt{2}}} & {\frac{1}{\sqrt{2}}} & {0} \\ {0} & {0} & {1}\end{array}\right] 第二步 计算矩阵$A^TA$的特征分解，可得 特征值4，0， V=\left[ \begin{array}{cc}{\frac{1}{\sqrt{2}}} & {-\frac{1}{\sqrt{2}}} \\ {\frac{1}{\sqrt{2}}} & {\frac{1}{\sqrt{2}}}\end{array}\right]第三步计算$\sum_{mn}$ \Sigma=\left[ \begin{array}{ll}{2} & {0} \\ {0} & {0} \\ {0} & {0}\end{array}\right] 最后， A=U \Sigma V^{T}=\left[ \begin{array}{ccc}{\frac{1}{\sqrt{2}}} & {-\frac{1}{\sqrt{2}}} & {0} \\ {\frac{1}{\sqrt{2}}} & {\frac{1}{\sqrt{2}}} & {0} \\ {0} & {0} & {1}\end{array}\right] \left[ \begin{array}{ll}{2} & {0} \\ {0} & {0} \\ {0} & {0}\end{array}\right] \left[ \begin{array}{cc}{\frac{1}{\sqrt{2}}} & {-\frac{1}{\sqrt{2}}} \\ {\frac{1}{\sqrt{2}}} & {\frac{1}{\sqrt{2}}}\end{array}\right]^{T}=\left[ \begin{array}{cc}{1} & {1} \\ {1} & {1} \\ {0} & {0}\end{array}\right]如何通过Matlab和PythonMatlab：1234567891011s = svd(A)[U,S,V] = svd(A)[U,S,V] = svd(A,'econ')[U,S,V] = svd(A,0)input: A 矩阵output: s:奇异值，以列向量形式返回。奇异值是以降序顺序列出的非负实数 S： U:左奇异向量，以矩阵的列形式返回。 V:奇异值，以对角矩阵形式返回。S 的对角元素是以降序排列的非负奇异值。 右奇异向量，以矩阵的列形式返回。 Python123import numpy as npM = np.array([ [1,1,2],[0,0,1]])U,S,V = np.linalg.svd(M) 应用举例应用 2.1 信息检索 2.2 推荐系统 2.3 基于协同过滤的推荐系统 2.4 图像压缩 特征值分解和奇异值分解的区别 特征值分解只能是方阵，而奇异值分解是矩阵就可以 特征值分解只考虑了对矩阵缩放效果，奇异值分解对矩阵有选择、收缩、投影的效果]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>SVD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python库]]></title>
    <url>%2F2019%2F02%2F24%2Fpython%E5%BA%93%2F</url>
    <content type="text"><![CDATA[开始接触Python是大二结束的时候，到现在都快两年了，其实一直并不是很细节的学习，只是希望能够跑个结果。不过呢？，以后肯定是会经常用Python，所以呢？我接下来会认真学习Python Python 高级用法总结基本数据类型：整型、浮点型、布尔类型 容器： Containers容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）在Python中，常见的容器对象有：list, dequeset, frozensetsdict, defaultdict, OrderedDict, Countertuple, namedtuplestr list推导（list comprehensions)官方解释：列表解析式是Python内置的非常简单却强大的可以用来创建list的生成式。 1对于一个列表，既要遍历索引又要遍历元素。 123array = ['I', 'love', 'Python']for i, element in enumerate(array): array[i] = '%d: %s' % (i, seq[i]) 12345def getitem(index, element): return '%d: %s' % (index, element)array = ['I', 'love', 'Python']arrayIndex = [getitem(index, element) for index, element in enumerate(array)] 迭代器和生成器可迭代对象：凡是可以返回一个迭代器的对象都可称之为可迭代对象例如：list dic str set tuple range() enumerate(枚举) f=open()（文件句柄）123456789### 迭代器(iterator)是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常### 生成器(generator)生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立）#列表生成式lis = [x*x for x in range(10)]# 受到内存限制，列表容量肯定是有限的#生成器表达式generator_ex = (x*x for x in range(10)) 生成器： 不用创建完整的list，为节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generatorTuples:() 字典：{：，} Sets: {,}函数类 Python库——numpyWhatNumPy=Numerical+Python主要是提供了高性能多维数组这个对象，以及处理相关的方法 How 自定义一个（1D or MD)数组或者特殊的数组,一维，二维 数组切片（也就是提取数组元素），注意 a[:,0]和a[:,0:1]是不同的喔 关于数组属性的方法 数组运算 索引 where 函数 索引的布尔数组 广播（Broadcasting）用于处理不同性状的 数组。 Broadcasting提供了一种矢量化数组操作的方法，使得循环发生在C而不是Python。标量乘以一个矢量的时候，用Boradcasting更快，因为 broadcasting在乘法期间移动较少的内存 array 和 matrix 选择哪个? 戳我 矢量化和广播、索引在Python中循环数组或任何数据结构时，会涉及很多开销。 NumPy中的向量化操作将内部循环委托给高度优化的C和Fortran函数，从而实现更清晰，更快速的Python代码。stack|vstack|hstack 1234567891011121314151617181920212223242526272829303132a = np.array([1, 2, 3])b = np.array([2, 3, 4])np.stack((a, b))array([[1, 2, 3], [2, 3, 4]])% hstacka = np.array((1,2,3))b = np.array((2,3,4))np.hstack((a,b))array([1, 2, 3, 2, 3, 4])a = np.array([[1],[2],[3]])b = np.array([[2],[3],[4]])np.hstack((a,b))array([[1, 2], [2, 3], [3, 4]])% vstacka = np.array([1, 2, 3])b = np.array([2, 3, 4])np.vstack((a,b))array([[1, 2, 3], [2, 3, 4]])a = np.array([[1], [2], [3]])b = np.array([[2], [3], [4]])np.vstack((a,b))array([[1], [2], [3], [2], [3], [4]]) mean123456a = np.array([[1, 2], [3, 4]])np.mean(a)np.mean(a, axis=0)np.mean(a, axis=1) reshapereshape(x, y)，其中x表示转换后数组的行数，y表示转换后数组的列数。当x或者y为-1时，表示该元素随机分配，如reshape(2, -1)表示列数随机，行数为两行。 123456789格式：np.reshape((x, y, z))参数的含义：x：表示生成的三维数组中二维数组的个数y：表示单个二维数组中一维数组的个数z：表示三维数组的列数 numpy数组去掉冗余的维度——-squeeze()函数import numpy as np a = [[[10, 2, 3]]] a = np.array(a) a_sque = np.squeeze(a) print(a) print(a_sque) Python库——pandas记得学习pandas是在大三时候的美赛，花了一天多时间学习pandas，然后预处理数据，当时三个队友都是各自的家，是非常愉快的！！！ whatPython Data Analysis Library 三种数据结构序列： Series 1D数据帧： DataFrame 2D面板： Panel &gt;2D 自定义创建 可以通过字段、数据、series、列表 列表传入的时候，主要行列，如果单个列表：列；如果是[[],[]]是按行[] 如果位置不对可转置 创建空 pd.DataFrame() 选择区块 a) Series [] b) DataFrame 列选择 [‘colums的名字’] 行列选择：.loc[列名,行名]名称 .iloc[列索引,行索引]整数 array.value 统计描述 .descibe(include = ‘all’) .head() .tail() .select_dtype(include=[]) .columns .dtype 缺少数据 查看缺失值isnull() notnull() 也可以 做一些统计，sum, any,all 清理缺失值 dropna(axis=0)：axis = 0:index axis=1,columns 填充缺少指 fillna() 标量替换 替换 统计函数 Pandas 函数应用表合理函数应用：pipe()行或列函数应用：apply()元素函数应用：applymap()eg： pd.pipe(lambda x: x*100) 类别变量向量化非数值类型的处理方法 时间序列生成 data_range pandas.date_range(“11:00”, “21:30”, freq=”30min”) 参数1Return a fixed frequency DatetimeIndex. Parametersstartstr or datetime-like, optionalLeft bound for generating dates. endstr or datetime-like, optionalRight bound for generating dates. periodsint, optionalNumber of periods to generate. freqstr or DateOffset, default ‘D’Frequency strings can have multiples, e.g. ‘5H’. See here for a list of frequency aliases. tzstr or tzinfo, optionalTime zone name for returning localized DatetimeIndex, for example ‘Asia/Hong_Kong’. By default, the resulting DatetimeIndex is timezone-naive. normalizebool, default FalseNormalize start/end dates to midnight before generating date range. namestr, default NoneName of the resulting DatetimeIndex. closed{None, ‘left’, ‘right’}, optionalMake the interval closed with respect to the given frequency to the ‘left’, ‘right’, or both sides (None, the default). **kwargsFor compatibility. Has no effect on the result. ReturnsrngDatetimeIndex12345678910111213141516171819202111. DataFrame.stackParameterslevelint, str, list, default -1Level(s) to stack from the column axis onto the index axis, defined as one index or label, or a list of indices or labels.dropnabool, default TrueWhether to drop rows in the resulting Frame/Series with missing values. Stacking a column level onto the index axis can create combinations of index and column values that are missing from the original dataframe. See Examples section.ReturnsDataFrame or SeriesStacked dataframe or series.​```pythondf_single_level_cols weight heightcat 0 1dog 2 3df_single_level_cols.stack()cat weight 0 height 1dog weight 2 height DataFrame.value_connts()返回序列，index=统计值，值：统计个数 Matplotlibmatplotlib.pyplot as plt 窗口：figure: 一个窗口，plt.figure(num=,figsize=(h,w))下面数据都属于当前的figure,有一定的顺序喔 画图：plt.plot(x,y,color=,linewidth=,linestyle,label=) 标注信息： plt.xlim((,)), plt.yxlim((,)),plt.xlabel(),plt.ylabel(),ticks:图像的小标，plt.xticks(),plt.yticks([值1，值2],[r’$值1\ 对应的文字$’,r’值2的文字 \alpha]) 坐标轴：axis gac=’get current axis’ax = plt.gca() # 轴# 获取四个轴ax.spines[‘right|left|top|’].set_color(‘none’)ax.xaxis.set_ticks_position(‘bottom’)ax.spines[‘bottom’].set_position((‘data’,-1)) 图例：legend: a. plt.plot(,label=), plt.legend() b. l1, = plt.plot() plt.legend(handles=[l1,],labels=[,],loc=’best|upper right|’) 注解 annotationa. 点的位置(x0，y0) plt.scatter(). plt.plot([x0,y0],[y0,0],’k—‘,lw=)b . method 1:plt.annotate(r’name’,xy=(,)起始点，xycoords=’data’//基于xy,xytext=(+30,30),textcoords=’offseet points’//文本基于xy,arrowprops=dict(arrowstyle=’-&gt;’箭头,connectionstyle=’arc3,rad=.2’)弧度) Bar 柱状图plt.bar(x,+|-y,facecolor=””,edgecolor,)|# ha horizontal alignment 对齐方式for x,y in zip(x,y): plt.text(x+0,4,y+0.05,’%.2f’%y,ha=’center’,va=’bottom’) 很多自动 subplot(总行，当前行的列，总的按最小分的第几个)subplot(,,)index reset_index:限于DataFrame set_index index scikit-learn官方教程绝对是最好最棒的选择，有简单数学推导、直观立马就能上手的案例，还能提阅读英文的能力喔，实在是一举多得啊！！！！ scikit-learn.org regressionFeature selectionMethod from sklearn.feature_selection import VarianceThresholdsklearn.feature_selection.SelectFromModelclass sklearn.feature_selection.SelectFromModel(estimator, , threshold=None, prefit=False, norm_order=1, max_features=None) seabornseaborn.jointplot(x, y, data=None, kind=’scatter’, stat_func=None, color=None, height=6, ratio=5, space=0.2, dropna=True, xlim=None, ylim=None, joint_kws=None, marginal_kws=None, annot_kws=None, **kwargs) Parameters x, ystrings or vectorsData or names of variables in data.dataDataFrame, optionalDataFrame when x and y are variable names.kind{ “scatter” | “reg” | “resid” | “kde” | “hex” }, optionalKind of plot to draw.stat_funccallable or None, optionalDeprecated**colormatplotlib color, optionalColor used for the plot elements.heightnumeric, optionalSize of the figure (it will be square).rationumeric, optionalRatio of joint axes height to marginal axes height.spacenumeric, optionalSpace between the joint and marginal axesdropnabool, optionalIf True, remove observations that are missing from x and y.{x, y}limtwo-tuples, optionalAxis limits to set before plotting.{joint, marginal, annot}_kwsdicts, optionalAdditional keyword arguments for the plot components.kwargs**key, value pairingsAdditional keyword arguments are passed to the function used to draw the plot on the joint Axes, superseding items in the joint_kws dictionary. Returns gridJointGridJointGrid object with the plot on it. http://seaborn.pydata.org/generated/seaborn.JointGrid.html#seaborn.JointGrid g = sns.jointplot(x=”x”, y=”y”, kind = ‘reg’ , space=0,color = ‘g’, data=df11,stat_func=sci.pearsonr) sns.set() sns.axes_style(“darkgrid”) sns.set_context(“paper”) https://blog.mazhangjing.com/2018/03/29/learn_seaborn/ https://blog.csdn.net/weiyudang11/article/details/51549672 123456789101112131415#初始化类g=sns.JointGrid(x=&apos;v_ma5&apos;,y=&apos;price_change&apos;,data=stock,space=0.5,ratio=5)g=sns.JointGrid(x=&apos;v_ma5&apos;,y=&apos;price_change&apos;,data=stock,space=0.5,ratio=5)g=g.plot_joint(plt.scatter,color=&apos;.3&apos;,edgecolor=&apos;r&apos;)g=g.plot_marginals(sns.distplot,kde=False)from scipy import statsg=sns.JointGrid(x=&apos;v_ma5&apos;,y=&apos;price_change&apos;,data=stock,space=0.5,ratio=5)g=g.plot_joint(plt.scatter,color=&apos;.3&apos;,edgecolor=&apos;r&apos;)_=g.ax_marg_x.hist(stock.v_ma10,color=&apos;r&apos;,alpha=.6,bins=50)_=g.ax_marg_y.hist(stock.low,color=&apos;y&apos;,orientation=&quot;horizontal&quot;,bins=20)rquare=lambda a,b:stats.pearsonr(a,b)[0]**2g=g.annotate(rquare,template=&apos;&#123;stat&#125;:&#123;val:.2f&#125;&apos;,stat=&apos;$R^2$&apos;,loc=&apos;upper left&apos;,fontsize=12) 颜色和风格设置调色板主要使用以下几个函数设置颜色：color_palette() 能传入任何Matplotlib所有支持的颜色color_palette() 不写参数则默认颜色 current_palette = sns.color_palette() sns.palplot(current_palette) plt.show() set_palette() 设置所有图的颜色 sns.palplot(sns.color_palette(“hls”,8)) plt.show() 颜色的亮度及饱和度l-光度 lightnesss-饱和 saturation sns.palplot(sns.hls_palette(8,l=.7,s=.9)) plt.show() xkcd选取颜色xkcd包含了一套众包努力的针对随机RGB色的命名。产生了954个可以随时通过xkcd_rgb字典中调用的命名颜色 plt.plot([0,1],[0,1],sns.xkcd_rgb[‘pale red’],lw = 3) #lw = 线宽度plt.plot([0,1],[0,2],sns.xkcd_rgb[‘medium green’],lw = 3)plt.plot([0,1],[0,3],sns.xkcd_rgb[‘denim blue’],lw = 3)plt.show() 汇总http://seaborn.pydata.org/api.html# https://github.com/mwaskom/seaborn/blob/master/seaborn/rcmod.py https://xkcd.com/color/rgb/]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的读书笔记]]></title>
    <url>%2F2019%2F02%2F22%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019 第十五周三月份至2019.4.9这段时间，才发现我是如此没有自律的人，充分体现了我是人的特性，那就是我是群体动物，苦笑.jpg,苦笑.jpg, en, 最近突然想给自己打上厨娘的身份，如果可以每天花两个小时做饭就好了 愿你被世界温柔的相待 接触的东西越多，越深入，就会发现我是如此的菜，开始有些知识焦虑了，知识那么多~，可是我只有一个头脑啊~ 开始不想写一些特别低俗的博客了，一是觉得浪费时间，二是输出效果太差，引不起特别大的关注，虽然我写博客，完全是站在自己的角度，没有考虑读者的意愿，（滑稽.jpg)。 现在的自己，不是停留在基本的问题上，更应该去探索未知 的知识世界，虽然离这个flag可能还有几年的时间，能够给世界的知识创造一点点价值，哪怕只是一小点点。离这个目标还需要努力啊！！！！！ 我想我应该去记录学习知识的过程，突破更大的更困难的问题。 2019-第四周读书笔记 这周读了一本小说，是张爱玲的《倾城之恋》，原来和电视剧的何晟铭主演《倾城之恋》不是同一个事情啊！ 看了《阿甘正传》，“生活就像一盒巧克力，你永远不知道下一颗是什么味道。“这是阿甘对生活最好的诠释。小时候，有人骑着自行车羞辱他，他只会跑，拼命的跑，只会再公路上跑。长大后，别人骑着车想打他，阿甘还是跑，但是这次阿甘学会了网草坪上跑！就被大学看上，进入运动大学，还通过参加比赛赢得了冠军，然后，阿甘当兵了，再后来，打乒乓球很出色。阿甘似乎做什么都能成功，也许心无旁骛，最笨的方法+时间=收获。 我觉得很心酸的是，当珍妮告诉他有儿子时候，阿甘问，”他聪明吗“？ 2019第四周安排 改论文，改变自己的办事效率喔，拒绝重复工作 编程能力 慢慢的做事情，先慢后快， 生活、学习、交友、文采2019-第三周读书笔记这次读了《极简思维：颠覆传统思维模式的极简法则》作者：S.J斯科特 巴里.达文波特 我们生活充满了各种诱惑、杂乱信息、导致了生活的混乱，产生知识焦虑、年龄危机、人际关系的淡化。作者给我们介绍了许多问题、许多的解决方法，让我们这个信息爆炸的时代可以过的充实些。 每天睡8个小时、还剩下16个小时，在减去2个小时解决个人卫生和饮食，那么还有14个小时，一个星期98个小时。那么98个小时，你投入在哪里呢？ 总的来说，这本书传达的东西，我还是很喜欢的，极简主义者，少不得也多不得！！！！！！！！！！！！！！！ 读《拆掉思维里的墙》摘录 ：我们的生活也由三个支架组成：自我、家庭与团体和职业。这样的支架支撑着我们的灵魂，它在记录我们的生命。我们一直都在调整着三个位置的平稳，使之成为最稳固的联动三脚架。 这句大概是结合我的经历，最具有感悟的。因为一旦走出大学，这三者才开始真正的组成我们的生活。 古典老师，从职业、成功学、爱情、家庭等等不同的案例，给我分析了大多数人会面临的无形的”墙“，给了我们如何拆掉这些墙的方法。但是呢，对于古典老师的爱情观点，我并不是很赞同，因为呢，那些愿意陪你度过余生的人付出的感情，是如此的廉价吗？有的人既可以是白玫瑰，也可以红玫瑰啊！ 2019年第二周安T排每天两个小时阅读论文或者专业书籍的阅读开题报告修改和PPT制作（3h)《拆掉思维里面的墙》（3h)看哈利波特（一集） —-2018年的总结 小小的悔恨与遗憾 大三下，在课堂上，打了半学期的游戏 生活还是不规律，超喜欢深夜逛知乎、刷B站 额头上，不停的冒着痘痘啊 英语单词量在下降ing 运动量在降低喔 很讨厌洗衣服 相比于上一年进步的方面 愿意去承担更多的责任 更乐意去交流 越来越重视健康style 不会随意发泄自己的情绪了 更加认识到自身的优势与劣势了感到愉快的事情 知道自己想要什么，知道自己在做什么 整理完了大学期间所有的东西，往事不堪回首， 但也只能是柳暗花明又一村。 能读研究生了 聊聊2019年的点点期许学习上 多看19场知乎live 阅读10本书籍，书单也有了 在专业学习上，希望有所提升咯生活中 早睡早起身体好 看十部美剧，尽管我最大的兴趣是睡觉 时常更新歌单，不想在一年里面都是相同的旋律 静静静静静静静 合理安排 折星星 番茄闹钟 偶尔听听 TED技术 清理下了github 仓库 重新更新了 github page 多读、多写、多想]]></content>
      <categories>
        <category>读书日常</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MayMay]]></title>
    <url>%2F2019%2F02%2F22%2FMayMay%2F</url>
    <content type="text"><![CDATA[https://www.kaggle.com/dgawlik/house-prices-eda/datahttps://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python]]></content>
      <tags>
        <tag>wan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习の历程]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%AD%A6%E4%B9%A0Daily%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. bc22c968cb171bdb745a70dd5992a9aae40f0ef3132c808f1da14043ee958366bebcd7c4bed63503d0ee5777ca03627f18cc761d7e6840509ff54b88de7d6b22171e2590b94ba2c33dbe623b9af18b99d28b707857311cb2adaf74ce3514e7d4fc67c18c0835eda4a38e0c524bac1fe256fabdd88a2159aad13d9f73b5149db400f57f7fedf4668c0c9140494b337984d2fb04bc01a20ecf2df180d279da82eaf1fa028a0ada710180e0b426fb960a6d0025b9629b050d4f359ba25a01c8ef613f60f667c002c1faafdb63095e267deedee5b7f9b7bec18c2275080dfa522a86dbe5d84dd9e8a9f21fcd6ef25e049759d6f8cdaf2ef4737fd94d366697985f6c870633e9ce0f0b72843fe7b185f42013c1c514e4542fb7c35234c597ab445b0e9a81c4904278943c86739cf2ceec65f223e25f17c72a2ecb90b42da18c50aa99e50c3a317546ee05e73993ce19e39462667eee780e807e9d5296684387f8f7f5b6994449aec19ab07b76abeec7334ef75f9e8ac7d5fc0affcef28d66413af248b1fd404965b2016f84f8085b52e6bd72fa4c5f2d2bc33915adc04de08e18a8526fe05ba3aa8a607c871f57aec6271dd7856571c1a45908e3c84339fff2a0daf59c727f472c707715ed9dfb3af79c07a397297998657fa17ddb13868d960b21ecec87e04e1dde37607883999b24842b3f4e138515b569eb15414fd652a7a0af3c533bb1997e609d02781cc0bfe7c43b9563697b125188d8b055feea978d56415aef6632f8275e3acce8a8a5ebe3c686388e46eb1d5212ebe8a23beb329cbfe21a8e0d1116eedb4c4325ef9ca8d7ae30275411aade8df025575fc0c597dd978fef6e4596d64e34352a9026af06159341add8973d78eaa621441d88ee9c79816126ec79f67289b979952b33edfd834309554e2dfd5c501c2d8cf55c3710d0f8d47d13ea1cd3366212edea20582a4106075b96063ff35c8bb184624c7e850896ae65c704a51528307a9ec340bdd5553186ad10346192f65c7a7c3e20448b9be38fd365bcbed2b4658a08d33b1671c1580742cb13744e855b54ce568c78dff50be7153ea985c2f987079da89d963a96fa56db7401621d0abab7710f8aeeb3297a51ead97916566797c74761fb9f5d1fe95df3ab1d620251ec77f6e97ad795fb87fdc42d20f9db735dbd5d8c8866638743a0cc11574f0fe7f0a034fde30211892ff7412309df51bd4258ed4cafe215e7c67ae63d4ec558b358ca39e406c70723e4201d3b721ffc1d39daa1337301601a900881f240bc69d46aa2462a45da9ace647ebe8f7a3f1f18bad045867dace3f9abaf9ec76f19b1a5d42322713798ffb4fb7b023e9a08b233ae099bb8a542b63e205333406f26536f8f68403f57fc77ec28e2d090dcb47584647d51c6fe11b4e3a7f5f0a24d13270e822996e2b5d11e88d59284c217c218b4a329b9581b56f5784a38adad89aac588b888c51ae7b2b1b02ceb0ebce3e843f750bba7c146387aa5cabc3826625abbd0551e8c9361250c13ba9e0522fa92026a2c2ab65812552906477724b2e003fdf03dcb825dc03e3d1dc9c8452f50f793142fab1dab83bf33c76b2a5eb61777a164d9789a29c82f337639326e240501f31792c99ac9d0cf1a8b937d785bdfdda091ac1e70a3062380cc93c80c9afe86ad131714565a20e887ac9742e2faf152633c15992377506f9d7ead547fecf04de7e15738a8c292f14bd05055b9341dd2ee9a698d71e3c79d6b626134107689d56b9eede35b9bee336968fe97b91b4e3fa5f79140c0a1f86e6e3deba6860d3ab3dc071980560fc69e1a6234c6d15097efdc9da596df265ec28472ebc23d032b6845a265b0f4c6552aa187e41079bf18c67afdffda9c13f4406007a40d0b62cef78f8ba679e83bf2f29ab822a4661b9e92be763e04f3b165ae4a3b593719d94891919e624d14e91eda07dfe844354b9829181b67c59b78a7ea10c31395a892fa8c1aa40d6a28542aabee6a98e2221b4c8ff7f7915dacccde55670178fda4a43eeec2f2bee834f18a107a634534addbc642d3fdc5893b607876cec2350e056fb5f9982328b9de647cd633526f3a12702dd61eba835220b0822d0f80b33f1aae1ec9794b381a0f3e7f1ee3659076857f7fe95bbdda5db1b37c452296bf4faadaa3056cd2149fb7486cba951e48390fce0cf95e187775fac2e770380bf9263b72465b84885ee85312bfe850e0d50c88ef4ad1558ba036021df37442c5eb6ea2dd35616113e33e4f9bc85e7c42670106b061210d1780253f67710ac1765dc60b62865254f5116e7c0fa37a28aca5e160a59b10067c6acbce870c340bd9c46d2f932d40dd46bb44048a665b75ae4659d463b1f672974a4e60224cb443633c271f7004c8e7e4b2cfa2b73dc5fdf331de7264ea20db632a4e9afab8f402a0c975016af465d3d4e72aa3bd4b9b546df5e0e89ea220793a7d14806ff5186d75d9b951375cf248eb562d88e123ee4a5163f43fed05ad0315299a8664930f84b317ff9fec0f8c985d178c41bf2797736b299a67235f6fffed816b8bf0657e2cb7759cf11c418c65d0a9c3d817be7f18030d19d97d6d0100e419c047c0e5c12c6e90c023aa4cb14c494d7fc360d8e6a332d736519c331b7913380800c5a90a3cd377ef22e620cedebb086f0098a33f8fb22865923f1d2043fbe916382e3fde18266525904c496b61a174766d3a9af69849d7bdb41e61ade47a86c6a08fb1cd8e18431280e62be4a0017a90f6140e54cf8786f4fbd73c721869537d477a690a884ed971994d69a6b8f7a66ba1de6131064d8fc99b71be22af280d7da6029b1e872114ae6144e8153b08142a7ecd2e2f0978339796a94ae37460b2664ebfd256fd36dff41d5f98c181329afcadd565a62c08017e60ffbb8c50c879443e6a9c1c1134b93f14462cae16b4cc755bb469e44b22fa2cb8272e77b48d74303511c6e6e7b37a588a182f3c8fccba5faef301f6017825a1d0cfbbf85d6db28c0c3a6809bacb2f6c4ede95cd28fed91957af254b2f348129682748cc2b8008c0b6f26217e2ba8d0f204085aebfd6d6026e59b14d15525d532d7b0aeeb9e88fbafee68196bce4dee1e63c292f2dade4755670bbb214827a7f86d4dce76daad8c548dfb25e2aa86362471f445e051f7f288108173160b6378e1c66cf178e8ca90bcf4b75dbb5e75784e315cfda57219c8ee8393dd384782f948b93c60bab5b15d5aeb6e035f1b311e3503ca376218246b6c41872aee26f5f81463e05d5d78194175c26703ca2d8c85f12f26aec2599d6d6df1093fa27eeac82c5b00d1f46dbdc5e71255f24dc190f415a3444bfa5bf33e2582a8605b79be3e8bdeb9a8b1578f38ff00079014f0509bdff77f5b607dfe8406376df7aca0b5059b6f6d6e6e3a87bf9b988511edee0b6ba1965e6d39746a8b5e53ef699340545c94a6e763b79a6c67597b146175a20c2a6c03051b0450633717cb54e09eb1e0ecc4a28aca27ba35e4f85b0830200f814f4413370380a864e05115337f8820956029dabd9f9af187a780a298bb21ca86e88a7148cbef33a1bde20b03b32a0e36db2bc2c47b1c893c4386a7a0b4e7a98dc9e7cb100351210f0d5443d71f613bb29355d962c40c20b7962742760c6aca9d3f7f4a8ef9275c614867fb0ccf07649a0a5875fd0ead06a2523348d5fcdddbbfbd4beabb65ff802b3e0ec4b2b975fc8344a31406eb0606477c5a9de6c889c7a0fecc307cab9ae5f6a93f3d83d3f11a35c652247fe6e60c6dc4ba71ca5bfdb9c8c54fbfaa57783d7a813da3c650fa7f478a136e74eb5307e59573902fe8048f7ea596d689c94404621348990a8020658dc6c530cead69fb6cbe210ee2af0b90e4f66a24d39b293f462d88d6727555c1837ef5cb02318083cce0b7ead6ccc8ca99f488a30077cc311f0597dab48c49168a7b3fd6586816ff16177ca3c506e726b38f162e87c37c8651adeec9aba3011e28dde384b6414b07298d2a3da0c0064fbf0194ca4e120b0ebccea11a7442ec5f5accd621a0542c79996b41b6bb2f4b7e35e66147e59e62398af6085e77a7911d95d971c18fdd27afe90d314e35dba588c8b47c2880ce51d6be65c9854324c7ff6e125b4bba5d03da345bef7a20e54c55b5ad3590f78fa429efea076e440d82558f36dd494405d6d44ff9abc48f8dfe9f909d7d31094debdb78e47bf7e9aedf9ae77602135d442441bfeeda3ee0af45d5d6b3099422ec976556b62dd83156083ace33d599133aa8fa20ce7a267265d9d5388b3b8d456838c2bcc372a7f79e807748de4b7042a59a7036d931545d71de7de1ab3cb7b66dc55e93947d8b16faadc15f70d316237926a9f902f522a2bbb2187e4dcbffe510c2cf222e5a1f4bbec8bbfa251ec89096800dc183cf09cba208f18077db03bfaca9a2befb1556ba6dc184ac5f81f1b1d17df97c13b73b1b22b10d72977710f38c9335aabe376fb95f138f7b0e5d3bb5c90d5b6143f3a5cc45df7551569191b25add088001bd6dc761a0766d77121f7c44e5134234bf7925a504cffe8d48b78fbdbcd777dc035a72bc07f48750321233fc14086ad6f8859768ade8699f2b2e14745a3a9d79a770094125ab8693d9f15b4d1862ec429e484e0de35cd9ae5b41a36301de7969bf9a62572c3cd8b698afd0b9e0e6746931cb09e673afbe27d73d106e5f7f0429d2a51cb51b6dc998e7907c929b240749622a74b9d68adb528d60f7d295530a0aa00737b6e788b8429d9f86d4b4991634cc13db28e80c25b21da3482929a79894cce9990df80e9c324d83493c72f59846d2ed292049510ba0e61938b9d789d28798978223500f4f142c1bd3d465faa9034634a516eca1e7c0b032adb459937b59ed733e95296b49ce965b71fffbb597e4b13c57c923e6d9ff76f76970338e1e4e51bcbfd7210d00c5758f8a28dffe816b60151a32fdd1e4548c31ca56369e1713859586f71d276148eac9bc7beb3d0ef54042100a32dce6d754b8acdd2ece12b78db88e686cc091e7e8e6e7119b13df086a9859ed91c17640e9dd78648870eeefb45d5b5be4cdae0c348a093690509eca8c0143409e1b47a4dac0c9ad49066dd4f5bca51ff05307a5534822f422f00086ff87571b2740624dcbfb760fa7e1ccf062c0b58886413e9df5b335d1dd27ede3369740255516ffd0a4f14ce8a977add2862c5294372e06e8781b16619e8504f1279d3f671faa89e99f12ca48c3c1dfa8fb78fe0d23acbb5607d57b40385b7af306820fda43d5733d2c0cccfe8c753f8343ec263dbb690e574e4cc9b32e1982e8ac5e8d6ea36ed573ab53296ea1c7a263709a58aefe17b1cb8397650f9b9beb60db91711b3cd772a163d58570801d3c109a21daf6a65f2b0a1e82374fb672b04a36b873791bcf8134baf8ff4a716f380d887d179ddb05fe0780b8a54f71230ec96e45115106412e51742460f6d4293d85b0a1519cb508ce17d1ac0fcd4b5fe9428615967bfa4ace0cc5a2020dbdf4ad5b39dbfa17d99f77809acd1cd604d99543203f7ade271224e06c4d5f9bd1fd3e92df8b34e9b58991afbf39f578acb7f6eef307a6778d04c1e9ae1e1cf1d715265d4297cdb554ed81255bffed8975846c4124ddf9f0a51a3b1a3e6a9579e0fe9ba0a14bbc394d5db3a11016beb7904a5dba9eafa5a10be0092338de816f1f5d8b1a2dc5e38a39fe3d94874130729c286ad622759c0cd72280a93a72d5600570ea5e64c3cbad6374f8296c4ce2bd36db645826ad748f3fb01043ab89e8d94cc1a6353fd1aa5844b86298c75ce488078535138f8784900620dc7f106fee5a683f52b9edde67c02edd1b52ee0b86220385c5c8befe611adbf8069254e6c166efbb9f56faefe95ec63bd3f0a6b051bf25d3c08a57e4878f59af97ae7f195a05014c3127dd1e944ceefecfacf8ed1aa54f69eb5556856712a51b17b6a7d6136ef38a924cc225d662b4076d98b4aa82c44d0b10c47fedb13ab5905ff0c78eaa6818937bbefcc586585efd02fc37ebc68bf56eee5ab46d701ce61929d1bea8cb4748f1ed1f6457d65c33ee612cc151154c90ea8ca74ad0a68b88f02fa02640e742f5addbf8a8b97f0dc09a270e529788be947e7658ec4d36c49a107075e0951a499665ff10b82027d9ac97d8e14a90ea4c9bd0ba0ed375b74781fd6f0852ce8b6745bcb70ac2eca2cfac2ce815262544c7d03e950d3080c411c2460195663958d7af81d5032239c09ab5ca9d7cefb7a59751d07a81628b0b5df23cf692dd92f36b030a4b097fb942f2f906a9ad5a1f45fccda059cc404a102467e9a01801209d6f7bd1cea6914b291d28eadd26c2bb97dc4f5f463c7e6d979ebcbe293b9c3bdc4b8998c5f63e4cfc4a03f728e221aa15bf3b23bd3c06b1e8b325b575db42f6e2aea9199273464da93aafcf2717b62ded5314259609f6ab3a04baef24a837042decc546aec4df480c02bbbbd148fbd92670fd0362abf9fc3ba2a867f4b93bdf1d2f372e446b74a175f6055d2ee90efe704047a909c6b3b8f38f070ade11e3d659a3b1a4d18cb5cbb6f10516c74f425dd6d39f3ef874a120aa814558e005ec7199ad16b64283d24b720f7bbe4e0d4c9cb23ec1072273784c7cab33de19a3b14495285295ce58441fdca6c48749cef6eeff8c211ffa5d52ca28de8af69d525773f95611b50681f91bc71a7f57a21c91b8a0f4bdbf8fb43abf30b869e9f6f770a0044e11e85f8b93858fc0078d3e99a092f3f97e855617abe1d27073c219aee36e87244e465fca0c79b349f795016ae73a13821f225243be0968c42a3e61c560f3c141c6a6b87ea755d81d5ab38d2340100f82deaf875e4a0d149dcda60b08a9c533470f5e0086a31b2718c28b760cded43adceebb653420f012ce97526b1457598512c0e6625deb59bf0a4163d14f85eb7acf3a97a03402452222b1ac7a5c18a3dea86aac314c873c6504af03303fb3953646800aab699456d36a68f58e40659f2ad56006522df970aef22e85194b0f1d90613b7720ff555c5e4f8136071c0da150277c3922fc09d2fc11c5c39e6462c444790dc46dbc80609a2754a6cbf5c8ea5d97ca053ad67bc6fe3fe00f6e7af0db05385bd2f3284c52b3d695b6b360419ce529d60cc06c412efe701b3e5e067ee3fdcd947b11e8caa3b4511062940d2ef875e225810c75c64f706cf5d799fc41629da14ee15397a896f57412c1079c76c3c9b90a8d52ea9f95f2f66e79ed9d1a4bf7cbd9a5e4a1d8e17a52287460b062cf6f13584e09d3142192d5917a387cda3d561d0645f25977f5623373015856f0c47eb7969fc79616ab70e68fd3ccfa22bfeefd603064d296d2c0527409db2cf567803f30493606aa643e8eda2ce6918ad3202a29770671f5f9d1920845296a3c3668d55d71bbc9996b1347b91f86dd93812832881bfe8b95d87eb028eaef43b1b6c3cfea766213fcb81ce29be20bd1820db2c967d46e2a6cd0cc56b56c138d002f21cb89a0270d67ac4267472279b6bf8d7e8488c502b401ecc7eaed6bfeac3c7da5f1005599561ff2a3404d852db290ba9e5e01ad6ea1b65aa2b558af8189e46da07f304904124d27640713e3fa1a223c998c62a002529b29437df5e21b168508abfc5023870063b48b772eac320fcb73b9a65a1b11370adb4c3ff98c4c4acd7b5f8a4f11f0915cff708761c2e645c2e050628bf2077807786d2e63789201490a001f0ab0d1a0989330ab15667f14f6d0ccd8e813acd3f4f1ec5ec8ba1dd113372b547dbd359dac5abdcf6a2d13892c86e988988ce334f0de035a897f2aee901ea79239986e522a61185c3834299bd8574329cf6e69ce2a581489dd3ba09ec91e6247518356890189bda7cbec6c0b1a27dad92d5570aac8c859137105e752bdcbcae894c90b1a6da12e6b105b4be9c74517e5fb1308b98bff8d380185830aff88387c3b3dc2d64e44778e7ffededff2d239f46de673521a64e4f6b1d5a1611ae08716eb012d1020cd92cea30df4afcd00f36c2d340577d5e82bf5f8c0bb6f6d5d4a0dd00ee9a649bcb6d69d735bf308789283a42e46b1188c11f99d238a85dfb7f0fc5ce0919d77551da2fb1ad16a5a5aa5d1ebfd0019c63a455e36b72f7f6d0997aad251f3f6a41ad4c69074c626c09cf17d092a6e3ec11fd396793b1e6f0febcbeeef715809c675207a87497e7fc47629b4185395de2d634124ed8e1344dc685c0c68881f0aa2f8bd1202c81fcf0f3ac89059311c02f9abeb738f4c6d8810775009abc2a941776b94504dbe3c0bdb75ca64dfb784e9c8c2a00d44d90d47bd42cc75df922d7111d5c75f8b33cdb2d81f86f063b86ee74d9c95b2410715d2180518382704a546bb076d774b469fc71759cff8e9e7130818f9e88b16c1c861b4e4cd2564a44c5cbda86e665a40c945f76e22ad7bd946e7d8c9a0f62d07c341cee3c0ede5c38a92d9d12e99ba3146b3b5c835ba3f0065b4bef9e734f5790120b6ff3676f765cbe71e363953f34afb3587a2ccd73e09520d3e4a2f0df23b2be81a1c8f2a6f1146e692e9f4aa2acad54e01907178cfc5dc23ee35fa2bc1466f68f154c6d878732b2ebd7f5b73f46c7b795514a199998b92853309f71d0b626ae28cababe6ab3ef84fa127eb042103ad1e9f4f0eb8db36587d6617c4a8f2016000d922cea57f85bae1bc73efa48a460f9d0f7719c3ec8c0a400571bcf587db793f21289f10bb01eb09a9611dda3d2fb0f95b6cacfeb8885cbe1780036b4953c0c02265f91c7b039cf60376ab9a0fa96bc27229405f3b2250e1665c84281a7802c6413c09227cade6f48600422a67fe0f32ac2561e82e3395fa60eaeb81e3e421a070fd865afb8778b4f08a28a6e3a46b7287b4209fad4b2bea5c0ecfb6b3a723d170ac82782143c955fa20e106c4d9f4d6c2e732b176ac9866f69362a015df3a814134a90bc56ee73926630b374de5f14e06792cb3aa7b2a2482c3276d0eed9175602c9015d55ca51476f7e37f5e1301f0202018741115f6450508e4888fa9be187d9a6b325d91bf3c08feb9f6a6a66d965c1ac2ed084ecb211941225fe7351652269682deca62c61fffe628316758f7dc109c4124ea3701d4782813cd03f6e6d406f9a14cd0f5c44b8ee6cc595a37a0424227aa628e3798e20056aa4831668eff7978dff9fe029ebb5af200c5410f064dffa333a15e66d30b39d9d61f9e132afa6400eea5a444c07560d35e52938058d0fe98dd3b5cfc0047e9f85b6ffff35d63808ed55a92e0365cca303fda89df6b09850721496e49996ad8e804210c371daf230a694a3e0e27fbc7f48d79801c693bb8f4e382795b18ca6aeda774e447baab620c2263f2d54b00515725ca94b53e477d8c853039d2f6355d83c11190cf5ad878a6420205f54b9484abc26fc4ebaba2508b1952fc0f70ac6231b676aa062ee4f57ff07372b5db4109ad21769c1b1840f00faabe64effe6b0a2dd3e2a823a7a581123b1cd840ae233f892247995ddcaaa7d1efd749e496e3b0f8048079a813122ff45d37c2470f3cbbb124e6178b45f746da59b3fab8212619a887e986066700d186831334756f19474056c9325ae56949a8c9779ef9cc7e519ea2fd968d63b76dce693aacf7310bdf175aaea82d7ac4ebed8e3d2b225d2bb93bb42e803662d7bda19b64e8c7441eb9d5de05b7f88fdca095d0d2bcf42bb42c925e87a2746b7eae6bbb14992931529f7eaea60a17821908d8a647a26a5b6689b0ffc113d9b5093ee809aedc75db50638671a28d6cd2293103eed08c65a094267cd711e89d423379b4cf867d79d44762d40504c52554259dc7af2e4ec2d7f088f386b1cd78e8ae81f99d8ff0abefc1bc0ce72ffb2cf1ac973fc12856c1f5944061b97b24c00ce28ab66b798190584512f9b0ef1fc54ab4153257edc33a9c48f6a657c32532f7daa507a72fe7badb221894c707172e842bf6b633e0b11b59ba8aeb75b41a98fbc48f6dce0d3090dca5cace86bd42ead930affeffe2c8d87bf3d008131ccadc250ce6ed3e95269fbc2f603956048c728cef2e34e027f868fdd6c40d30c880675d73863cace6234107a5236be0424f16fb4e58f508f42f403b40d76cf2328b15393adb7a985d73be77043478737db71fb0aa4a7cfdcee53cde8d02acb5d152d6a4e23a782303fd5dcf91c90fe2faf0b0d90bddab8e6fbe2a905e7849d01216ba5bc1f637afc5112df92a3e5b0523ed272bccab04885b03346c8d2145268211eb530431f7b0c710757054f10b523ea298d373a395543a4960c6185ac5ed99e74731f373ae7c8f85d2dee267f1b5b22f316f25a18309baa6bdf2e8f35dc4cbea97daeabd8902d3e4559a849bae1d263d2ea03f32862e62a64c0daeed901c91829f57a99e334fb7ccef6f7efc036b7c86bfb97fb4c5f19b823b5678315765b2d5f66494f6a48c4844082d4c04f3f07e2577aa36e8921a150b6f2e966df7017f16336a1462a5cc72540cc2f656df543071538d94759fe2b9fbdc8e9e12cf85ba15041803134fe4799654fc0a6bc00564733c27948d7ade9dd545f6a426fc478074c5c70a26df496c25ff39bf7391f5d16c88a3e514bb3b14cdac1bd95a52502b46af24d4e155295d4d55311cab953405c179a1b7b69b18dbf2a97b7de1cb407bbb5f0a4e702bfcc353893b92236522fa585ae36bd3097117ddf345167e734b7a6888fc723a2dd15e1563d98371c7e2bc57709fd074f9da887e0e67c65086461659da60ca283862e1927834130ee17315554694dd3530bd83957f02b09bed912ed07ec4870b0d17d08e4f006187c85979bb7322caf3d647dee3a52dad501ecd3165f184b50841ae5b406b1e589702319f9d21550dcbb6bfc5e2c2086443b0667e00eacde50437c2e1a99fe3c58f577ad500ba877565a7ef50e240622617bf18698a3dace1f341f36187a099bfe523ad4bf866df73858e5ebe2f930318132e86c6464cb33f3684b1283d82024de839b488ac1d5cb59a8b72902f143d9f24a7ed520bb718f22221dd2c9d1be74f0a9d33824bd8de8296b9290a6b37ab62a089ac9cba0739a01240b8315116a83258ed0dcb8f913ce114291fc0bd1eb19f8cb5535375c6bda7bd48108c7898055af4634c2e3c89e4fbe04b97ecadf889a13c55a9220f7d3ca23e34b16260a43a6dd1669b0226243c071d93cf93c7ed698eaa835acdfbba96c8df5212d3408bbe3eeaf93773b7d1cf990b84f291ba9cb98c735b4f8212f3fcca3205f6d6ab1430665ea8b68d03193aba1a522f8ff4a725c94064f55a649049a7d183847518b5df513bbb7ada218a2058f3da53e2efa1e647984d2a7d61e0a9c6e81b9e76140095bc05456cd011cc9a52e2b0a3f38327396cb99b331408be49f0b81d99fa16eb116344ddcb314b943cc2bf01d545d1d840faf088376d9bc96b362388b85f25d093c5f31577c3a4c97f67c34034f59db5e352fffc47ef27a5e90853c9602056f65a4d26c2085616ffcc357e0415be9f62827978e83bda025b9909902f4ddc0966d0869be9f072ed794b2cad13207832d67c3ce7dbc546a2bf00d01cacdfabb24fce397deb00454d74c8ea641944640fda986fc05e2b6835e08da4d5dac6c88ecd86fd769107a34a638565f1d8d0d16358e569f6632c715180763ae84081c5e6a60112bb73174b5e70e29d10993fa92ab9a2e022f49125ea69c53dc6073726dd21ab1dbd654432dc4c220aedf30aa2489c78f57000a11856ea85f715f8fe995918f2aa9280d723ea603496bac1a4f38850c2d5bffb5045bdf2300d69dd8d3256c2d875111ecdcc98227f65bfa83c7c32e219f3d0aa8a67289a33c328e5a1896bd35651ccc33e3e4bc6ea40003abe3a76d7a28c7c9cfb3f587329ff803e449acae5aa6e0c1ed52cfe736db14b1fd6a5bd96a112c744c1cf7e4efdc4a5ad0ac2094acc9e0f90e2d8456f8b5bbd6a1cf6b07bcc65023d8284833293435271c5ed35ec6e11ac02c6bc62081a47eee20189c3ed224b5c77182aff63f5cf6005f373bbc15433c5aedc5cebdfad70a7f75fae029936cd9cbb571137ee9e4cee4883ee1970489e58265014ec79c88807ed87e3199965ae98258f39d8f09fa17d0cade6c099dbb66218cb5f3718b07aca276e6f700e06cd7cedf9bb9f74cee757aaf7a00d232168bfc225073160ec941143f6a6f701109ce480856918841d956da13890b2ba970762c6eb661da95b3738854c370d734735a69ee55d5eaf0d3f8753176b885e658cc521d301135c2d0510fe8f018fd1f5fb7f4115a0941bbec1a96f4bdce792c03e1acce4e1591ad7b43045a7c4c55faff5f0b71ec70abc54314acf7da78d6b80c934ef3cd2451c77dd0240541ce887cd98e9f8107f5d1acb49d10e67b4077aed4fc20b9229fa689d099fc5a0fd73cc4d2b6255ee964110d87ef4a596298fbb4b312ab90b5cb558e88dd2e52577ed7b7e413dfc79f828e53bed2addf34a20bb5d9d806eef83acc970b1e155fa9df59980aab6e4ea5b33ae029a424fd0992df6d366dfabdb9e9b7b2532d954c0181d7917a19c90166eba353c3e40062caa115e81c70c71c571edbc07e7e5263b5b4617bc5743ec7ff42b7c7abc6e8a35e7c6c821cf49854686221dca49c4fe8491f043240a629cf05297960daf41c9da33926b1542779caafb03d449a3eb61ee3ba5e4c49e3449b70852ddbd3826324b6d0784112a0c2db4230124728d9fc3718c10c63c110b1810501e507d569040a6d654ce7aee7f28ddbc9eeb2c74f1663f7fdae3123eb5fe2a116db8b6a2d10201ca0eab63bdb93b3cbdf033deaf56a5f07650438d71bad9b85cd1ecab54af96f6acc7ac8520b7b78fcc1f6e742ace32fb49b9087346021b1cba7bd9800de09d70bd4e6d39c9e8309ddc7f38aec9f3b58093fd9e56c60b29910a59ebd2939c3710de0277ef6342f139e285c81b5fbd1790b888bbf57630d65c82ccfe2110ab3b50eb35c56e41a589cc4fa24276d35b485dc9dc3aa5c46e567417246f5c8a30b958ded3385e55f0ceb158f976f44e34b537e907dcb2d759b0cc54f435a7d50b902585cf492051281d3e432adf1c50ec76dfe8adcecde00c0c8f15898fd88076bd1ede1a1d2c4331eb565812d55517c4809877b932eebe49943812fafe845c8de2f09d9c854cb6f483f2c40c52d884196e4b6a86274000fa5bd86e8164a10524bf7afa570709ed85f3ce84673e9015e869c08501a374c96d3dcf83aed68a001fd511c73530b3328c2823e5dbd5e73d8bce60b0d53e857be6c961775712d8b579c9b85ce57d5f18c691ab2dd68d04ef3d35a314f5809231d79538eb1c634f4948f1815f17acf10952f3d0e80bf3e3015052cd53753bc9df8c75272a73ee8c31cb94a818875a4426293c371bfed74c8cc340d3f4cbcbdda8514d9c5ba1e7a18a028ae4bd5b53508f85f16af141d3c0d0864fb166831f04777c554a0d95484120f8b046fe1f25e851a6e168c60ef6e4d439a538c3ad3d4e8e6369e14a66004549335b30b3dee206adccdf6b10772dad0aeb2da2cb295dd3b346b69604ae127b18ebaae6ce6944b0137bcf3e7b15d004a20ec68b66ee8a0e5f321975e952aaee27a7f1bca3060838e0e40cbb147727942b23d2122c6e2cb86f2f318a0ed8fc4c47385aa98aa3ae6f1312d9be004a5caa875639757ae704b304a49904b2f24831eb4e6d2e2b586b743a4e16d9a14a7e270e4b8a74d9a6abf689eb673e85b9d7fe0f854f14ea1cde8ea2cd9f05f62b7230d3b6c8988e96a690acf67d74e4d4fa1fcadf25970f85f7eb3d008498630d38d00f7ccdc0b71d2f8c6ccf79f882323f8d5651c3116df5acb0149f0698f0cfcdd87c5035a2bfc1788cd85e6e4eb912f51101732f9f008aaf9c4977bec7d419a61da816a1a96d05e923ae063dc9d2783fdbf5b9b38bf9649da9449a5ffd0a2c4b54dc976674940c60a18cb7adb83f1ff111b557ce5935e4cf23fa4599791f7c5690070540ba76bd9543e898a1c731a9b36adde71c1a6f796dd2c32d35a569ab33b26baaf0c047e850b3580726b70924e9bac4f8130ed4015eff28c89fb5f807607682596dc327927d6c93f3ae3d54c3cad67cbf3266de2fdb41eb3973f56a5e3006ec18083e08a20ff67d001bd015103ef00d78904260b600ec020c17ad7b3a3199b472f75e676a3390057f1cdceaf60ab06fce98c43524b6e29f915da3a3c8734bd4a10ead68f7df8c79ccf6a7a0068b43709a97b2a69d27d89e0f412dd05fb00bf6ab95ba735d62a6c3163640edd7ddb08c450fd43a09846535760cd16b9de7cc5fe91b4a75e2154f984f509d36149c1006ccf41b52b8a6a60c8f131355414f250fbbd4d522a6fb2edc31287f8b5b485e9901916151e2f26984ba45202af23e2fd57937ad58093cff545394c6133b924782f80128e49b6302cfc72f429b5e6a6b3ee5c534430d6581bad2de3b0b5b95e557570791932d4c9cc00203457cbf587a6f653e9e5f5fd6fb4b0c48776aafccb1690ae3d468f8199d727c7b0e8c6ccfede41335a7df6f6b7c1b0696fb600dea57e2ada086bdf51e2caec86616798b3e7c9bc6a7b63dfc04cc6ba8f8cbf710f610aee2aca049fa50af06c1d25a80879dfbd409dca004d38e27ca351d6f2804ec63be42de9e37ba80e044fdc1261c3cc90d8219f9329ad06e99982f4bf4d3fff6241d4d0dc6f56124a0d4a24c22b616ee2b655a69d35a94cb3ac025e8a2c30682614a58bbb837affd54d2807bc8f74b57c1643002260e10815d47296156ec3105a609a0ff3e89e78db9ad23d19ef78c6dc1947ac8decbeb486865cc65d5ac67227582c3efce22dacd27da819b1aea03e30a3766152adfed6d3ed8b16e1a2e41bf7b15d7a7abf9bd53a896987be906c3a6371d36755a11a879829551078bb85abc9755a3bd1526a67370af8b95c5fd6b8b4503a36e3b79395d6fff6e152c172b2f26be7fa239d146b294f102cbb4db087974e712d95ca7f2cea79f22b4d09dba58fb61ae35808f8856590f694ee392c726190967606e58e7a75d0ab4f91f71bd85991d58b972551ee018129efdadfdba15c78b11e3d7ba2c1420291c730f5f229c0c219583feb37dc9e22a6d6859a592ca9af15d3cb6591d0877f5abd47b1310e330c499b71001d1c77b5d208587e018ad9450346aec847b16ae31f283f6ac1f580b8778bff96e6cdd43e9e70400c421526452e2557e79903ba799292276f859ecd176fd600d495be483dc2b6b968d0eaede0a66020d10ecebc94e2e125edc981bfc2d6380dde48ab2c551416d734e405f5a49854b65fcbba0720bcaac5f29b0420b6d924befbafd2cb4b357a86882cdf4eb16a62f48fe0a66d6730c8a4c40db2b3c803f2e5fa8fd5c1b30f98084c2c1decf718489a37e6ada99e8dc6f1534d5cf6eed2cd3dc8f241150e4a8c6b7be455c2b9b26e7c573b14b805ec0d6eda80463eb80399edffbf11e6525b54e7c86334a89e9006532db4203bb92d16654fa2daeb1a0bba0a6d7b6c837398a9bd8841925590e2c20217271ac2626e4a24a9665da14c6d41c648778c03295f458baaf15319a846e41d312ed909264afb9c48fdd48e277aaba6ac3baaf98acae562c856edcf18cf3ec68c0777287a6c5c5bb4494ed0d8827e8542b1351d36eb9ab275b8fb8dd30942b707d9dbcb47f3566c774590a45a9e4a600e4adf195ed25dfc7a951c06741cb386a2c40bb56d36d6f724b18965ac20a8e351e912ff8330747e0769d42a97639c0e810ead8467289491c6b2801b7f5bd9b86ba74865c7c048142a81c9d38403a5b537895b4dd710593c4b2ab93a5d69e615182a22f7d6009f97ce7db4d2761f79ed35ba73e0c12949e7d059d4e4c733bccf1cddeae07fffdd3f3a5d4dba674c88bb8625b3a7a5647f3ab44af5425fd29e4bbc9bb53cf7c65b638991c6929758ba6b9f3c31867505166fd48e757333ddbfd594f7813849b87f9d686bac7449939be3966868f849e670d261e26dfe824f3a559b6a76d4b5e2515e8b0d9bfc41f8ced143386e04c8be7f397c8a9a5b2b434e88526c22722d619e01e4f9ac95b6b167a539f99dc52bf7823cacd745c2316bf0f1131ad033564691c3b79feab06479dfa8f4a234bd58a80d0ee69e3b45fa7c83c6db32c6fc57500c10a415f1641feba340ade1cfe6a38dff9a92e3e23a874b1e396b8d123f838217ef81616ba5f9863a58f0b5f49a093637ccacb4db56c1ad9808779d23d09b69998488f344b2dc3f6a0498f3e26f9913a316b92e727aed8786ed2af3b0d67973773358679caf9d9517313b5fc9a15030037bb3374cf2745fd322396278c7e32ca2bed2d06174af5f75f6b6908d16744eb5290e69aa30dcb06038d7d47fb9b177c8981bff061b154b1b7230b38e1c075cde72710986803f56efeeb57fbdcfad80856e20f29bef3692d9ff91977b8c92e6e45dfdd2a594e576c9e8024a2a42ae586bce5c4876f237267aeafabc8368a0e413acfad2ed4c2491a2dcf108733a0a17c0be869392cef40d662c5e4a861c79bd7b133bc88a3a2bb27d154e99e91d61f1a6011f5e68ff8f982bcb0c3a10330a8be6e21f459e11bdb46d9f3be5eaa2b72eb4dfcc9a2455d18b45d868d64908e8e825cb38273c352bb8d9f586affd7edb5f3611bc3578d42bdde3a90e5bc46ba9e9d5efe40bf970d4cadad61de0bb8595784e0c6f97d76f8cb825d66f4048c6f689f2507d92224c40e1af0e84b2698c06929f75ffc105d5445c553cd68fbc34641b1048388844b9c3d095f83d4ca23321a2ef592b4aac72bb549e0942641805e2f996abd0349f96056130b35e60b564e480f1b429f8d3c957291cd527d17a2b183bc2829863ded6a48f37b2ec21353bfe1a1b4f946bf756d79374ddd429d090a08bf24f0ac6d733f90079f9358877cf98062a3d6a9337d8e7b747a70308d24ac029f4834dc295ba740a5ae35194b4aca65de8293f60258bbc6382a4aa76cc5869a4369e8a870bf77394cd1ef01decde8a912c5f90bae42a8f91d69e62828b89504bc22a6e23ec094f447e63d668cb1d14b35eedffa85df9f5550015422966d870b26ea536904aa8f00a6bed29f18a43b8fd76050fd6167bba4ae9cfec74b8c1a1c8e40bf81f38f7aff25070ab17470f0d77cd48b53dc592bdb4f53a9392104bdbeccb76210fa8b510a3f63fafc029f897058bd66251bdbcb756cc75b583c0e0c6e15e1642873eba34b73b2e405d8c07aefdc7f8ad753e6b9d4e5f637c1b1c9cae625303549c41a51e8fb9fc03fc19a4185fa908edf756a6ca11db4c9bfe492eda79666bdeedd6a61eb5db7def2678fddc361414fd02fd6a647e191967296371002895821dbe443f1ac7b0c0d873d50be6c7d8e0a2230fd0e29e7e669c9d28b7218df894850c292edc5b277ab8d7bec1a7d243643dda85e8a784aa1bdf6477c3922c381b6d4131a4f7e1e4f450a9623eefd9eec334202d586de247e68d46b0f56bf6bc9a39a0f52e2d0826458dbd34c4a3aa5bb4cad8e50ae216ed463bfa51b80a58d78e25118f0a3ad1ea1b3524bec7328b46d1938ceabfe410d3feff93e176f4465720728b24ffd0f30a673f4f700abed0277296e20d227faaf582c60bd0de2f5318373bac3642ca4b370f405c750910a3de43489b1481abe649aaa932b34cb4823e14aef0c034346aaa300585cd6b45a760722dc9f997eee7a7de73effcc65a5ada55f0c0f8aa80e4d1813112377ec52fa33ea5f139c7ca4986efb284c33b445e86dbe2c3cba9fb85532d79fb47ef0c317bdac4da8432e6aac2d89f3baddde3f59c5b8260990fe6ab76ceef4d33bb582bd957fa4a2cf6852857a96a2f0dcf91b8539276c37d0a35f04eb70c00ba4cbafea268282be4e804363573234293e13ac9823be97213723ecd468a7b9cf491a7631ab9d0a968e960c488eba58037b288918e871127afad451dde04876a00387a2d33d7d9a27c6921c093602062dab3f2fb3f6b3bf1a90dddec47068f4f463ccc9865b7ee45195e66044e291bfaed653606a8417dadbe4095f59a796b95408d8e0f81008c65758a9a17db6333aac59aa63856861f0a053b18345092806eda4e5a262cea61175140fad5cebd8a59d01b368ca44b8e146b22fef8783e872d892edead6c5fb6cd704ce486068427f9510a02147eba9c20d7be7aafcdd112213a94f98a5f7ca8b453556994010e8575668976936056f4b44e2425e23b8fe5e976b388dcbca570298763af6a27e2d2f10a4c1c7d2ff51d05f7a45dc6d9323e271b96b041aa53e0e42187327f3255137c87914244a978cbef9610dc9ea4d03ab121bcba50cc0cd3891b1a5563239c103d179744aa924cbdf5594f6e1a8e58e654186515b56948fb3ad4e47e0002124bbae98ea576bae288835ce2f1122c3d92afa917f887138f1863f8a3601cdc0edde7a48276486b227036f949c49ed1bb738c97edb6712db936388700d5fb2e6ea2fc9fe0f16338f0673300eecf6535a67556c39a75576af3bc8fe3620ee3cce65c75ea11902c480f1308f03cfa2b9ed0060be2a09720da4bb02843fc473ebbf3132fd56c19723cebe809ccc1865525fd14920393064eb131181250922e77ae2ef80a777cfd359ec22ac92918d76df79d9136c76bb6eb64f4f34fdf5ca457d23679362601ae3bd9e14509427cde46bf36f695b10883a68d36151ba9ecef1d5ad918635b3c88afcaa379040862e2657a2ee01c368ccb6fc5c56a19bede783197431ae4bea9b709c1661091f051d3181b2f1fe89bd08d7f7688f8caec580cfd6e35870b432dd39f6a3dae19d3684a9b46d9d81cb6a0681b884e02d8645c426fb480621ba28c41f54890dfa000ffdae07c0540b031d4a90b6c8ed314858a9f3d66b03fc6a19f76281197c037b0935e9b98bd6f5ea9fd44044d63e24b71c16a8a195cc113e0d969e67bea1b0ba6f68a87b8d2bf647e5ca58acb3ec2a565b12ccaf412a161e698c927131fa564d32d55c744571b71d59d869ba458b39e3d0e50ec15a573248f0e6c5c7616f7693f014fc3ca3f433011b73e0f736b6600dae8e21dc257890101ef3ba1ce620964b669aab2d170b2a4a5d1e8e04075f6f5f2e1eaaa0d97dcdd40df17fd5df6aa452fdcd4713d1ae381e567564746848515620b06781617c7d2983cae3c0a9579854e4bd300d9755d66ad47c628ce3e969a43cd5fbbc30a6ecb22f87699a483f94780f851ff579a70470b5396a1eacf73c7f67d0387a2ac1478276c4bca44e13ff2da9f3d2469ac0ca8f28dfd1e1c38b24a23c8112293222dd3c3faa8ceefc7e4cb15ef22b14d6559895bac554b51341609a9003d6f3d9fc64fe58d6c9b6333f87f439418cae9cc28906a0b6478a5a6e470c7dc88955cb524faac619924b215c19f46aa375ba598516814a36eabd1e510976063b1528b5cfde27e14c4ad49b54638bc88f04e4998c0837efdb38876761e499f3c3123fa84ef79354d615e5c1330ff3b87d80bf765147df3798ed6ff954afb7763eed304de2dc217fb2fa33cd2741679053058f18eb5b0ac696d2c20f730dcf74276aeaedb66e59c69b80343b9524ea54dcf37f58bcfcbad9b51ef5b7c535526927e7e7ca863b3486a151ce672fc825aec551e5ef039cce4198d3c3fa699db26379367ed4d62a32ab56cf46634a8441dadf8201ccd21926909156f488a0370aef20feb4a92fde2f4e4b9b6c659feed2e3fc1771bf983f4662e0ef365dcf208ed22e6b9e3f5444c1f7d53f55ad3da9fed0dc39c739cc82e266d4209ace18c23e6ca7a8e26ca01d6f58bb3c4373e2d8d7c79d331f0fbf01b822926ef3c75b48a4195bca8599fb78c7764a8b1bcc9f8bc14b8d56e3667c5714efce69ed37d4488d00017ccee9d5363b0aa94917ab8f2e44519da0a573b2e3f537a5f559cecda010b5b12fdc021ac762d96e20997a2aeefdcf5b265036e3f7fff63bc219de8bef7ef5f8be8a34f3a7640318800665efb7882010aaed94e4831a317e04ee4876a83df06c0a5def9b41211ba82b81dff38eb8e520047e46d4944b5ba83888396dbc00aaf87428fb8d15e02c478f9671868eb20fe9f764818b0cad9fd01335948b7f328950823407eb4cdc2b1d29c1117c542ac3c71c5eb62a281eee7f826857848cb45c68b83a4e20cdf7402d0650680e7a93c20d6626983e7269487472d6fff2e79a18359e85eb92add1e528c69b12c930c04bf2e5634a4195c4b7017d103a88231e9a1d6a8ab1ef4499f591a0e05ef590f6ee0e873446d9c2b91156afa24a34fd91251f4bd4bc4b6d764453bcf0f4d763d736cd8b274361feb14d666b690b0d767960e1ad82c83d4ca55f71225ff2e73e9ed6145821134fbaffca0d45190799372a950f1382842b4113061ab554539229e8982aa313a2df75ff5da0b339ce00cdd4bc4819b5486b649e19bf6a1b06f2129a00eebec38b7b445df32b833a9ed9df396edaed806ecb076e62e7e853a6aeda0b3ec2b3a23472216912e03b9af65901f66e75ad9c797c6dfd7a7b15c26a4ca653e1d710ecb255344b10a0c828d7444fde8f7ccfe8db2e0a07ecc468e5d8e91fd1e98f20d3ae30549f11f8d95736c729315f9d965b8a935980bfc7a8ca6fdcd2f2715fa1c29a54bbf54929097fb389158d4f437548f47e42df0cf5688eeb68de33cd52d6f1b505492adfe50d709e7ed2eaf53ba09e9e6d8fc65a5fb2f8cc82f2c4e41280bc09bea11670e45a1a0141356695a3d3fbb38a972ad86f8799913dd3cace8aa02e3209c5275c100d69e198bb5baad52fb795283f4996dc4efd30fd5ba1e0aeeabfba2965c01bd5c79c61fbc218ce6af39ded971b731ebd5bab84feaed3db962f7b149250d2bcf9878f5bc39309e7bab0ce1d53ba4d4187f5c587260d6dd83b71abf30691324127546e28ca61c8b031f1f992137640d910e9853dc0053db87539a43a1e98b2b9a57db343129335930c181045971e2ee5044e5159db897e6e79b719768d51aa423cd3583fba34572ad2932d76039a00d42555c12c514c64d5f5143bfdaadd0eff7ed098d7cb2473da1b8bc802f0a0a396333162586f9ce9edc7acaeb087973d92d745356d790314f86eb91de1baa0f24d611d552c9df33f9247fc45f697a486b5a1d55e01cd8e1737d8688b65f213d196c40c33b4aa9d04388bf9603392b26236beb1233a78c7fea89a1715ca9225617a07732594bdc53e7e698f3a8d9b8023f8af0241ef378119982128ebd600f78d1c4a6a733b897fcd9aad7969a441942e3edfff1a898c0de5c0fc2eaa4dccc3546458cce673654618c4e1d4efbbf686ce8efc6cf428d83b0ee29a97cffe5529e4fbda9bd4193a2e1451eaf84ea524b03bebf873b8c7a57a26d3ac73898ab21c5a39aa64b890ee5477613a4eb462e06bbd33fcaf13a5ff211fd81c90cca4019517e5a87fdffb1274b97f1f05b5c3930790721aedd3f801fd3b426a6077ff5295aa1d9dba52c66f3ba6247361ad2e2adfeafa18508018d81414074aba7ffe4138ae8c5a38521d91c6c79bd4ab7d23d743d7c3ba672d84cc91059e61bf43f7edf74c0f4b2db242d1143ecb2fcc713eb1cfd5d75d210dbd82a2908661a9b6b8ea3f4e5b9052dafdc47fd9d601a53e6a3f68ced42cd392fb0afabb838e29e17328a5b7dc8971af1dbc48d2078cfbf3d8d9a06df313dead2b74cf28c6296b11529b92b6db26aa827d0b672bd814e632f7e962e7a42bd685f76d8cecaa4e274d1a057f0f0658fdc6b92c8116da4fa72d6c505a410f845bd56127230c4c651a02c598350ae377e88802baebf5ac16a7b4b59803679698d8d40f77af16ba8163a9b6fb17e72d7e57cf856b4444d35df0051c6438dc600e3b2528c630c429e99cf360f222dc7d968550273560505a3f471e5ebcef07d586e43fb504b995426a3c936222e3dba8128f04c9e26d1b17f20acf629316857f0e5aeb78acc97e04633d218d362fe8d66c8bcac84d096757f702a177278c6ab0bba709baab2bfc8b17818e39824cc452699df94b3423364c97c4282670c98816552fe2b6d8fd99cb1f8b049d35d484b35c9e3d61f37f980aade3fe3d62295b4fd3b0080a34b0ce53b8ca15a6a253ea25c760761beb91e9c865d0c81be4595b22ff03810f72ee107a604a87ed4569fad664ace180017f556e2ad7ea8d66de0bebc2e3728cb19b2c52be1556b902ebb106b06ee06437ab5479995265c805356eda6e20286c1d25c6d8ccdd1185fe46a7e0a53974e8c2ea876fa991725e5ddcf7960d23e08d3bd5ccb4f4d06dc0a49cd073122a99eed64c030f3ff4ae02968383b658e745eebe64f535583f6fa73a586ca0f26fd659436bd4597a285b3d149ff4c39779e4e15143a89bf75a6c0b707258158b3a44dc3a713642b14c68a7a86c8d50174a7e55fb2bfc83ab0a4fb2e5b6297b9c114b8f33de7ff5355740b28ddbab21fbae5cab62bf16f7086aed3ec2900ebf41d9b081a8c860f7669bff147e60046f7fc193c0a254a6aa97cd820475df63e0dae5c46ab4bf4d152b6b9c35914ee7d7a10ae9f1abed8a2980d5842712ec406bb6870c8b28aa3429b420b731accd2b7c5de35c24cc75309884f9522d47843c94794be11a2dd6639aa6c66d4018e81715bff82324b48f0a1205c4ecd19d37fc24de03ff9dff599dc04684225f0dcce7586baca62b443024cffcb08e893e74c9daddd22fb417ca565892d7e02c1bde16adb71e1741969a6c940df3e398a6f3a06f09bfdec6d0b0c206e806d611c723dcfc9203894b6377d99819affd8a62b0e9dadc32d401594394d1f3d63cb323ba4a1d83f6c74882e132e23ee99df7e8f0b2d4370500c8c9096286740d881aa8d1f951fe8a6612633c65832c30c69d1b547ceafc428f2d20644e6fafdb2db10b7c87e37a035a31c6d3928053d2653ce9511a6e791ee74c05f380f0ef91e579ce894690deb84214e9b46b87f0936f7d7fa7cdc9fbff405bceb9f84d685345a8b37d87164360e8b8d06503a82570dc3f3696432128424363a8728106abde014dcfb0d3df951e347ad589439614f0953d5e44aa17726beb6969c3dcf207e85e124461419806f37f6f50608a0169d08ee546c96cbeca5d848519c7b9c432b934aaccb7e80eccd25b8233ff9b163b4bde4ab7df445463efa4b7967537bfa076cae518828f8d7f28a3211740dc71aa0f60a21c1bcb4c9c663e5ec9402d064c3aa8bc7e4020e28b9a1349603788814972b03f7ba18688dc51b8552f39f69c06a05245dcb0a28b6f360e29c154692f0306500194b78e02cbb777eab8f0a149cc63b2d126e9ff92c00a2dab7c9377cfcb70fac0f6fccabe02e03f6da767d2f9aed068a5dfab032034037f8ed14469945266f8063237011af2502dcdabf690e05ac9e8d6442ccce1a0cea84122db841323d8e28d6229a092812f5f6160d0f3fb6219e8110badecbeb7d0238d4d9264aa26c7a839c4bd53e104d76f6ec0d32c854ee6dea9efcd97cb309f01303d47b63b28d557036d51e92e7bf857f4234923632a5f8015300bc3fc8625bee441411285e72fe50ef381c4fe637d464fc19a86f03eff5bda9902d0964c48da9de59e9eea28201297fb999927f3361bd6e45e5cba593af52f8f29499b65978e7c16c5d2b4298b1a5412c25069a002c371fb9df399b79f1ac93f3f93bdabcb89df3104cc1ae9485877d20852c636b764128e186168785189d1121862c8cdd7bbf1c8d88f0eb07e915c082e2ac430ba805302ca53722fb356ed147b855e54719e72fcdb472ae7b9f3c3aa39c93b17ca464cbf17c62ed7e5966794db595bd8b679195d4b81809c1dcd6109d44cff3fac70dd5b504d144107702b5f2d93e6388ebebbe7dd90b9da1ec0463a5d72dcdc4c4c297023e303ee1b0c8fbd370dc2444b66b89d75b076bf793d8461ff40d252f6f4237975fa25c4c9c8eb2a7199390490e7d429877c854375d745ad5095ad986a8b8d2dbc6cac455a389069d3107b609abef4f3f2a0fa574b47779abc934ffcb4983c96cd910e1e8b676bacac11597d17d80d2e7fcb093ca8a70c2d77ce776c7be6b5e253bf6649132f323e73e308efbdda2efd4436c8550dbc8eb16b3c11fcacbc2e1b9fa657c5b1accf49ffd389578070a4c3166adf38a8bdc261a2eaa661e428a90e021f8d267f1ce97842c9b88a252654b2c06af099113afe0ed3e1472a13e11d04540ed5f8678bf31a0b14e860e58cb80a556e9288b468d02ce4c24cf2d6d3f8ac726558a26e4f4b845005694e8c23fd35c322931357740d1e604c3e7a43ab45615b73acda8ff6d9e5d5cc1e49ae58e48f8b84b2f653e39a02d2d321774c9c749b4efe9fd8cd73db0416e3213e0c8566cca49dc6913bf345b06877819d984cfb7e91235a7d91324cf59663025c705f2b0faff5d957ec3e46f41f380bfe8fe6ed4e79031396560c6f500ec81d4f9e0068e3634416458d77f99b4d6a5e45d0a0dd19ea89134d117fcf9a04cc4674f04465da5d754d195f0e3bd3ecc7fa4c04673f9511307eed6f243bba3dce4371bbde5d12d70c8b265a5a7f032c33ecaa309d7a5a4eda8ef808f62a2b0dd795a7c6ba9cf17ba838797906cab25f080d84b2acf2ef0fed2e0ee28c3a7d1ac0f06a43edd389f2949045fd75326b016a0cfa8227fa23f8aad496958c44b95794be67eda0d4273c5492f279eb4353a405fed4b510901bc7e2ba83b422457d0507a83d9fa3edb345ad4d6b57e96b27fde8f0006bce0eba87244b08591ef290578f0cf594c9b55541192d8856787002fed8544beb149df6ca48a234faa1fc50a6ce4dadda6c684d9a57f49b1cd5ef3a41a6f7a7521c91d85168c1fa91c6eacadf6d410d365c2035ae6edd3e40ec1631401e2dce55b8e9121e7bfab76bf0d5c7c9b11173a153d72e702dc3555d6287580dab9d83e8d6132cd032b2b991c223954519711f002a5fefa2cad8b32e0204764e2cf0bc8546ccdaedb25476424439e9310f98da8ecb2e6bf564ab2f01328c9eb58c405a70482202d9d7ac9758c37e21a2991a36ec04cd79e14d18d5ed295dda1d2bd161a73ced88f7c478c4827c6a34df314e278da4e4cbee9d2d78858bb9587501ab2a5eda78228978d634901f587f899d64bd6154111423841d6a5a5d61c3e9541ad822b6ee96054fdd5739ac510ff13cf84ab14fe0f9842eecbd909b17007673f0752e5ff67f96371193b220f020c90f835a48a16f9526190a42e72eb1daeb7e9602c99f721cfb59c000409e4b09cca109668b681010c982d588941d50e1f031c883d558780780f2c54b7275861e8a3c47417908574e7426d923a0054ba444843c8b0d4d67e81bde5c713b1313ee9deafd6ca4b4838898c0378ae2dab872a95ef3d8cf1766bfe5266f76a0451be5bb8fb39d072138fd83b5f0f1b00a2b91f947f7fe807a49ab82a0d3e64a783894c71f33c57164632e06bc249989799707b75cb40b06dd16967b5ce55385d68761f002df8806995449322b949e969ffd426eabf17aef7a431ffca2827dfadc279b3f2481dc20900205831ab3533c76bc1dbe8c32f2d32179d0b705d72d04eda89fe2cc86badf38f609bf9ec487d1c619a5f8b4c21597c4c90e91c1055ced75b82ceb7fe4543b685ffdbeeb92b92efc994d5e015c5e377f6bf9061ac6f9f166a49236b5a382b3da1842ea1719d10e92f34cb817949c5d0aea5ca4bcb9d70974459291932251fe7ac62f2d1badee5e06ac1742b16a37a99ce6d04b474aab0988869fa3b8753ea9db9dac7d745f36648c518bacd72fe118e82cc975e01beff679b3ce408f629a57f4391ec447dc09e3ff7431c43cad9137b922225d0b2149d218682d3ae1b732eb09cf0befc890bf30961b542c4d4fdc1e48b5bd9617621ebc9c9be986ddd8914dbe7e70aff6317c001e786d9c764ec11cfaf5be0e6cc95a0886bd590f83a3f87b1aea5e16168362cfa89e7982fc7e9b9f2234a70d21c06c89bca7b15c6b9f8ebe57c1788507e8daf6e1623538a86efb9e22d02d882d02d28648009b98544f72e3b8f32785b1b6c0fd4e8fc8087154595be3dd310d7817281ce8131040b55620e3dc35ffa53a556d3dded99b56880a506d1ebc4628944ae5d92a7548bc5d58240bf3a828434f640efd9e7b57b2ac006c74887e953dd3a7b7ede25dbc98b2b1caa5b5c11dfb942bc2bfa6bdec997a08196b01694c441994b13595cae08535fe575d0bdac8ba53b4a39df186691195eb5aed8340502cd570c62fa4319b193898d4043d20282c490f5dbe4eba183d8143697d385e597df65f1aaaa34c3010a8254887b55bcbc76f17eb6af86061985cd0bea682471e4ba56e818905294668abe14cfaecc2bd892a25b29f1010ae2da092f78593225e0b3a4be264b3cf9d5a823c246b32bc5f06ec59a62dfac704cce4a1fd4dda9b55fcf128421f11df75850a4e0e49de39c42bdb4c0895666f45da6324321399c3bb089d2054ce3269b74caae56a0230fa7ba3bc0a3c20ad5fe46bcdb0d585e7dccf0237c76aac1640456d0e546f6c883e761c78659bb716f95f71cf77731136d51fd9730d4a046a4fd506ac6ef8a9168c8377717900f39ca532f8af0dcc00ae02e05cb5b1b6ff02e599e4920ab796b3e4b171a4059aaddeff031da9b5e20b2e534da3e1759e0285772ba64da127ef5f5228e5062a1edbd536b64268e468c4d25854707ba72751e8e9a54ba1b9a1cda9142a8f388a44591e9e4212aef0e8ea5fe517f9ee260dded92d8607dde5e786317ed473a0f666191702e638f28e7b6a7eef2cdc5ba232cc3d963ee153152deffaf251a93e0b94369fa5f6e54d9136c56b9a2f596738ca13df9689333379b27daee84135e9b2b359b1cd987c26d7a8a7361ee366441a81db4d2696eade22728e514beb6e8ccdffd91328824c52fea41e55294767a1fee2d4e56af2603b945130cb03efbac41ff58a7d1cd1f64f72d4c1a9cfee34dc3a5973660d84e7d93505b21d559c58a88c256b7ac1bd0d6de6cef633f7e46f03ab882d8d2bcc8800002cd3227851223294d996520779cfb4e6c3b8874d59a7b6ae07b9eb473b75469a8131aec33a477281cde0f1e3e286d51ba05210093e1ef33d2c518689f5a1fa24a4725368fdfde24147bdc1c8e1c00a6a327f0882d310737fc5484605d8b1ec28ab6c81624a5ebd078636faae5b80fe98f94895990b1a855787fe070b33152186a0a55c9191c2537eff0cf3226cd666a1407657074548f1fccc0b723f720380ac33d718ead7b6cfc99644b4ea1ab61b2bec03e726ee8f0bc2b06a52816282d7c95ef7e0c687c48634e51a36c1d4d8d561ba3c8b9bee631f3680c80ec5704a86d01c421333e8b71e483f5d0080c5d8101437507114c641627b049560e6830b04a5cc3af8cf5bf2fe664225b7220e8b42e18b6ffd6276450ac5f0cf5bd5d797d23eb60c2f85caef25f4da84988d21f681ce50a1f846749d61a08241a23ec13dd82a56637eafe97a0d999831a8239f779c850467012b7a756f18e9cde42cc111f6d6ae824c669837f50e02b947e494c0648d4edfb3bc3728e128450b235f6d13a0199d35a6454ed9d2e2fb74497aa1c8ecc3c3cf90137e44b4048c3586bd0e560acad5e04ce257cf59c1c9f25a447b2b89b8887ee909eed54d6a092fd6f2a7ee42076bcb9ca53f33cf9e1c0812670387a9b62b88211dcf32876ef9b716de19c8ab1455b7712f58ab69f6f1d52c143f462dfb87f9962c929ebcd9d619ce70391572e3f3c44b7c0733612291ee4fa1f72dc9f1ed351d2b24b0a95949849f4d54a64616225d6734a232bdef63ec17edda81f9f7cd7ca06d9cdc79977aba4310c7dfcf2bb0fdf8f06d5eb3db3a84f9814abcee6cb1dbb5a397011ea412e1a6a5cba4538f3f8ad057453c865a84db35261e9bd497418c94d51dbf47be51292ccdff52e1546cf3f92f2c66598d5c0d27d66b43a02aeec0ef0616d43e80dc32cdaa97e2fe578a75ac6914d8bc73bf58a9be9f2ca59df45c00fb59cd9bd7483732ef526ffb6b74e27d8239f8b7067b704240b502711d177ae232c0e66b12c31ea24311ce79f01780c6aa9b76a67689ff8ef12fb0d70c06ed0d067c6dc7a616b32941c008186aeb7f0b2a7d3253361be97502dd0c9ec35bd9410fd68840a318eb8de3e52ae453cde32df6cf79f188977f2f319b021f78fdf7043d1619265da8fc32b99cc8c45adaf5a6457e97c787ad89367e8517aec52746fe7e1db0010a3f36d09aaab64d091f8fe103cf306d8544adc307d642c12a370fa70d8274e565ff91a6dcef57c4f362dc39cabfe3f3ad91bc2d05ae99e70a7b34d016d39b7cc167b9fd5761b409067b40487857149e1da4d3f555931c1c13b4a5774c07a17e319009f26f65290125a39966c3e587a5fcd685070bdb5e1b52308b6ce27cb8e1da78d5f871094c087848c0bce2c5704407a4366e37624ccc11f73c10d11cf3fd66a8c62f8823b3800420385ed852d2db6f009d7ddb03104c0371b474682310f3f5d152dc6ed5a162cc50042e46c4507e7f088a40148833bfdcaecc3a8691d909e48c9969a4b10079c3cb872cb0020196cc11f14718fba39403508140f5ba47b7565c4f5c179502c93599a010ccac9a7e94afa4019b4d6d6d836add6b5436d74772cebd9b51d3c0a927fc443d4b6cb66a9af59716bd7cd0706da365a81c0699ee69db18593fe75bc70b933072d39756adbdfdb38a03cb63fd23dbadd2fbfbcda35cd3141d2d451021f09df805cc94e3268787affb9aaec0cff900686bec0b49f8ce0235eadca7b55a6937d2f2d21503385e3d18e0da506ee3a66d64a5b2aa5e902b83996aa4545bad50dfc154931339ba6d22036ad50dfa102d13aed23c5f14ce44c46614081aa6b916fc68a1b17df5128f951edea1195e4ad1c9b6762bff82d091795b127ce7d53d3e4f481b012730a5ee609319d564627a5fa2d38df243f5b238f2c3b8cf69c4cbd6b5ffdeddd9aa6e832caa5fc1c6278d015fb5c14e3896a40d61e71d53eb59c6bb38dc6e89b1452f98f9b852c22f28350fee75a960352a0c3befcafcc1d3d2e0ebb9db9186080da95a0598cc4b3342b85c0148e90c94fdad90ce9e84e63066a4c4be7b2fbe153be64272f420108834bbe24a862ceb3d222f87b487384f2ffb3dbcb6e74dadd708a251cc719e2922a913d8c23ac01543b247ff1a797d7e84c08f29c8c46486e30078e4c5f41c410d32151ddcb9580187386f817cd0aaaaa1395636959b917f4efe5ecbd83804329bf08279f717d53d71d003e40d82a80763549e21eed6f6bc18ce24aea4e18133c370f1d9bb92ea06d65e4512cf2e3dadc6ca4dfdcc53723a81625ea30da1bc61bb22aee593d06f606c6e46d5c958f886e9088022602390e9cec4544ec8bb59ea6da0dd2e3db5feda190e82997cefce5a4eefdabb38c58e35e63726924ab5a26b04114d548494907186517748b497e6e735f7426cf6c9902e2ed74046227f839644fd2ec699a1066d94bbd8863dfd37dd9bcea67112c0be9d60a26bf426497660e73ad2105294ed4a8b7f733db55a73fce4591a2509a30040212181b0c4e7d8acb7c532387f3c5a37ebd681dd7fb96ea3f95e9203c8b3ea7ab83a363d39f72856a88ba24ab084d03385da638dd4875b2152666a0a5f9f1eb9acd2e79842779be51a3e26a3f591943f6b28e8bc1c82765075aa143df966d282a1d974e96bb42c3f9b130a6db361d50e285e2a3c49b0481e8505539403d7fce66b44bbe9d99aa9aabf10cb4e0ca47a40b234a39dfc59dc5c0a31469b5ada4bd71a859e778aa1c008e6b70378ab2fbec91fdedd477fef5782a33e0c92d3e25fe7e490a48e03b4e8a36975e3618d582973ec030363bbd9d44fd8831b047c8d5a9ea1fb68f44b490e3a78e72fd6d6e986ea87e2e778ee132f6f4b79bc4983a4091da03fc37e9b653c0f5f0918a4562b15f0dbd0c62b1f92ec174cdd12cfba06e7a479d6c628f4356a3d14df234dfe162dc0ec51a5c5a6b20725ebf40b026a8fc0865fc8d9b5709b8c0ca494642316b38f7440734e785bdcd36c7523dee751bcd5d32b9c42cc355d3ee7a8537da5b0b3f238f25d6f6045cfb073156a99e29b67b57d6f7b26504da46d9db3822a86583aa413382f0cbeb2cb0a1803051632d5b7e065777072d2bc8b441b37f2b296b4a59fa250d27731966bb49f02f01ab43652f3a1676d305b47aa94c5b3d42fef3261e8c4d32671d21d273885f0289ab715eaac61bd2ecf0c77eb4ab92efb3575d3ef740a59882facdb4ad34b515a1fceb99daec78ee7eeff57f4f83ee6d597e6b86522e2d71c38f99db18feb9ac2a5a9d8a1cef5a909ce496974b8420dcf43f17b07d96b486eab66cd6baac11d1252388755eecbaf6050b8539eb997c43644301e2e4262f7df887a2ce57ee8eae5e5063b107855165eab8fc370aa4e361e672d2b4e1bdfddb4ac655785d3f32b3a2eb8c6876dce805e47b8fbb459f7f8e8577c777a6df191f70bce7f29ae1d36a9a8b9ec5135c590cd4eefbcf42f812aef54e70aa1ec26c5f2e389502525818cb476d60486d167f482e01b360bad958be0bb379510f424ca6da62528c9ddb317294fa8f6c551908613d0d7230fa24ec6fce7716e47a5641b7b70bd11162635a6db97020c5e8575f32eb5a357bedd5e67f6c763d53b462fb9466b5c7bc33794081e6372f468c4600e7d7670eaa7e236afe3a37d82a23cf980015db7994becac630e6479234f216ef5ccaa52d0d7adfb9f6a6496c1a996370f21ed512ee84331b84972ea61923d4274c91e49a12ec0600b16856a80df400aa0ede601b1e8fc6fd65e5042209b0c469260da894e3e7db8e043977803191fec2c9ed684b8293dd99f2994178317f953463c88d62b41237c15a9891d5fcbf28b5ddc1bba0e6ecf6b7657f609f3f5a2ddcb3393d41780f3277fd9480c42afb65d118e787419cc04cae7cd2c5c0fe7eb02c882deb2397c17025ed93a996dede9237a63bfa7d75b78c305ae27203c76057a1f11838a3701f73fae833906795348a2942b923ce868cc138b7b6ddb7ec598a681aeae4a3b7978cfec5919134ca391181e3b83643a3a9302b3623e352c2157c4dfbc9636203ebf079994040d2adc3c0f14d05fe7b789115e011f8c733aeea4ffbd992079a99b9df9f10ff70e1a4eb730441c7d00315c061644481b38e0023e3110f8b0eb51828de204bd61cbc40555b195ba131501fff279ff195c50e6f032aefe77d34dafef3ac67ff9525e4162670f49a84d3768d748bfaadd7c0b06fd17d92b5b574f26f1c2b2c30914c6b725b9b5ebb2733f23cd3c725612d9d7ea3ee10959d67983384bcfdd0313363f885e9b3f104b8cd1408ab16869eede479f6215e08e117128e46af9f0dd56bbdc0164c413f741ec919d61340c30e02a8915aabbb30cfbb03f104fc6a5796716377fbaffcfbfc2120cfded5fb7ed15a588d83fa6f95b4a1167e69ffb6726fb30adb7dda1e2f744e94ae4dc26f225602d8b88ec4b81fc8394c5e1cd341670592c3f54873503134ddd1ae12d62342817d4c3f07d4c3d8e37406a214df0ba2abcf9d637505b0fce72c2d8684c38c98166f4808895bf603fd29a097203ed5e4e6484d21f950f32d135da00e81e55ff470169494b5f76053981b42f1e1222766a52520ec160d43163db7bfac3b9eb4abb5f154c098908df4dd6501052ceda5e4ea0a87eafb5b40e28299cefd32b8b4bffc224054a9f2faa60a7728ec706a3702aafc5156cc95faf3caf06a4615fbe6c5f9e8c1e4eb9ba380ea80d7f5db331dda2e63e3fd3e1302bb8057459278ddf04486ea26a6994076ac327bdae0c862bd2548bbde1ff1734d26a64d316aecb18ce5b818ebab1e9c505864b49d8c36ba018d278179d476f239b24585c5d1ed20d5dbf90453681cd475fab2baa3511b98433cc2ff14981d22d707f2a960ab948ee9468d67ec1b00e3eba972f9ccfb877466f55cf958452645ed32a7ed41243662846fab7b4d56a0b64bfd2bc1ba6e87a867c19cae5ffe9a0bb82d47896880f4c12dc043c6fe67f1b04e59daa4102b0b0f273771c118e28ed81ca0133b67f43740607c406ab76030a4cc4b897a51f6ebceb579dd33a519643c13294fd012a84175030507206577ebf99973e23251f6b293e19d9e8d3fb1d2a1a86b80f8ccf4f8a1e8a5574ee6b6d3f031d6c181cf7f930e4906e51e3fc37adc8244d2206e3b105ea31d83d6595649cf5dd63582c9b9a24bab54a7f691b028a9462546fd0587f9b844d2912533a9abebf2abd915fb5d9c07f4fe3373ee11c6f7513f84c2f2856bd4ec71a77a26890be6fdd66846d538f5ea959cb737ef17f92cdb4938454288703857b1b42ca2f24154e66710bbb7a0525e881b0b877d5df1397a892a0fc1b5a885be2708fef58d8fe6d0e2e22b29bf7b082d70d02bfdc31978296685a888d426c247a086a50443b58c671dae2f3702d97e98de761aff55cdee8fb4ea4e308b73e8b341e0a2b9181541fc7d9c35f08614137b826b54949b5e1f5e9f719f3c54d4368ff5d6d891a4ed55c8710e4e7c0d862a01cae164dece70dbcb1dc25ca84df0dc9c1e9d7257ab1166dbe9af5db279c6e99f138d95b33596fea286aad7e490047e376e2767f3d2428f83dc43360d9f3eee8e7e6a2412e4f624811386a369af1502ad17afaf9386a3fde21fe55ab16a4302cb68a36065bdea48dbb8276eb253ce489e64ded4209e75b27f213e405bb496e063afa0459749113b7626886a17f995604a68482d2522ca101794f03a5004d541e05261abcbb42d3601a3b240320284f45689fd8264745801c4a60d6927e53ea1a511564f9197ab34d3c21be3b9317a88cc29dd74e2cb9777da7e8ecc425c8715ceb5feaa1032e5217fe3d8ed7c38e093c71684155ebbc95c66d4305f0097bd54d8de2ae04f28f900f71680654db44ac362cba5e00cd5f9fa797d1c7c52aa66c497e6db36a71aa75be0635ccc274845228cfbd8e368b07c7abac2bc5584f736476806edee3f4f3ca256cf44cc3619088c0919f5bc8c7663efab99b64cce7cfd541c2c2911e9524c3c8a398dcce6dc87edf5b3f0644e037b80394c45d9d73ace274ca5f8a9f0a6cdf1438bdbc20425120dc569ec9996da177dbaf3755816a46cb3f5168343194c7f677f71db364c5478a173a7d96f475964b3834ef6d6278b89608f640a342745d70da74df484007d1ca8435395f834448dae33d72c626d492a6dca6326a70c1fbac3a56a6b73dc756d55439f4dba9f798160983347f017c5a69a6f4c7a42a16fef17ae7f4b1fbe8fc1d63418348836ee74cd751d424d2e762a848ecd4449a7755c24b1a7a79b001ade4887273f4f80eb27a8137badbfaab0a9fe56bc8b221ad3252fc174770901867dfb8ca3c5c2ea7daeeaec571c3b16f0c8db613a9dc2d3fac720ef48d3bcd6312e003c6af1c1e4e89ddd2b4e9a2498e83c73b94083cc6b342a39c71b25b3120ed8327954c8ace893854b938a1e9f5dd6c8d266d832b195bf15038c9bdf2bc7fa2c5c200be078587bd4702c56f28120e6a8db67d0ef5e2c244181b758c47eb9cf75204c72d9a6c75a528cb290e8f34e7504c4418efe84c4158e444c9c8da75c1f269a2127d43611a9c4fd2f28c2f0a008c788d4c2af99d8996e09d10a7c9bdaf384a5265bb0e735442109b61b72d3902c658180d27bce162e7dcbca73479478b55a94ee2a6df8d04186527604214ad0631535d798fd7f80dcbc8e337bc8a92d2db34cffc21b779f5bce8dab489700db71e1c357bae2d284c44e543e87ec14058ee08eb8fd73d798875c475deacf90060919f2054f9fbe9d397a961f4392cebe3dafe7a86c6639bc093ff27014a3201d782f199378bec6b01c8b2880e9b4c4cf8ab904d08e905f5b227bd261025165aa55d66c58a125d9b6944f2aff6ee43dd0078059f8fb9f970b7a0fadd2c6869a624f005a259157d71ef95121235b969bdf6facae2bd2f93ef892c9ed52de4c859a9ce378266bc90d004753ff7b7be92d601182f4a4e23e932b27e61953736d4fa7fd5029d0a9123938e6d864fe8768c72c74c934bbca0a862baa518d2f46954af3ff4cd2a1720fcea7b4cf1afa3961f541454001585faeee8cc82749ed5af3af2125bb49fa58c40e02c14fe15f55df8c08b933470e1445b5e1e2b7521cd67c17e8d039b279a7ee5be9623c307111a43af40614369d5f9df7550f7e6918d15ecd213295b2b5db0adfc96be6d957518b9438dd2b363620d41622d576b0a46e47251f42030f7ebc7c2f9dcdc427a9ae3c55e1c20accb289fad071734764fcbdf8ec066b4a4288fccfa89c0ce666ba6ff77b074c92a704aea5de8aae60c6c71bf438b4b258f127a9db1c502990476ff36ddf94b37a1c831f0b2e863d2e38856e69b108cf79d9f37f23862db3200a6910bec60050079ae97295eb6c369ca8a6781f23e17d985745eb67596e6be7d261b36e6385e0a79a937e1353b7df0a03c7007ba1bb83397708434a4be0864948b6df58c9ebc7c92e57b4509ee62e0483205a5f27020941cd6bc7df357554f960e900cea8cffd0e43f244b3072779b44a0f35d0b384c1271e087cd72d88689723deea726313a5dd79b14d53a507608497f1df166ba3f83af3a86801cca1c2caed9dd27ada4ffbf6bb15d43be461bb70f7227ac367d0849e909d2715bb415863f0c7e2783182781b811e62c59638541a49fe830aa09e888ddb208acf73a80b555a583e97eb2953e712609397d063ecaef78c01327a3bbc83c764c8749aeb7cc3fbac34b7e89e790a5f03a7cec94cfc7c296258be7545e4976cb45ff357c196249fb252e7f4a53eaa7df4354565166637e97e5cbfd0c5ad1b56e8d1d54ff127ee74e7e492accf1146829e8bdb9a10340e2399164dda4bf59ddcfcee53e90bc031b591f47ca16cb791db2cd6bf0d3f3c23ac2bac104acce5e0261842306e66d5f6a1c2497fe549af6e7e444c8bb2b71a8598b45d328b287422d65281c61f2d8426ae3b7c69112e878142ca328c3341e494a36aff0ef72a898c3dfad75e9b83083b466332474c57ed2c8977ee9309dcf601262870fdfb5bd68ef1027f5d370ec4faaaa95af3f34e0caa328521eb1b6726cba6ddb601f92c59b54366bd316e86bcbae2816c09f7057ec308be78d421911fc3edcacb5a708e7412441dcf9198ac267e30a2c15cb4139e16593cdd6a94d1db06e6791eccbc5cda23fb3c9065cb15ac067e3912b283bf0a27317af0fa04751a993549898367bcb69789c344bde1df11d670eda4431c95f03df802465935a75fd42b23ef33a9aaf5eed91132002f97f5446e0f10681c783da13aebbd1ab2670b0dee52654a329dcaf701caff18ec339b62a6ec46d11f3bf442d97f117f18fb8f1aa682566541cdee7a3e442909744d41c319b6e371bcdc95795985db8021f58c69921e853ae5e2b3f3f60c8155d652cd10f367338ba105e6962b8fe6621c4149e93d009c47321e09181bb210c15e2990f4cb4a91fe783d9b7dc38a5b89f6535c191d121b9a6629098c81433210c4029c43dfb829b7ab689ab44bd3d1a04aa6777a6879a44a15ef32097f960be643a989309e10d5a567c8e67d88ecbea672db38aee23af748c530be6d901635e723310372131b28e9442ca890b344f0db0e713e3a0e16070d2d165ff417284fe1dcd2f985ef5d3141f1f660549f862d7caae4147bb14faee982f880a489fc5664a6f9bec5946ab43dc14322322c294dfea06c578c9637bf22c3462843135e9cc31b39b1d79621bcccd13b70e58b0d03399cb63dbc839b70e920d3449e0853bf35962ea150c044529f93fbfe43446aaab4af28e1b1a44eb08de99910efeb3d45716acc6e1052b535359114e0c79efec97449c41e87633c88fa89c13d517f0f52b0a5a87cc1f92c5272f8cbe4c06e976e1817cc12ebe52a34be919ca9eb12370e8f5989aca8b59e9966aec7c797e2e90b541310ff89ab906bd6838842cd0a5a35206c34846672a8159e76ef821dd3ada76dec67e147966ad8f57ed30470c6c245f99f7ad3596f46138ae518f4e98094182f81eab8994e7dbc1435ff60f02c299d5e08a02b68addce05f0f5c3338fce68973abc0e18125fb44a89c61f3df89b1469b2d7658f91a94f380ea293bfb744ec17bd9dad1f63e3ed1260c2d13bda40c6a3113268742089cf05041a2ef29c85a0b3af7e005f115572ade0239076d93d45e8beae01602b4598f73d079d704737af73b40961843a2a77bf8ad2546c55cf87fbf17d84efe200aa3adce3eaf5055d1ab1e56cc0c26eecc607225192c22e83d8c4d64aa69ee2088509506c35495b41925da5cf04b8f6df1412cbd47cabdc18e81a1849fcfc9560d5454294f044267a7d027109fbc6358e254a355bef1bf17dc6f565a58d9a92d8bc6627cd8b22ff63520a5c4287b77b3a5ddc672a687426553dec90960ac896d65270f12d866279f6534045b98d9092c225e1376109128aa42a584bb6043c16f8b7c9991299e8addc468b3deabf29ff7884fad6a2ad2fc6c65578002686836d035832624f0f1bf4cf5b2cc87d5f70c9dd1971a9f9978610f98efd72f35d55ae8d961b14e2f60cc41c5c1703671b1d28387f13f548b53f65c3a81c115905c9b5b43862ce2e3b99bc03a19a233016bc3d1cc1df2ba9182452de7c1d6cc994d9ee7bf6a78eb1c3e447356e235cc344211273f55c6899224673452790a47ec52fb1e1bb0ac7401f2358eb0890354369ba9b95c4cd71497d3d71145026740f4049d5d3390c8e991f623a6f937eecbc2314b60a1f7655f2eaa21a4f37fcf76e90297316c0ecf8bbd21d0c5747d96b40555d021678647d2bb15ea229fc50f972d1187f8ed17274a2c423a79ffe39ffa43b24fc77bfa07218d5b6e3d1a36a325cdc300344e7386d8667b013552040b006ad00cb5597d6c08b4ae938a967449800660eb0852ee3760f8d0cf4396f65894419a1b2a9f7ced509ca2c9d29ac30f14c876520bea4d800768f20a8e0d03adee388aa1fffe4ceea8b34e684236858e5c4409944c8e43a0d0b46884f84076ccddfb4e42a99f37bfe21aebe01e33294c9e18e8f202e828beeb8251cbe409dc5432e26c59acd992035a79675c2fe38e511bf19aaa39ef2f6bd44ccb9dcc727256cebe5c24777c2b161c5f8fb0996103fec3893d4ebf17ade96048faa513b87337ddcdb7dcd5b9aadb966e3fdfe58d589d33251612497e9911eafc81fc6c1d45d3f0658ba93d87c92c9342bf1a660693f6538ecb8c210c431c0fb0b462f5029965590850a4551e654f739eb6754310a1598d6e18762021436511f9993d68054a8bed9f7c248b7ea4f36d6ab7682fd23c6a11a6a689de4ceeaf389ac3cb6768404c6154ddfe553c63e668651e84c985aa9b870a9a991f934d8933b7f62142244a1ceda2160267a0dcd16fbab476536b89ac8ff5ad21f9088ae432590fde072ca30e6eae7ce23b8448a442de056dd4ff93f89b84ffdcdb33cd149a11bac1987e056a94cdcfde0439bfb1d10fa557feb9cbd1cd9d3523060587e5128abe6ef6c6169a3464bb828cda7f9ac27a5638d0f997f9da93849cc56f78f285832559aa2d7c96b55caaa755bc3cd84d564db08d2999330bd799d5f4e5bd7068384a6a8da684074aafaa98432a49cd4454fd595ede50832fc7bb8c2fe1a43f65c66376344e2184ed0326e272afce067bb5fd5b2b237a9432645cc6406173c8abf7ba8bff8301a3da229e3cda73de61c350066b794aa1af885f5ba96521706cf1d37f2513366d57b5c31204c0791f7fae7668c1a5d048634ded6a13fae6fb9a374fafd3b98cbe7da3ddc650a74b891a3e08c15e7e4210fb873cdaf99269d1f26ef1e3fcbde3a43d4327df9e83d95b15890b86e538a242224f9a9c21312bd9b565f0b9ad390c0a2874ce94147d52746c9549afa4aa102ee94cd067e201d955778ae165bc6a409728881cb007f2c5b91d65e60023a85c7f4e94193e1614a33a3ebeb29c4f38ee06d64be7f5f4759691e30476ca6eec7d9a5bed2dcfc493c0d4702cf33b0854389e6bfd8d45147d1daa481103dce848dc83d5633d3d18f4b96467495914a286586510b0d310fed30677db1434d08a36d3dbf26d4c6eaa5ffee85c35f862109bf7d9b6ba0d450834027dce5de444bc9737ef5fd9f2f1050cb6e9dc69ffdc8f6b2bb91884bc651f36dbd473919dbaca4dd93dbbe9764ce147fa184d1572ce59c562b336b7104ad4f482e1cc5ff50bdaf22a6e02c0cde48f84572499cf9f13a7d0538d9985e2f1dc962fa7a9a2cb72949b8c991e1f7ecbb3604d5e5a39e44093871a1ed189f094edc249940e2acb35ea4a8e3f0d9479a8b3a0298cb43012ed3ccc3f53db60bab43638445ffa72eaed00295f9411ee0c42ad51c8351b444ca5194300c64138c3786b86bf9f9e902b08b31929cd748518fdcfb05b960654749c6200966a2d4539a3692f111ebe0687fdcc8206e3747d7b078526e85b14c17953ac59a31c80e8a185018d495903f9b7ac097bac9bdcd7fb5fdbfb329bc6f1d555d16fe3f9554b530854629e50739123a5430add8faee47312faf805fbba5e49bde08b89cf16376a07bc101ca18a7bfa7aa5700463148ace997dee6ae7dcbb779771166ebe4d326e0ecc9eedd5ec94ac6b80b8118175e02117879673571194b4fa7ccda3092a3adccb7c273f66ac140160744e1156a70866ed21036034cbf09a7a71456f3140d3e6dd53b6d4ea872b45c75e4ffce96392a4adae2104611a1d765cf3ec6e56c6322a545ef35fbf634a2b6a980e234bf3707e0eb94f2c8ebffd1344d1dc8d76763940110b1fab8b010c5293ab3fc16d5cd603f1746f64b599f6606e856439618c3be82daf2af5fce4640a99e124cec7a84c981e282d389ee64398b6d70f7275643931bcdc81120d3a50ace6b42aad5df73868c1ca18a229a4f920a1b8f4003a033dfec4a6f1301caa0444d6440dde705b3d7efef14e4143d248d4aa303454daca17247543675d938d37730c1a3890d714c31660a2259890d5d579be4c5e64a69609fc93095398fc4cf6b5608cb1b257f72b7e7338747fa990043bd31e2cc747c2c65d54efb9738b44c5fa7e56b9c70b886032ea5eb1502492df2b627a30607e46e24fbbe05875adee1872cc3f26a54ac619c75a22fa9db2c70a32456a32b8273b974cd6fd0b81f0f60a55d7fcf3966e869debe620f8b244f9529458da13679abd7b6cf4e48942948023127e0f9d824246d06a1d3abfab759c2456442404216bf28da9fded3c347e072784ee5529cb60d191e522e0aad80adf96655ce20a9397d384b1dc8932b076eb52dabcbc8e2cb4114301b5cc462377df2b92cc7b0b483ea7a789911c1b67676b3c5b59ee919920e2f8ea0cda260ebcbf0b675afd5be61a3439afc45deb7f7951afe65c6c1562a7b96558505a3afc2c648d47f631a99a40cafec9325facaec4f10bda8405e3bfcde58d153884fda5cb02346b98029287522195b384790af0ee35508b9ad2568dec90f5f4b6cd9fe20095f59a3334f003ea38fe73539720451dd51bf35ee9685205a0df712e6be98ceaa58263c974b787a2db81607d548c8ccbfd5b0f5139c5ed0797fe43df79c31fcad98881acf1d8dfcb16ffcb0dcded1f6d01df4611458d45a498619c1187c777e7b99870ddb414fa164830f1afe53c634e5e065fd4f0e2a8576b11e297fc2e5b45ed9fb03e9a5e6bd2291408361105029d4a15f3fa9356f6953271de643ce8bcbfd976869cd709d5b1fcc14f2253e570e3cae637b0e2112b3228d6db82064a72d6066c565fe3f8cc462f8bdd5173c1576f0ae73e80ac2082b143987033cb03fb6a74e3e667184bfd85284db2533a873e679ff8c8b60947e1b55ae1500ca96573482563e7db5803260585011e51c483a2129d3594a22c38b86a23325cf3896a1bffcec74097b5d9aaea57ea0d55561f999a1102449f5b9d698866d59fae100dd87085c7caab6b0447be5c866890a4b85961024903a42a10c7b772179db74ce0524c48b248d45bb1b50de8be3e3cedcfb292d95f4f5d2476ca0fafff0b43e4dde7bea9ab40e81e2b06e64a3118ad91073f0f5963f548b7517cb643b30b419a37356363050fd5fdf119c8d6d0390be9ac275eb23e91d7bdd0b54abb4b322808f381f8c95b97c4953b598266ebbd7f88a7c045cee0eb76114a829e0f8240557e2b9d25b65b3661ca862dbfe9f50fb657133409f4993bdf01205ab1d9ee7f82c885562b50b54dc5507b9ad9386b23b2fd72165c3dce173d3344cfc7d9a7f7e7479c121f62e47cff606c1d52b6a8dbd80015600f4a3d056d9b5d28180eb09797e9b68ffcc4297e314d83d674f8d15d43f337d049d6bf7c22d50533705c5cc966daafbf2a523ed7786fdf6d1d408e140eb502507dbbf05105766859c53fefe41beec0510c60170e34a583d525ac1f96b7c832d7ac7539142bbc618cdadce9219b853e1dd447bf929047ead977adad95379cfb5c5ad7f0cfed9e98c068b2084cf4baf190af5cb771dcdc0512f7a5f88c7b07778ce272543630c113f41a1f497d39e905d54b3528896508b46bbd519de4a447976967dfe753d4409890727f4e861f4e09e2a26d07c343a1b1c69dc931ea58c657afffffa392bb81296c3282e29dc31fb74f84f842c3867a5f9f03c93377c99a63ec1c1aff171b1e8921bfe7f820df561e4d355aa178d5f8f62289b59221549641c1e087cbbf3e60bae4d68fdddfbddb33b707e654f13a995ca22618909188a6b7588367ab8ecded005d1c44948ebd36e2c15ea72e80d33dbf311162aa4566b565615a7774bba9738b8b29bb4a5a16a2653aafeeaca5fb5b9e4407349bb860f48fa588b5d8b51df87f5d03672f388e27e2d712adea46c3fb5f17feefe616ea92f822c5702c709ec9d01a4629cac6c2e26db3ddf0faab9425cf22c2e79cae1389b7d1dcb91020327bd0de5a3984fe3a029e1e8bda98682f2fe7ec8e583755739baf05cb2546a56b182a228f87ab9c7e070cff754f5bd37f2678726143ff8896ee9df4f6a4da92ffe1aa3236959467f763a07094b8bec9142ee2b0d9fd04c2504c5cfff450b0e37d54da6d7e521ebe9a3d16da0e889644abca14314c2dc1c4e6217a4993bb6eb7579212b3cc4d174eca4b4382a74583ba55ad6094e05ce88c8e49646518ce125408df34cd513de22b0dd27d57ebbbe9c153adbeb175a06ac91b37c8a945ed8efc03471d7efbe41744c85d76b4cf224eb5bc30e3e9cd264b10b0a5b941f745abe8e752795c113026696cfe0f5adc514c893b1953432f7847a0e25100c38c73c50687d01074860606a86f02b8677e2740206d17af52010538a249b659887286dbe233f35d2913c0e62fae9b21c589c77329c3aef655d020a75a5dea3b14843d88686d76994b76b8a19c34580886ac4df9cd0969f0c272f78ecb1e3651b4e27a612dc4fa1a62bb71acfd496d88db2f5b513ff54025d75d0b5b4c8bf16f19457439634b1bd27cd3b9857c63675f2adf2f00c0dd6c0061f0e952e9183a0445cd44e96d5ebbec4be8fdf4b4102eeebd01ba5b05036fc76577f4397fb802afa8ccfde9af758b5afc387b923c409a87e685234c180cd2a04eb10b4c528da9a5b943b4f7e49c19230019e2d0f65c7975ce9a3276b0a25863951e718f6e28863214214fc8910d5720b17c5c1d85a6e9ea07eaf7f93a2c4800cd376ab35e0ab437691fe23757199c52451aa0238a354ceb23847da120a9c581946a33f10b78b92bdce15df6f55c651eb8311044abc2d2dd8cecb5d69646eae11b232ef8706ca280429f40d0bb83799b7db7f9459dbc4425907062bfa6fcf63e527e949ea6ecbaeb93192279a824c6dbd868a78bed04cf79d71c2ea81a7eba4ca93720c5ba684b9d43dc5ed9e5cfbdbea43e7bb2f8f851d6fc799bce73f2af5ae7bffdfc9538f751cad332768123253281cb6a17d67b66e6049fec80c7c7575b84b355a7df891a7b21ccc9893a7d3e12b468efd09783247d4495aa32163840d322a0023c34feda935faeb2f38cbd2651608ec1a75bdff397f7c0730546aafa3a4f4a8221b03d3543e2522ecc82573882b81553fc943199a3118d019db05563f739a8e1eb3f9f166e79200d4dc9af1d6e6b08d6558368e19c72835b01264a3f9fbbac4cc5bf90fc8ab9ccb38df3c1156e6125064f7fa8e4256b9dc9401e4dc17cafdb2e19cee8a0c21f952eb7e3e904e0e51faf600e6e40b3ff69b4ba15f9290ca33152d65e3f0611aa73aaebd7b0edc118b45fbe25fa65071bf86b212f98c916823eba397e0083e51af7df4fd32098a415d513b44ea5fe5414e14bef6a1aa19b176802abb42114fc2f821cc530c00201a59c58af50b785c1aac6fcf75c9b6069b3efa4818a9cae842238a8066147c0096c95f06743bc73192114ac65d83cc57e4bbd0578c0669257e944227eff57156147d4f8db2826b12c601f1373dceab7bea685dd70486719f1d043abd850572134fc703f209d494be2d48b3d02261c76103fc9677ccce2bd306c64ed3e50f46853595bb8eeeb5577e599b6a742c7b1a4b323b7332cc811a428c6a8c1de91671966f12cc748c51f882865f9c110f31593e2c9870960b7798212d9a15eae6095d4a4d5b514eb1f8e83dda91ff8310ca62ac9cc177ee7974265fbb367b9332907acffc0a6d00124fc8acfcc1698a67a78985d5e7ff25d6fd20c6f4b22daff1b31c3a8d70ba8053f93e28d738b6e0dd15e8c14b464ea846f44d6a106e1f2964b28304780bf796b55dd3c7f8339f6855089c68e4dc2a1165dde5f26f3548b54eacd13a6ad9c97c9ca5f63877ccd3ae7e6b1865088e875b18717cf845cbb49d0ab45374a325e61b660d8dfd6f50b0f20a7f5c06dbaad5fae1a4244afd3da778affbd9c8a0fcd12aa57a9b7325f53d438630b8de0db3e6f07eaae6bc0f7099c0c392d7c560fc4a9f4646c254592ceb2f7e1d99a752a8fbc4cc286f6534515045b9f3d898d99d7631bfe4ff67d39cde25230faecd9d1656e169c134cf3892190964925316a1e2ddf91960e51576ce05783bbd2e454297dc962d66512d207acd6e6b20dc4957f1eb21cf5ee9a525ceadd0dfd4c1d51c18bde35c096b0cd76c118490c0765ef5ebc265d1636b74c80b6b03d9ae1f5f793500a5db02e96819b92348ac5cc3f519552a7450a7c030c5c566af59ec70769c3d1e6b50ab126db6f24b00d5d99a40abe9b00a9b92ffc547ad944f69458249e38f97c0c8e0608744299cedb201d9643eb9e31326eed00ab9e6b5f5ef33c04ae5f73933f3efb6c26fee174d983eea7784b9a925aa20172084dbb82f4e96a47641087f96f120cfa6afe3095c5a339f0b86b4bb910e104d896445a7eeabf1cfd98aa4f8b124cbba7b94ea7bef37b53d7f2ae063e4487e0290c0403590fd4c1ed3225e948e6e12b96e502c7a758d6c0f190e4673392616a466fcdd874611aa25b7d4eeeb66d1bf70f72b30b8cfb5f6e0f9a20e47d90d4202a697ec9f7517920f8a08e31476c1a751aefd39cd4ff9dbba82173c2a178c7ccc32ed5957d63227afe04cb75825ff4e16866f8cdec949fff077e4a57414792cb415fb2cf0203b81a3f2a9ec7419489f3d29733f4d49372bcd5aadc8d1bd8a0b8f79bde2793c782e30d02a4fa9bd4fa134ae8ddb67bfa4989c20a56b1b6ead34b89eb750a9a16bf613c6dfccb25a8207546fbe393cd5f812419f86a68c5883b1b5bcc95224608a99a51644571f376869a27e4ea4dbf08e2e671ed09198a0c66e5f9ef2f2fe7c380e3fa5389946180b9becc7ce8234ee79e689743bce91b9fd574d6daaf5241849e655058f3890cbba0d88aba2ba73624cd81d81ad484a294a577454d03c2fc43731289ff32b5bed91f059f2c9d3602cfe6cd3635f66b1973ced9012da5291e9cf265c7cc80b335b736f35dcac4ee2b054efe83d0e69073f10d788f3adc6c0743ddea4ab1901e4f654ba0630770c3e68041bac91900b294cd56b009d28a6ae9887d5d54fad62ed86c328d0259f8c6510989094501cccf751719ff5c3ba198ae0392c28de1961943ebf5b50276a20864d6bcd9e9b100648c971f2933e7169cd23291511fe9eb1300f94ac6b3385218ad7e66d5dd673d44dd51bd1e25f1862943fee2e7b32ee93d512ec7d47e7dbf67f42af0930ff4470beb0330477e7619305cdf6fc2ba2ae0678941f6038b4476e3d6e4f7f1a57a5d2f1e990dd498df1a982a780ef9dde792835081960d7a439e84503ecb97fbcd556d094f3473a7b8eed2cc53570fc105365d99bbfeb980d991b3b51d99489e844d8b02229886635d9e1205ac76c4a1c6ec0c4ddf961e57263db1e2406ff318341ef66474f6c84aedfa15a8782803fba77330c6ad145e3bc1bc3a21f82f614e25ef8c917e84636a5ba294e2a37a4035ea2317fa4987d3f10235048842dca44734b4b71dce3eadf7641e9adcf5be84b0bd509f74ecec150998cde0ce1286f8d29f237344f27dafc91e3e5bce6221578036cbe1aeb451ceebe7b5161e7030793d9a83d1b346eadea66aace69fb18824f3622dfe2a6b2c2f887d4406861ab56d32f96e09b50bea32f7584b584ffba6c598754fd985f7e65c59f29c6363d743cbc6228ac5638a46568599dc6f24a3972e173478dda7acdf0688e9f0fdcb62e67b694b3984d7aa8cd73cb75787bcdf702726adb4a87c85aad9ea6cc750e2aa8c853cdde78b10a7aa6c00b42da6d7aa96c7a262cf45525d7455f47510a605664c9ec69d5b39a4d3d9400b942d43c7507b239aad124157eed1154163bfddf3ce71cd909c52a1abd8f5138b6eaf5ec72e3b71739863fa5d75afbc9b9df4c6563d6c139e6f755da16b2a459abd38c3145578a7f5cdb494f35835dedff2e9bd4472203f506a5c4bf848c492cba5ef88f2cb5bfaf3143565c1e30c9d06d3ad234c2c0c38bb3751712cb76fe0d2be226b255e6a8360b449a75984b8b1b94f2a6c249a61ac3cc32127b57b08286475f7cc2fe3e90558c48c490e45c7a16e370303a79dd41b668fa2e35a4ca665fe20b0126da24dc511d50ff0863703eb20554d866cf631ee128a69c26cbd6d2f4039ec2aec34db18ba450b7a209cfdab56992672472e666d1320085f94e859d16ab29224d10c3d6bea69a57c9a73746c7b023403f329d10d37a47f2036acf5d1e6b3a802013aace263ccb7f5efb6563f2ed2e2c472b4988b7432f76a662a61c33162e156a2bc124833b2c6915697e5666fe4abd3211f0ebb9d0d1bf2040ad20db337de78b2d4752d50bb7d15ec5a896897fcfc73e539238ae4b19197382018ed397d10ff9d66dc6a3940aba2ce0e61fa6503739f344ea57c2279eaf218a06885585f14a11d52d1fab1508751d5611ec7a58465ffc170f6ccbba8700921dd790d36bad48334d381fa9c1583d1c770f6dbfd583000f721caca5042d08fecb26ecd51287022af9b5942f9d6ca9f9dc3ff886cf11d083ab5c0e6347f4bf454910031fa1e0d046222750ef4445fcacab550da98073a053d8885750d558c108f2f2bf3cd92e6d479b8f0c1b2a65e9f7972d564a185afa72cf250fef6d5d0b8e5f7ec0cf58e61c675f4325ea503106efadc5725f3615da16a43dee80cd6754d0f337a2dec7282fa3d951fbd3595c3ccb5d88205943330819d18e1899b78d94f599a2de1b1dec4bc80d4138aaab13617c0372f89104f90bf992acaccde22e78f31476ca80e521c650df2e33478253e7caf56d120684c167202fa00abeb1a7da33a0bd519a810e3a4d30ca571365f7ba7497e6f2ebc5a7e2076b4fd54bd982df2e496ed70dc80889ec021e4a211cdb798d0b212adb637946aed983fe522bcfd3cbeae9c348b0465d0f1fd4c47a03672bba50eef41f7c57d8b7c8fab5e0d2a359e5bf7729c1d54b05f0bf6cb44a1e538eace796aa03b826716417557212273b62f9981fc0891bb43cecdc6bfa9bd233629f6b70aea5df3e7483e1cc70e88e8080dbdf830f0b95eae7737c6460c9799cfe6945c138826a13686ca0e4ec0ad806eec9938e0719adcb25d5ec87455b919576670660f0202095d09c4073493ac50767f7b9a67f8b0c0908d5228edb9d276a7beeabfc98f9d23ce8869b0603e5117a5eeeb852afd2e5748b12dad15fd111dec400d27a95e91eb36754e76a9b5b04ebea5b50d2028a29a9624a0768fef1bb9efb57e517fc8c1a38b94906fca9f67cc73e4cb924323191ff2c1f9162ffa352038df4bb9bd9cb0234786a9ce21d8d054a2f08f3f76bb6672151eb0a3eac5b77245cbb003e3f4980ed3315fe29fc56081a38a8908b19e57966ef3ef26e2514d8e95090cd0091fc09c020cfcba46aa6d6f62b99f08d13dcd36cdb3d51c3824c860830bbb950b2fa206315d458778e879348610590fa1bfc4f6e4e7501d4a3b950b7418ce3c1c53f716f75ff85325d450459533cbf51570112cbb9d74ef1d3c4f353dc9c61286b6f00c258596aa8e69ce2819e6ff3a0c2cd3d28f9c2d2781201ee9c9d4ad6d224fa053aacbcf9ce2648802955522687b2d8399ce85e5f82e74d585a78a3a3ebbbee9a436235a4393a07d17575ed8dd19c8056c8123c433c7f9f4aa0afe9e638dd3c9c961566b7a057e4726d40ee928aabc7b0fbab6781e93661d596ce6476ef881ef7514bd86151b56d466190103831fa230d54073ebd7af5aaf8c1525da104ceb007cd117bc4044c0a939b2dd36f3c5c74f70a2a34b649f8d00b101c1018e7dac03bd537cfe4a6afa09fccaaf2877070bd0575ad2c90030a30bda4dc4f4ded40df806afec112ce16e3dee6d753a140d97b6ade322d1a9954bc66cd222024b0d97b4be7ca07f8358e4c2253e0b23574a9e9fde5c6ef533ffc59826158a60657037497719f4f4b9f34efe4d789370dd8ccf9214678bc2faace1fd2065a5cbfa194ccaae1a0846c027b6fbcf81a19cc5ee5580ef560e10e9bcae2bf1ea7ffdd94bee198e1938dca0be29c1b0702653d39e939a35e973f699ebdb41aca206bf365d8d5dfc8151920983a0ccd10c45dbef579c299017c9d120e9c3688e10b5038f69c574e0674d37ceeea103d2de38ea245464c9adf2721ac2393aa576ad25db4a6a390191f33b03eeef93e837e99af9c539763255b38f172eeb695f7230d4c8d6336744ee6b7799d7d54c0518e1e4c35a7fc4984e2252b04bb4b7cc9d79e73a3f5e3f6e4a015319e444f62faf6eddbb6f3feb8227d33f68ca0f4efae714078e4360d94b33b62cbd4fb1c215bc1cff901bd86ef18410044206c26f3ed03b92bfedb2500e0d812296807e74e8c16ae0b77979e9e1f8f52b99a774a44db7e1e3525a522ac448b3375ba17f0938f46e3462302a5373549b5a77ab9ec06d0feb47dfb3af0621826294d065c69dc3568b284c203873d3f3614d3d5bc18b544329cc1d0f0848cfde80d0108b09b1c684f0b55e05a80fcb45893396732c913def40f3d470ba1771fed6ddeeba0ce680da771cf749612ca97bee627e8ff714d8710bb06ed68d10ad50482840196aeace207da3f077a0bd8d2984e8c2e62ad32b24d9b644c4dc3626f2dd5c6d077b9662b1f17e050630bf9dffa039c71956265139e0fac858539dac40f2d9d6f74871b2bb6574fa638dbe16d71e7faf170f49113634d20e140a76dc4cde4a0243272a885c1833afe93e2f0cfefb2262c6ec6c42f6b2ed72314ef4f1a98220c7aad5a4c28b740c2f8075020944cf4b733249b9743ce9df4a32eb2119ee57a42790f6effcfea7ebf033aa9ed001371e8415cc505356a188102f4d50a93cd2fd49ddd08d7645caf010d0d5e1264b60f4a34b72a9af3a99a7f9cdd6e322d8c86f1289758bfcfd7b2044d5a4021c3c0906a76ff27fccf17a99ebe907787258eb4c5606276d407a8e3417e1053aa424637757135236d6e9efb64a7d1e57c815a927bdd4aee0f2fc8930f05b77577471647cd223d97bbaa0349db879890bb8f397296e38e38f5188b81b31dd839214b7dc4f9234d295b74b6b5731d015b16a798a30bfe123abe89f3609b9f5f7bf6e42dd0affd6f091b4e47e8afa2939f292e65a9b8636979537f6ad553947746f79b56719da29dd1317563b1e188b22f4fa9ea4818400fb2c270855bde88574b0f167a850ba130673ecc5c86adc3fbb5d840af272031ce275dce71982a1d5f4ad117c73fc156b53267b0d2cc188bba296e5d0e99cac3e5df8133d134434843de3752b012b5b6fc115a5643922cc2128783dbc7c588116e08b90b06fbae3ea97abe9c1c630ce8666a9e659e56c5aa4cf9b95482b9cabca0779c91ca2abe14fbe76f84a3a9fc4ccfcfebef04ba5322aec134f083fb0695359dcaa01fa3192667662c525c78c1c6766ccdc3742b506fb31aa7b37732629b2fa390a5e422208629a9b89a0e726c13d9b88ee4fab5fb998b303c845d59b63d3dba4b79d91bb91ccdf735e1d19784a89eafd232cda930a6826d1929477b10d530b7f490f1ec0f33630e06bceab267e27227dc16af9b34d2f7bb36fe26de4c1ff9da631a3036cb2e4819787c1f6f7686e66c36ca07700c4f4debc507022b2ad2ff057ff3b1e901562ffaa3fbc444331fd9a1bb39423e5ae63487364239ac857783627bb1841d0a09a44c4d3cc02ae2ffb2781afd7ceed840bca04601b8ca5281cefeaff8a1c44a1e25b64e8e5c8f27ba2ae70c3e0995aab7a4497726e6852854c12950b785d5c19fa3a3da998d5d5ca1deba3db7a8d1c8db1be9dc55a032411d812e362b6d7b9f4f272caeb04696d553f1d40f4a63798e872578193692493d81dc58f8a60d0923b791fea137273e437bd0dde0ed13498428a252a5dfba95a5c14235a32dbcdbb67a1d0f213a2aea3f6e3669238aad34b0fe7e717946ec39bf9c7e294e3317523e8f6320a54b465c9cf891f239d63802084ac87856d8c72ec2a9cba51d2ca9ce6e7eca5de7568ed4a285833f4b77a089b988d0eed71f8c7c539b7e117f25cf1bcc2572919d5b10ed0776d631f6899e4145f666556b7967fdb77740888452550c0bb04c2a82a6c20168da1160d7ed04bebb9362b1667e0cfb3f89b19c02f9ff11adda6d04b44409020a6eda61dd0bf17b2877ac531779ee05629cb69f95e433288ba1e700d5ddc4666aede5e89b0640982b763d9957f66c949fd41a2ee882a815f341d9fb233232cdb199270c215e36091eb84d47450945c50fcf7c3ef3125ed789b24aacf25f40b82affba46c9cad089f5f250886d89a91ac6c93c50e28b9eb9e640a93367d06235d818556b118fdc205d307ce0cbff3a8e9bcbe303c840dd4dee3072e5294a5503202a8aa62bb604cdd245089852874e5f0ca38668d4eb9a7bca474e0b1779eab9355d6eb91e080887f9cc328615fbf0b41526082262a90e1743b040c823aa40c8534f4aab8f2c45a05036f6ab716d5bee44b782402bc5dab2d50e73a20a09a82160e48b1e5e06f50c340cd41173c279c9bd2950f3dd77737a7b52f6fa63aeb03e0524a3dd00f225def08f3d648b62210e0d175e97bf7984b653967f45963deb37bdbcbc1400758e94cad4988f84b8b5ca2519fbadd362c29c90661eb8d8ba648f3a72dadd429b2be14c6c078e1e581e09e2d3bc60b28571cb563b31c48a8ff6ddbf33886b1ff8347f9beca13339107e7093db323ccfc3843eaedaf7cb7c8fd5a925d0825bd55352e323f0c50a7cbdb4661e6b0b0f40ab2eebe61837c5169f563045415221e26236f242e45b7cd69d98372060ce3a65cc75012a78d3287cb2a31f7cb9d38cbd6b2b5c2e7ce9c7fd4876d39e8a0d8664073ed07d8929282cfe658b426b159a87eebf7fea7c3d4dee40933cbbc8005c82d4a78853f3fb5867fefc4ecf56673754ca2a1318697ff6e536de3fc93292a8145f1e997e95982765477e3864811e1955dd18efd94a55cf75e921f0bbe33a9724befc94d473818c08952851720e48ff4659359ff5561685e1b4bd7642e6ce77fcc1d84c3d05a1789a8b054b2046fe6a776c5e60242f672b69d9610a51b249b0e843764ff3514721239aabfcfb8d47f20bb9612afa09044bb4fbd32eb8071871c71dc3c6d0b224f6343d872a643f22571c66d86fed86910228a067c38451321ba6cec08a1ab092f0a040f8d7abc5dd9aceae5dca9392bf4db694c16748db4a46bfb8dbb46973cc45546ac6f0f0a15ba9dd7f9bd423be955f7bcd441b8b15ecf01964d6b0cf117be06c7dfeee913109dc7cf97486d862444f2b92ebabc706a1f538cfd303182584fceafba2dca7a2c22942f3a405b8130ce55379d46e7b2b9fbacd29c266ed36f85dc4c2a9e1d30f7cf4ce4cdc8ba24ce17480f58c0421aa5484e8e8696b1b04a360bca74b2ed1428f3eb4cedfbd88a8be65bd1f6696c354c46bc0ba498310b0402e06abe228196337eba0d7745f95b895070f9faab6fc459e659962352efe1eee7632b0ee95a9af5886b2553bd76edfd1a2532c9496823501485637bba12a85efe88495f690c3d6f039a5ed9c95316c3dadd7dc1ab682b38f1c63c20874e699b2a92a1ae46a6adbe6d4bdf7ca93fda9c1cb197656f6cf6a46b1f11e49ca92508451dcbed259029d01c1120448e6b58362e9b0975b66bcbe7196551039593de29a84c11fbf345512b6576cb1961541d73197dfe9c8d8bc4d0d4e74c729db8011598890a9c18e54c9c7862abd1b077974ee7426bd983222554471897b7858878894ee4de33c5e91ec3e5b2f264edc1d9f851ff524ff2d8e2d20f571d4fc9a075b15347d3d21f0dd1f985751c975a6d56aeff8aab8f8c7005b5f84dd93ca13f04c63bf35fc2104b2ab68a80c6cabd379eaac845a6659215ed026bcc4470717b1ae282c582a3785c5ce622776a36629b417303f6fec1778bd9fb92c5a06624c9ef4e4c29e687a1b5990e082072f8b7162e0796bba2f32fab52f4626ab19eab87f97e7197a9a115b2787ed17c6396306e342ef3df0f6f34dc79c0392c3fce8a674bc6888e324ccd926136d4d25f14b8e809862dae407303983463bd7f13a5ae15654df57e767133669970730927b88d6a35624db73ae5a179a7e311e38965c14dfa88b4dcd1e71671424a2b4334d2bd4ef726d556c0c63c01ed2af66cb7c8d88b47554625e756dc5725bbfc22d6f154e32a241c0397c15ec249a208136ea0b2872bf8570104e06e12fbf00bb56dc916667f38141c382b5b427b087d5f8704ec4ba9d3c23f0763beb5418ce621d49b83363304b74a051f72a7fbd79322dcc52c968f40a6f42432be99baf0af5d06f59e6c020ed7ac795d5075c61bb12097ac2bd290cd8b526e0a68f12c75cdcf5fa0f688c7a13cdb1dffaec9693dacb6c17844f8003eb28befe0a3ddc87a79f11f2e00923487c09ad32324255c77a08f00b3787a41d57d1b5111416c4196166d32cfc90a810e43db9893910e02739c3cee3593dbdfe5bc327f304fe0ff092d96442fb323a59904d3a683a63b7e031f80b136a8467e17d97e4cf51e3b1f668a4b398c5e965649434007ea230c7043fe9f28783773c35c5c600d85e4206989c9b677f5395c7544a0c64a5bccb2f40cf08e8d36cb1015de37df36aedf310c4687cc3ab1e8a9de1537d366b3c11400a1ce2e8746fa4520ba43044b09981ac914373c31633a316b36e3a08aca4ed97d059b2359cde96420bbd5d77223f440d7142a44e3a4036650de5904afec10e3eb5c434b6d57bfdd47657164a392ef644d7ce4139ecb5ade2aec2d055d88aa11a93f04a2de6f16de842f5a673220ea4baa6b8d77eb280dedbc38c8928cb357c35c62b13289b3fd3c5c11e8862671e190e6f079d7076d979cf3000c9e087ca3028c8d03f827a38dc1950451073e83a3c9d40cf318ac30d93cf1d98fb71c6efc2d188c7d67b64f9cdca51e085b56427841c80078793b012a5fb8f2213630bf17becc934e56e0cc2b55be2edc21ce868d176bbdf9042dc559bcf02e929a7e69e59c71ed67457f8f0003cc83ea6799b099d07b945785e7ffb2acc90b2e84936e96d106559c563d8f5df5841560f0f287d64decf1f882f77df53c9a75333a6628698486133645dd79e5f701912385a00b94930efd336fdc9ecc5beab6415aef49117eb5e8287276281c4775d3dc84deb93745f66d9f602ed704be38d6417aa3c4a7b911fac715c8ec118277296808d1fd94cf7e1e0874d1087d6401294a671758a1458e0fa761547eb3e3e5c66de0afc14431b0f65d1b78a2a7bcde19b49b48c374f8843a2a0ff83f2fa7f313f3cd58bb8236b48808e92b06d9c6071edee2f66f18eaa5111ecbd9a30bac3f6d978caea2cad7226db36d2e4b1fb0bf9ec61a31cd0b4ea2c5acc82c0e81c098e2c53727026f9f127a6b416b3f58bda357b3fa4c9b4807824c210d9c1262f1a1f32f65280ea2981952c45301ef24a583e7b282246f158cd9ffad5ac8be799be54ce13259ea0d3d7f5dea23372e7875fc5f2121a650ad21f5853e3025b8c51a497635ea1c78682dba05e44ea319366c8b470bc972675973aacee3644549e115200e7f609c0dc0eb8218614531d75cd6dafb72fc062758a1afc7e082b6b55f04d358d068691f468d0205627b206a1b7ee0b3ee2f7aec0581c07b918d07118aeec3345011ced5630418b197705df95b44dfbadffdd0643a8fd02178b0452db8ac5fac5d05a9b25e3b1dd6c3ace4a6b8e7fa6a5665cc05be8798b1ada70d9d307bcb0f6e2c65b4f48f2fa5047a74e031c388ca32eefe139b631c019cc94bdf564ffb2aeee874384444b1288c30f728102f9c6982f74ac7a88b0d28ad6013e7557a28daefaeabc967b14f8552e23300efd7a3dc42a0c75d51e8da0ffe2bfd7fcb965b081b2f45874a6cf8e57032de580f3db4a34c79a202f41d6d44c7fa4f0ba8bdcd681142187d9aec2abff38309d5c4fb11fb3bfff9659b10e858f066eea7786b76d8ccb480e9407b8dbc2901f4766d77d5126ad6499ec043accc5b0c9eef8e7ba8a353a7496824bc1da4fcad223966a73b604610a8480824bb552d44d2a197837c8caa3c2366ad9e8910006f42bb0a9de5bb2579e39558d21e03d996385757237ec7906cd61af5803c03d9c69b785f15a4047db19866cb694b506946a585ff436dcfd1d7c843b3e08630777a25f02d53c582f7500413bf86a147341d764f2b38a3a089f4d42490d6575bb3a5798f8ec671c3c31620e8656c69b31d67b656df476b4795062948efb8a8f1a155cfc693af751159de73422843d349e4e5c4524e51752f8153be94c3d7e83f805d319900a49052a6bc7b2098e3e584a0b0c4f52c36da9590f81affc4f8faab96d241c28dd149a7cc3d6a8cc4d1b10fcceaf0d8f33428a52f84609ec143ccae66efd82372965026c67347700184174ee0854f7c1d13bbec90c024444744b9ff72a3cb53b00e0e34453ae18397cf8d7f60b4db4adf67daed8a69803527e293a3b0d64a0fa4df56410c12bacbb9d46e21cab66046a467faedea565860da8f4bb2da39551c05c31f5047c76d84a48c3d6e76e3e6cf0b502aba6439dc500ddcea3b0b5d18428dbb187fd8e31b8048d346a13eb8ca5f08e31a86707331e553c94386117206ff3cd4d3d85b368978dd0e4ff4596c60b2bc42f5065d214d6769f1569ee4c59bb65ded56ee329928618bd58a97caae8714d1962f70402a441cce3f2de4df00f00e7f7873ebce979cfd3caad253a2af9498562aad245cc26b6a9756ead81b588cb2a074dd790c1023d3527a51a24856151e6533bd967c818bc4feb90490145eb563824fc7a422f52c688c2643701cc830e96fc48019957897a68b659597c00df2352f71b32b5966f83c2a4bd4f3dbc731d5548c9e14099954077a45c19fde92eb884e33bae6b81933e512e365c53beb931a98b068957a3f310dcddc8b2331f00a6090678fa8b8c70655a618731400c8b6891c81fe83e485df6cdea66153552778e18937f7a88887aba42cccddc887c689d3be498e882df5dd25ea1ab34dc11c54ceffc2133016159de175cf93a1af5540348dd53c50b6b9ac7a7db485bd8eacb32fa56c531a30234e71e2faeef414cf9b287454af3bebf5f672c696ac016cc422f31167af3083ee754b667880c0aace6795f43d764b6d5a227479e261feaf459ebbcb029becc4e265ad3ce9e3f26173acc4ba95ac07c43dbf9b201d9b811930ccf2d78980270120af1fb2e736d86bacd040fd6f4b1521bf4c1a3250478a3bf3f02bf490b0cfb662aaf653a7143c0b9625bfb8fbeab42f1545baef91a4be43e23b087d00698cc62783aad5672b27a5b340a3a75edffee66787c3ea869186e4206b126cdca12c89b0ffd60c3db1b0b2b9d4e2cd7e89cf4517ad0eec861505592b94a8f4f5d23b3d1bf04b803bef5aa7ffb0a1b6dc2c96b6ac06d31e1c6601f5a5ae098b0769df88faa54ae6781815d01d0747213a0eb34dbb383537e29e0c0e29bb3234941912e99baafd2e589e426b827adf93893ea012caa38e9b73969b9b7ef8f3c1be6cf97cb171fee3874a410b49f6fe53a003d0147c8aa10fd8c4dfebb93d448248b9634caae17d1640b3b188afff61b67e72c8b709abc8bb24f1c48ef15f9fe5194bd8b5c4e5c04b3a07cfe74fbd8e33e1a745a7c16ae8182625093d8257ab775975d7df5a09f471be6be6e824a1044555ff8446f81e95f66e89a6953aedc597bbc04d8642b4d96b5b1cc8ca8ab0122b34d14d30435497a077bbfc393bad2224cf1fdb93e116174f62678d201bc426cfd18cf5e0b35524f3534cc475e3e3d3a5112e700ce11584c9da6a70b89ac326d7a982cf02db0bbfed659dd300969844c2ae0a26dc8a1e86527d349cd37fd60b680428bbf04f71b95e2c42c4eb8feef7bdcedec9f0d64e89594e7e11699eba7dd684ae2b1cd7bc0eb59270fe77d2eabfb2062cc506adf12c2c3c3db92aee6ef586b6d059049218164359eaf09a0d0cc737cb1bc16183a9d4ce096d1c89f9e3a9fcdcf992a20d7331f31bc7069ccb4858a41e18ba1808032fa737c2363d4aab0cc1dd82a00f51d1a2ac6fd99b9caeaaea2f9b769a95551c9ce7c992bc6b9e4d3efea9261b560c2add7c0a535522e60907e07c07bc51fb3c7b8b7c0525210a0a43cfd02c36e80b66d7e254758ddafb2d3bdd49e2937744590f529b9cff3be9a3680bae3bdb665827d3290849e699649e916cfe12a61ffef60053e279478a8af0ca67eb98f50c089efe22e5609b62666dbd8ae748f336c97db903d312d3faaecce6e26e217a9d0000c7c117416f7d3dd2b9636696f0bca8e2a8e0c76b6490722f2f1a172d7cd8f4935b080e606d1802578091cf3e49abb27c6193c6a0d20b687a110d9b05c5fd377bfa058b2e5bfe6a1e9faffe8bbda007a668250a3459d5f09ff1b92ce7be8981e4dcad54b6bf61563bab97733add885b38405bf9e5aea231ee11ba6517b2d777596997ad5fb27c96858dcebf456da502c81faa9efe1070943d214449b61d92d2154bf7425a88eb71a6513dc1cea4dd5204332bad9ec2388f1e2f6a22a98d2ec441894ebbf792ae02beb40744fcaf6205fa9d801e689a42dffd23e39370125c817869a4633d5fc57f8e7ecf489746880543b73ed14361ed75e828c4e9fc614b2d8a1ec0cd51db0ada3450580fdaf7b121b8adafa24f97bd988a22bf20a383ba623590550219209d8079e08d67995b460b06bcc164af5935ff42c4d72577a6bc351776b11215c825bd7eca69829c05b237a253114004087728120233c3e087cb6adf3d3276cb6bfb279627998cf9ae13a7bd0e4ae3d6a872fb23eddcab61b873bd3f53193fc4d5c08d037a117c6d6caa00b69efaed2c3ce92cf829fede7469ef7450fb6255abf6c69fe72999a5b79ecf76639904788a8b41266874714f1836e6d815c7a1e5cca0db1275dd92f542e6483a44374f50e363bad9a7ec6fdf932d9e1d6a1881029714c32654894d6cd0669a28a9b3c60816e1ef4ee606e20dbc666756fb2021122b0ab146c105df4c0199a31fdfe8439c705f3de45ac83059afc294d8c7f9d196e68ea82855e0c2f113ac1561cb9dda491dabea038036a1c26a74024f26d8652e414e1f3fad4daa286d6267da48e4fa85ea6d1294650cbf85b6f2b5d23c3cf784b6de785668165fa0a57e572e109012eb4183fc2fa914c41ca7fa6e37b5cd9f8f7d5fd95a8543ddc33632bc6505f7bc2534bacc6a07a8649f4a057f0a666fe3ac63a0ec62230971782f113a5082cc94db602b1d25d5522cf6490270aa87a094c56a2fe88440eee2822b496f1d1a7c8486bd4febcb9d4ab10caa2fd244437af6682d0bb3d2cc4ebeb82834dc21eba28a8d8caf1d7f1199bccce8e518204905ce34b700ab4e14a136e4cb175f53395eb9231fab37aff4e2ff94b7ea7b9f47b74f908011f5ad8348052cd746537a46c7fbf15a704b40ea7bf7a658d12467effd1af2ba5984679ce97fad4ce7819ee6588ed593676a05535f2895c970a8fcccb1cceb201a4806d9d686b27e90c1f78fff0745bd06a9407c29ff8017cc64e13120cb99377af38a428a3b21e4862eaadea94dda5275b6cc559e53b29830e75d92e6cffd560aedbf2642f9f26c0d567a17358de6aef81e055d869b3c0db54dc8b793cb699a8478f3b4e27427f2b0c59b2afd5b529ee399bae4a5ef39e380b29a1d2370428af20d8d000234dfc22bb33f044e91020979f995bf90979058711aa0dc9ff9b3bd4e4fc026041d15dddf26cf1eb600acd0862bd0ccf0371842627d687347e24c84bc18c19c3f5371a718a946d3950b5a969dfc69c8261d264e7de165efd709e81d054cbf76dedd27cad8183c8afce08923fefd35bee3b87f81ad495323ca78ba81651928a515d4d448a17b52fb74fe95c78f2c4b233a9ffe71bce879f51b89bf2219896efb4a75ec2e587f03fd3c972f96200c113331da0756ffdcb9ae7ecc7426210084af9c16ff1265c381f9806c25d9e1941b4e53c3808ef4c8096274be3c97af65387c67c1db09ec7d4a6ac374e8e6847dbda0da96c9b55a96af727fdede216ecb3da0533e44e2e3e9ca331005d01899f6e976c2d47ded39616bcbe034b942ee22a1d84cb83c74e0a434e3296ac04a8080bdb160bfae782a2942fa36d99f20d30e0084c0f7cdf29029b80b3d32be14966f3c043e59dfa2249301005797455e6e77a9aad5a8a9b84996beafbd50119ebdf400e786d08fd4bbffc390e7e636f21e1e4d3929b28de800c39116768d40965478072b9334218076ad2847c246add8875eddb229d28f38e395f3f3806100d15a40b33afeb2d89232f67a492ee7af569f10e032f6ee042f64e73902ca449fc6837d10b7e59d1e5f5b7ce1dd0c083dbe626cf82fdd795e3d6900e9ea5d1b7d1a5c91e24cfdeeb1435065807a054ec6d6fda335af5047650cc9c960ae35affffb23ead584c304eb8c8fed4a03334216b3718b8cfd207d3553c109850ebd4c35f82f6f8825824327f923d85fd26a7632c73c341a355748ae98768e554180012ecfc334f668b2d54eb768378a37808e2dcc84644d0cc8da5996cacb9583e14b5efb739790006e7ec095d04fc9b98c2b137f130aef2c67c761d1273a47fe7d3fa3a79cd85ba0183f04ed5ad7bef72d8e7575312fe35ea6ccbe7c102c9008dcb30493f0679c6a528d6c5b180c2b7b3e661dc6c0b50dee21328eb6fa74fc3486fc1c7f2d6b42400a308c8930dbe28544a4543145f9459afc70f3d9b9a87d342ede7a809afa46ef1bfb5ae5a11b84dec05ff3ce436a5935905edbf00dbd6a7e34bfc6e01f6c2b7f359bf37a9326fb75cc7969027dd72bfb9bfd887875a9cabff602bcc456621cd3b02d85a3a948f3b1ef442358b5a3144b4b5b686151591cb2ff738e85f4ffaf1c40f8626adf4b84ca00e1a898de1fe291adcd36ef5ea739bb09665f55586c20e3c95fbd8b2de39e5bd473e7e5a2b2c04818ef2ccbe8acfc2ad6944e93227e2d678a65a0e537559a05dbccaae18b5f102acfafaebe084d661e1d46d9ce674095e546aabbcdea271e4e8259de399fe6dcc6c32a2b28e8d6f4423cc42eece1c60eb2b4d27131b025b826a426b38dc7c046b051cc46cbfac1aa9eb4667c715aca2b80f76791d5ecb777e02da2c36b73593837e862fe12a0ebd4f6f94886068f9d172d42702ea9ed38dda1e195b08f22e3eb0a43dd31483659427f97e8136f91838da2e8c0cee698b8ac1b70a11fe3a522cf7833d04e7b68f70630b4a92cbd1a3822ff911c76bcf8104d44b94303a22b0eee87b04b9c46a866a2c1502cb9e6ae7aa9d7c83804ef7e792927a50e79e2bde9282c7297bfd336462743fbbc870ebb9335e92f884fbac8142975d21860758abb78d153ece3553039a1485db8d69f6c344f6ad9cdb1bc637b9dce32ff1039df48e9c66818241946a816903536f130b93d33e883c95cc5c07aa246159bfaf1e5d34a92513c15e7790e8f6dbd20da7ed5c3eae4f3ff26a9c591cf7866dc54b9bbd180b84232fa5eda41f672ea2f927c051d8ca33fc94a2523432f32ec81ff2c22fbe20b5861d9abcd104d75a8a9b0d0845414165fbb1ddec6b59ecf3e3c2ef7d5e5a8ffade409aeae277b1300850a12ee1b6e1ce8dd5d1362b9b27fb41dbdf21a4c1ac58e95aed38a4cd98154b996b81cbe03dc028b83cb60a32700775c55e6011888c798491933d450f60a4f50a1b64fc4c24183e24dca95a3ffa88a8acb4754260b74179992992d81cb57aa3c52b9cbc3595a9023cab5098dec5e4c3d5790f2c9a72decd5aea653f905d6b466b6f3a23b920ed7cacd6f86b71fe0596f0187d60664c41a97130a278200df99d8cde19757d866fbd9c0a8ef48ae9963ae649a67963e3e09f330c3a9eeae9d52664236be00cd660c86b1833c8b2e1e8dc61bc821dfcfa2ba1f7332786eec1177b12495112dc830e99ea171714b8108199878380b90f0069510ea0ea668c8a7016ec6ff0444033e6a4fd41c9a1bc8e20a0ebcdcdeec11c2f4cc326efbb0f8d103374a721588712ad1da47cde1d9c066fbaa63f4fe2550cc9a8572c00886ceb5589a73ed3bbd1ec558f45144959f689de41a29b48918ba4b88d78078cac1ec2ea4600894046386ed7130c55262376ef6164eb76909888ec9bfc567b8e7ac3c6530f36130c8d068d0071c5d2168631ab9b96aa668f16628edc65dd1b359881a1ef0afc6594b91bfe4e55dad01fdb8b1f223a7571769e36cf85b9c4e3a48d03b71fb741225b1cec26401818620685f3f5dbc74d4ce00ec41ce30843f048408007c5a3a8a64ba8b90a2c87702d20b7974ebd0929797f40fd7a18d5d9d0a448d29ed48343737f508131b07c3fd7780589a23dffd2d595df60a7d28cff72b1685fc3ce79dea7f7643cc61c952b8459bed280df0abb401a90cfd47d1015c0b70d3aadda607f70378c0b3debe5d831eac86ec824b1493aba3e3e790008babe7711aab077b4a411040ba5f2a71cd637823c60963fff6c156f677d2e53b6623a97273bb6ce91f8a7efa2ecb5cc589e4652741fb223a6534bd44f21c0f418a192af87be69b5dc070836da4b1c0d8f34a402448452bf9b2fa1cd4fc78691eac3ace970070098b3088ff577abbbb11eb7591b8c64a60b7cc9a2247f35275e2abc01bcc06a0508cfbdfc4e345e7dd58417559cd8d86ce337a007955d7ee9e3b0b12d16f0efb2ad1fa46142109ce951711c8b8f314888706bd40282ec62d1e5b59865ef804f7173d98cf74c273161ba1116b6a83789cce7b0b6805d2fdd5b4177db80445b6f72d434a264dcb2a02e40da9246ba8233055d8936578737950e44654f1d4b6ccb1df803b1510e392c7f7f4e2c01ce4df81442dfc85525f53b3fa17b3d6c9469bd6bd1fe1af60e499219fee90e24dc8a037ea1375c98beaa0f9cb4e2dea647866f5acaec3b170346dc80258aafabe40b32a90ba7dcb6388300ce90a213ba43d89ba5f6f8a073091ee1bdf3f67bf11f35eb853c38c729454c336031bd9a6734ad29d5477cf68762a1ee6a3dd0d3289aa8dd0e85e7a0f3813b4fbc8cd25ced027b8e6dcf1bf36ecabda93a29080f059de93e690d0a8683a4029638b4a9e725a61cefe99b234822e1ad081afe6f854ff86eadf61c541650d59b6ebdcf39967d7300fc2c2c48591bf4253c6824ffee93e4fe4a905ae7f007897673f193ec6dcb534581ae313dee56af0dc7af2413f95cf48ec4891fb0ca3cc35e0e4d90885ee4b88b808e8eb79f38b9418b68758800b0890770b0ee5a97e2e97444a61e6d1e897d70286b049895297212b11f1c1f5f795753bf9a0f18261cac22303a8703daad69b2ed048bcf0900191ebe6a94a032e2680fed84e0c55055dfaf3bc3429105ed441b2137f663516734ac3bac220bd5e5ac873515e2a966dc0a55c4e2489dcef7ecc0c5f7a5c757327c0c98760c66e71cbbe55c4fba1c31638d61c0530c838cef74222a5aabf1fbe8a5d2ad3ed9fcb344171d088c8c9261fa3797c2095c69ca06b6005af9ec19993eb4edd25a8c0fdade2430e07b0c7c10b8c3d9e313fd92656939eaa9a15b15e895fef080475c3726acd238e26924e5d037578ef7465f8fbe46c8b05b66239b458772ae4268afd3f483712fe702be3eaa35feb012d5cc08ac52c237e774b2ee25b8ceafd1ffca404e0649e0f3afe05e377cdeb965ff2a9c705d9a08fa23adfdec5d0c0e4b0b81e653d76a45f4742bd77247f541653d99207a980629f610b34b2a9d49b20ec1aba8ee527642a569e7072b6b2e47c15afb0407a53cae6d3fa17db58f81cb39dc492e26f04eb9ebd18d39486e90c479806d80ed30eabe4f591450c8ec88b0cff8945ce2a754e1261ffa79da299003d893d3fb75be15c532a439a1c0b5a1d726b3c7f92ce4ed3c0300b4b10c3543b26e9287107cac86d941ebb657a0fa6b87b0f25622bd755bbcf0ad1d65d861a502536f3f0b712815b15e2dfe53311a95fe2bfed034ada55f1e37cb9d8890340ed5bb9d2c7bef80e144c484fe894b6fa89886958fd09b1cbfab8bc44d682f59bc28e6b602cb98219c6b1f85e3a6babbff63255da16bea65139c2b84f1a073e0bfff115813b613472ab2fbdff564fe63d762af0d5511539b0c7059857e25048be8ad96f3931c5983673e4b2c9f625ed40471723468bbc81df1dc036d0f6f981397189d7a77e3c30a9fd184eb83015c7b0e83149b924d903768a5ec95d5b2d45e2827d7152a9f119595562619b97e4eff9728f5d74d2f4a3684505a05805b4415b197968cdd9c7cf934bcd82c3a336291720f8a8170970aa1579f3db1934af16fb23afd0cbf0b67ad32ad8a8200a5faf02d414a540cb998bfb8058660ecfa646905b4b403cbc41aaf0a7eb549874ae958e01d12450c21d5ce11546e4fdbca4349af5e145221930075e74e3a828e7e62485f403ac81da4d9c7b97bbc4853e3d4d4c23fcbe455c98e080237bdfb51a99447abe32ad05ea209446aca7abd4b94ecfd817b3d2a04c35021406c09565240e099c92593f6f32d6719e19b5ae013bd4e126e4dbc029c3a35fa873dba2c33b3fd585426bb09f06e23def6213f8e98b163a4b377bd70051482973db1f0df810da4603ddbe02e7ebb8d2d36a8124fab19f20a8093704f65aa2574991a0d3f4c4546d8bf5f95b08b36b709968db78d9a1392689736017d8acd1a173cab999ca74a750c1db0dedc4c5e229b4584aeb5b69f6aa1c532adc031978607d0b07ebc2317340abdcc50e2526209296ce36d5f5a4b127aea8c955aa9aceec16e1fd666cb45aea65bf3ac29c6f3ee101e9c5ddbe21e239d3f9bb74303a3e9bcb236778c72a4dc34e18742cb2c81c5b846e872f1216326ad31c46955f48a92d357511136a8cd9e0c178a2094a8f4558262070c58ab8ae16d9835f573b32ba5b608144e35ce6d6a0042d6f06ebb309436f7e490ae948068ae9f7264aa01c149be84118730bfd5b43a0eb9ece4a9bb1ab4bbb08b5247ab0c405139ac11ff71bfc23fb7527d8f159fb88f5c9bf5ba5ff602f978349414905a54b496acfb81dc0d3e9c9749b6d6248f6f5b25751bd22ad8221b6f1cf7afc7b5a178a56fb8674e83947cf5cb8edd6870c721250dd761d59e36fd0d698059e18e34fb138a4322553b770ea56db882ede62c959bce9888c9989cd60a5aef136bd527a463011d08327c24c199f8b50771974f4ba730019a330d5e8e913a64fff7660c62c4e792ffd57c258abf9e1cea7d8e489410d41f4441927d702ca6fcd2ca61f2f030251c19c90f0dc6cece675c5b0e34209deb220088eac8af977c9c5b2f2ee45f08e75fcb6d70a6064ca6350b3e85fa802c9dbede95ad1b0f8076a5fcfb32e7b054c5e8775b31c3bf9c21a71da9434f7aa384a3b41dbed837453614e51efdb9d22d8423e003a43c0f8331738fb7995670290cd2ca79216d9f0e7c3f0d04a972f8290b41d5780bcfb962023378d651317fcee9a5112e6ceaab1c4a35f1a5e43489ca49cc28a79b9d7f88df47e57c7850ec4a47d3cfd8724cc4873310d0ac4a9ae0c6f4582ff832a4568cd3867903ae7658693b3a2ba0d3dccedd74877cacafb80086b8efb9a885cf9aab2d69f58d2b646447257fe360807256e04f0b0cb386625c312c190ec7a5277a7c08bbbc6c32edd384044eff7382e0193535bc5cbf7348c03762f4df2918a28afb2f6a668441c2f36a58fb053b900afba9024e51491a21569d87c8c5f028a34338504ad1862b74c7433b99b56e8e9d05117f98999ce286e43bc81ea2466ed3ed604d577bfedf3b820206a5567ed6fca8f570db0950dbf394623d9c88794aad902ea05247d0c599c198f755f00cdacfc429b6931254d7b73c7b007334b7bde180298b034d784094e9aad3cc5328333e1c2671a18ebe510cf43e75d6d3de573cbdc2962c6c17451db42c1bf5abf2dd9f228789a5741b4fd039b849f27af26475d8377aa05baafe8cbf230d20bc82777c9e9a1fac60241faf91d09afdb3b85ad8b4515bbbed37f447d22093310dfb9cf31d245942a844507a0359d09177e5d12f8a22a2e466ba7fd392f6bd24d7127774ef65635b7edfb9478746bf6ef8239d51443bd2453d723a13e1f24505ee554b0fc8c9d7a972756be3274e3a4196175a707697378daf0eb439f8a58450f0534681eae20bad62761ee666ced622cbc9667ce26812e06dc238418b92baa3187fab9c4fd7ebc76b7ac1d62e83050b35d9e73bc98e3cb59dfef6f36a88fbe3053e67850c693dc8fc1b367c3a8097d6f2d5b431a1f6eaf52dcacbfb72cae40311bf05e6bd63c2da0aaa871285232a8bc4768e5a614742739c1d02974c0db2664e2c52b2f957652bf6216696b98046b021013523ba2ec3ea60231a8ec424f6593b741405b5b502c4822913d9d1fcf3dbbd4133eb18a7b061375f11a8a9f561fa9a219e423f88db6817254377d201079633d282e2fa1cd1a1ced46765938b27d7a4e0ee3b572bf1e230cdea7f8d7b1c894d662a4bec7ad5014d5745332fd44d82a60beca19e758285db243f30097c4e1e068040a9d8e67e897d28b50899ebd5f02e3497c4a3b7abb7665e3238b256c50a06b6cb0bb140db0564188f673a6049dbaf9ca6c0d3ad1ff395db02635bae1a92f938dc731f62db0c0c49e5f237d333984db4a7fc4edda1cba15b7fd2e72e5d211cc2e3a20576e29d2f3b10829922a21701490cdc3c00bd381489fa0f0ddb74aa8caba226d93465796456884e9aca2a90becaa3220d40b75cbc61fbcceffe39321149a65b5cee7d2b1dee80a3a78aa2400570c811b3c526bb3a26974d67a9de8f4697d5a3a9a5326673a0ba028b4999b2f98cd7c3b58e6ee5766b64cee48250b9af043d23391a6fa6061b9743591f7a8b51cae80417b557c12985ebad92e22c066ee89f7d7d92a06218379a9c51a493b5bb4264a481186ec2e24641e5f5ed420f4b44fe8fb89eb05fdff98c0fd6858541b19ac66fd55b57c7d619dbd62df2dc1e98c5f2a82971873a65143fd98e030c883ae382dcfa55d3d6ef3bbc75f4c6927b66959b97c10447862fd2902e398923682e5e8f1c422eb7a6eaa9fdd6050a1a244f5c39308b01348de4bb3aec30d6411c0349116bdecea782ab01ae17304e8dd07bcdfdc2381150ad894719bd07eb9f793e860079523fe01c736648630fc110deec78ecb0666798ed06382e474507a469ae197d03b7aaf7cd1f99274203b267e3b4decfebb5036c3fbf8a9ef55220c60d38bcd5f55fa405deed01a8f3e83f9c1a164e93ab1acab41f4c36f99b67a29f43d7a7750745fbe97cb2d3754548491607353f3151ecca11921efd838feb9b504f22811aa1e17c95d4f684554094d051c6550628062b1d76f5d189f51ed6025a906571cf58cf43f519f351ccac0687c29c03b076b2b3b59a3c200b0e1e019a7ab2115bdc4c76218e4c5c83cb0925f244ce580b5feac6e39863f98a971dc73ca967e26753fb03443708423d7894765ae32649641bc04a3287d2990b1abf07d100a6b339fa883f040ef7d196a08fc827733998dd1d4e85969112e37daef1310b092582954a853824cec4e59ead10c8c00e6cd9012b9a6be57d92b435fdeb4a64cdfb353c51623dde732bdf4429a7d5ecb88a66a6c3f440d3459f3ba96c51cc3deb723ccafce98844931ffe8f27f60e3dee2208ec0396bfa0dd581eba762a6b0c78a612d40656dc3578ffa855161587ea8632732ccc70b18ab04901323c8511b234d862e8e5de8e73328f0080927431a74d26d402e004eeb4c4d8c3349634a8840ceb50cce5d077cc601056172531553e74b011f4fa76cb2a0bac5821eb3be9dba90dfeeb030818000ec8c7f2129cb549482c5cfffc4c97a8ed382711ddc67ee8dd4e1ac0c4268a6ac85fe1890d6bd51b655e530bc5ae4a8cd363e1a51cba959ad7dd5c69b4e7f6fd0ebe471a4e9dc86cc69c608c8f5bf1672aa15e62133fd64e179f29f26370b43784bf5a01f56b8e8a96a2a0c7064702d313c58ad1c5130c6fd92663c6e546e9b2c634ed8e93c16958bf4f812061855b549c3b2c6d05e3eb6c53d4233064f027014523a6274e3959dae668edf3f0716b99bd2b6f8ce73d883bb152655e6b7fe2d092821666b4aeb95dc4ff575e162548f907ab4560bc02b52bf9adb495a1b815d434702847010b0cb19208b04a5f3cadeb910d0e9745c9c1adb4d90f6caa5fcb17be3c1b5e171e0bbcc51a3ec3b2bbcdc196b993ce0d456cc6fcd8495039a6228937756ccd344f3c0ff0979373e83a1306fea049578d7a95de22986d16df982db0cdb97e895aa60d4661acf2b595133c16ba5cee0aa32f6748165a94dcf3ed10ad53f4da02f475594e746d50bf07a2be5983aaf5bf0bb19eeea0ad8f1511f08345c96c8b5019fc6de48c0608d4c583cff42dc34b2569476b47213acaddfe86b95d9eb5bd5c4590a853376de972194787bf6214b13c619483c88e0b4308e6aabb854e03ec698c76158bfebfd410a8efea84721947285c1ac29ff53719c7fe821cf4624a9f5c18e4f7fc67329cc054e38c517936de38610b122a4da0404ad712909feff27728b7ec1c5c1ae84caeeb7102fec3092ed3f645a03ba89d112c8a6c9faf7d77bbcdccf63d13cbe816eebf734adc046bdd1f2648f45c6d181c1e989759a7aadd67fa3a6acea996a1eb2c63eb34e8e8f8b3323ac80fce748e51dd784e6b9c544fc9ccf26b66a0a646fdb5a9bf7fb8afdf25d61f8f51a53b76541c94e11dd7588549c5b288003168fbd4885ee2993c8b2e4d10e1f76e46d81124694b91afa941996a4c711a00cbef494ff529ed375b05c418380ed5c866f491dd137e2f0d861ec900081e7efc7720283c00a45ac87ba963dd6d5f4d1e5370f9c4e0b9236339dd772fd04fead7f14aed4b7b6141656ec4d80ae774fad45d6321cf4a7ffa1f732064ad516f14d987f71e967399d1a57d6c8f423d431eb230b2636ed82207db91a33aff1a85ce85568a530468e99a2b5e438e810c1f28ff0cfd04d8d8ab652be425639cd4b8fe728fb05b3ce2544e6236803e2ba3e85298e68e43219982d50db69e2a118a351adf5c6100322f98c02a53a9480f08dd2a844630df58372885bccd08eec8ee13463f08cbf5a697cecdecd03ff7fc40a2ea437ca20581fdf1af082a77cfdf548f7e438a7b507612c881f5cafd282302239cd652e5bc7e0ef9b9b091544b1c52533e0bf9c74be69ca5bc952d71a02b4e528461d15ec220d5d7fcdeec0ee980816dacb074e1dbdb63158ad8b6bd1f87014978c93d1ff8f2de7d82f1dd5fd6c3ba273a0dee5069169a5b0ef843e13de41b00256103c65349d80d3101c7c2fcb68a54d801732f2e6f1e9bdb92710df8b5ddb5720b0e6a411e8e68f1af6dd21fa40db61a65135f3ff5e88ba1dd552d65a93e32d232e3cb9407fc8641cd9cda5f0ed1bc720746ab21f0c35fa03379d0723ebbc13c98f2829865211db8aef224fed1992ca8fe8c45e94b7a7cbd817d8a873ce91f196b889111053b0ca194c936603aebf7d5428f5ea754dcc7fd68eb9da378f6d938fa524a1c52fb062aba64ba3ac6cebebe359cb7c44ac80434b218f40c8c90a1f742e96b3befd7c6ae3c6f733d2e82675b1c82b8cf43234265c5933f2741ab8a6ca86dd3822d0dfb6d9f4958f6d226242f48466fcc1abe4d089e3eda2f4df495b48c802c57426a3f3e895a26744b7f4c1319ba5437506a10d9ae0af07e49b94ed347a6b417c673f5715577be9ee0bfeb64ea8c72d14ce8125ce17f9b6adcf8f0fff1032970598900e3fc1c3d688b93d31666979f25f68432f12ca55953ea7cdcbb83849404bc63ae666d693a3a23d38fc0c8a8b116d876628f0322d928758ddeea643ce4f5ccaaee4aa1c82cdc43c3a69dd51202335502075ecb97dd883b59235d7dbd92b53e6421867b03594db519415bbe84f7b55876c268bccc7857b71e5db6644b56d33bbdb8c392d3d2fb34e1cf4b8d2e6b00218c13cb57b3da3c0d1c87ea26bd93f888c89e8124497e4132d97152b8ea6ea4e0bb8a8b4a6be29f3735415096c668e6e78d232b28dcba57087043952b59423177cd862976f223082c6a861142702166caa2c397e24566b448c3390627b752aa5d306b4d0b328e4ec8484e0c9219d48a4a4e65459d8d5e29e992dcc9ef2dccd337b226466298e36ed4f7db7af4d14a32cfd2bd6d07cc66c0930c8e5d495310cc85c791012b079a1d7576685ad90fc54829280044bec2ddc8a6b6dab933c1f63e3152c014e320955d7b001b8a2a08e3356940989e2434232ddda721c087f3b0b90b91da52dcb9cc984b2d8cbca82220789b83f75cfd775f80286553f32359396151fa818f08974da18c7276423a7834efe39572ebc48f135c451c7670df7eda7d538e56fe82a7132fa128b0f596aa1a6b4634f03032d8cd1790a175a80be7df06bd52f11306e01c0688f90cc898992ab043dca644ff9a05a93eee6adb4cd9cbe594c7b5dafb57700b9d5825c15cfb36411bd585ff13b4b298720c537c82829d4a7da0785712a5b146afdbe71dc03048239591127259cb0e58691fa41bcc3d85b57494a90511afb5075beb0596d532c65251c3a4a5f4d96ad36f1e8c0f512b83696f85d74f5cdbefff64d156345f8d468bc0d038f979db329928e4f415891af4ee39c0e466fe829e6cbb697e14ced3698a19c5fd77d8dd96dbf6ed637338c65109872778313cffecc2d96b6730f93976a848216524e3acd10901a8e06a654ebe280acf70cd1490fe6f9a420ee4959dc94b99b61778636d79348725d84b1349709fe5d8a856c18c34684a0e8b60b4275d01ca49b89387897fc722e4c809a799221107b4da65dbdb2f72eb86026ced946d6cd8bbd4c6ce1c6bb0e28f9335bc937e1402d98f342a14e41d1bab67c840aa0776b3d0ba46502368ee54c3dc692f62c36d6a95771b5c6848e5eb9ae305fc7222a821181f573975766a1b9ba57987d086fc1db8dc7384e84e77a7e70c12356569e4d0dd2505eb0b2ea22915ae34c4efd2cb539a34f580d53771e338691b7a5b30443199cccff8d8c420012566df608850379c01da4a62f104b6666e278a7e49d383427b4426734a6917428a36bb991b948bf0fd55bf56791a59b22c2fdd31a5d442fe14cacca50db4c2ada895dbccc99d660c5fbe5641d632010c8bbf779af2996c136e2ac7da79245e57a1279cc91b63e42adcf2b52c0239f8fe69b68fceb321d574d9efae397fe7b1ef6ddd94a7ac8e23b9365cfdc14292d63a1cfc9711790ccd45cdd7682b6134dbe12a61819fb2cfc52e1fed6e654c0be4eae242d32ce51274349fda70bf8f9818a4a595b3e883d3c807c79f50b802d92a30b4f8acf90d26c1da3e391e85befbbce2946e8d8dfd5d40a9f3abbfb84c529894aadb6d8982c547977f576f01524975674131ee0cdd5bd34b82f8e2c60f3a388df37ca894713f2dee4906166de473943cfb9022788547f31af7e66b813c3932da052b6cbd09c1c50775fc5283235f6215dfe5f5f03e17500df8c650148d83ce0477f0d159a094b644610cbce2a7ebd8ce12e0902e7737077d1feb92f685905809752fea8cd4210c998fdd5de48a294ce8fd929ea92830a3b1dab5ca2702ebfdb929fcab3a6b52c0647a91c15dbe26689ba92d23271bd1e7e61430d29afae5b028cbbcca5e9b21643f33a99880ebf6342fb5265034bea7bc94d78c74b3dec6173a674df41e6e3d0443a346a734a49b4c4fa8dc7d3ecd0ca89edc84406af5975c524efa419cc0ce0ae2dcc0cf6dca62cd62ef76431ed78c3ec09eacf0c01fb99612126f26405777209ff4b442d364a2d1615a6fd20793c80f31e4296c3822b7ed3b13dc94ccd9903abb97e3d36584f2b3b13cc99aaf679a2a643abcba41f66b6cc84a4d36f6495a27928d7afeeb0512bdf3cc0853f169896d61152b93ddfd24a89626164ad23a606e1d8a4aea58226f9c3567fca1534878a0a282c625af2904038ae7fa4b9a00244d217bef286ddf47e7c9ad2a9ddabebc97ce504bc74611fa14e06ca9da54eea557620e0b2f04b3de21f48fb701cacb18c3cf366c0ab4d0aa32f6e52c809d54544850b2dbfa8319a6c5ebd33bfec8782d27025f2abfbdf73d2dd4003aa7b73eb75fb1d9d7919b2a708555cde63fc9e7b0f2b5af2c9cfc6aa03612b0926d142225296bf9fd5461c9267aa485a5f68ceb6b93cf2c33898610ef8953c3bc0c6d2445e83e0e5e8b27f7799ad77b9679fb9f1d6c17572df3844253c617cd2f6d6d35ad295e372903ae05f3db274b45056196c73d2860afa247795b0986e15c3af34e0afb79a8aa4564e8fe81b04f909d43b40a558740802de24e8bdd96d98f7d7faa2a1fe69822511bbd29aeb3e05a7540e3072ba50ff484ab9114cc38574fcc7707637074ccce6384cb0cb944d1f2204dece16864495ac2d80b7db1b226286831209de9253a3714607af2d5c9de1cba30032a29fe368e1d9fbd32185f1ddbdc500633f93eda03d84a5e2e5c621453724005eb09c03aa57290d42aeca509e373fc2995a31ab757a58b9dce916ba51d211004990a240b09034677547f1c15970ba13f4ff52d61db3eb943e80044a83042c9e755172f2801dd2f5f34aed03817ca7292c21b96dda489fffd0a9033c509ac4f290a31a46b66b71b53fe07cf2d06c2fab21b82468ec2f8dcce6c8f87967a1938d6e481e25ceee0e78bc6b2869cc03ee16e3fa19fc0cb6f85f4de1e64924dc98915e0d1f2362d07033ba00a42de588d1e6c1827464dfdadc3f041fbbc07e3ccadc4c4e4cbe8df6e37b1dde083bd73cd11d19000e64c485d3d837a00385a6c6f75947b59c823f244ac24863587ed7257bfadc83195f886e11177149c1c35ca56a57035d127fb63a8012d3c132ce85744f516366b353c55477cfe347127e87b62abbf3193ea7cda8ae066f42285aa1d0d582f520e211027d75386b59e2af7afafe28873d0aa8b6e53caa04bec946b85bb33ca91d19b37f3221cced8ce9e7ce1d50bac880e028100cd5db0bc6eb131bcca80fcc0d3d67c9690223ff9ba5bef80c6ef020e665b2a7a0a785606d6ecf72c1dab2f4a2d13141354ec02986ee0607e55721c452406908a1995ebfe697c4456dea005fe11b57b88e535b5cac2cb3217a29f79d6dd22ef9b228d5bdef1affba6badd12deb8034d8dfcbe6387b0bbec5fbae6216261149b778c30486242525eae4a27153479fc8f9f878f05c28f4bd0f9bf2c16351064da1c0cf79df25bda7465e3ea3225662bf7889c113ab7d3a75bf33bd8900b0952afacb6c1794c42864278c2c3172df934219689d5c17eff0edddd809008573b4b760ee5c52be7ecc7c25c405c0213f7c20dc4b169d2b4de19c03d421c48700f6d917ed6d06666dd3521b05e089b1acb98f53e8673705c59b0215116df196a3dd80802138f9096570485691aa73ae3abe6dbc10109601fc20fb77e9147c621b01c0c6fe97745f53114be1c9436119909e397e4aa7b4ca8f3c6c5b7898cee8d7f0e7c9933bf1e57a54087892691bc20d3840fa5efb30984e7483cd958b73caa3a102196b4329f1c0f2ce8eb8c0d428acb5b0bacf1e8ecc295837f0acf3e8766b93ea0d38368eaf3110225d2cabcddfc2d6d9b1916a992352d15a6192fabcf72d966ea0fcfc83a0fbfa172c744d95443d3d17166fab3ac8f971b6f4395541f608660426fb96b5763319da2a8c8794860e930418a6f09eea2eaecf03ff715bec0aa70eb36bf84c9a2eeacd608bd262992f17a0838da88b11504fe19b2a65e9b08fee59d8aca1cbe44e0bf35d70aa7b73ef5566834843244b48e5be063f00234af39ba769924330e9d8f54553ff630ed6025f585ac1f38b5b71b56281d5d61ca6f8047f35715bec5d55a48698522fc6c4489c49cff1cb7be90413e555f3e6a1c9c5a6732b302a3a877be33d43b567e420d2cb4d5a8b15735a4274be86846270a6fda9fc41a5e6ef8b762afe87442281029fccf7e441c03f87d314d6d1dc6f202d7a0a8ba6b07c8351ae571f604cdf9fc905d0720a9cf74d1bf950fbddc9a8466cab770caf60b11e0469303bdfeb4c7ada6486fb6afc287fab1ca9a1af1a1915c28a4ab81645dc94325ddbd09c6d9511c1a878f9bf600af942fecabba36c7111de7bfced0768e586016403383e929943817f8912253bb64aa877f6fe5a01c3940ba2403f7d921a2576c45fc6f83733ac128f5fb155d634bfbaa68cbddb30484b32a82eca9067dfd68fd411ce8a9efa9269ba2ece4d97987c8fc9fc329a7a3ffb6ef4c2433b38d40af4474b8de577b0da27c155f457b4825ffaaf2193789f2d6e0fa51d0020e0a3aaed7d9bd72aa1943b56ecadd8fdbd65679c9e6e98d24fd46e5b47e8f91fce1986dfa08501f31a5122749d653c0c7a9951ddabfd14ba929f725fdac481ce44dd4563449ce65c31dccba03bdb99014a6adf93cb30a2197d5de3602dd7da46114f5ece9428add1031a203d64fdf5838496a686054f6cd3442c5d73dfb9718eaa9013bdc3b1525835a850ba259a10d85e650cf50035007b0698df75db4e163a4d76c69d824b31a0c9a6c1bfe7d3f9c5c91de169dbeb052418d4c76062bc6ee9948d9a8131b0583ecc709d646f47039cacdbcf6c56144775f9e6f092118d3100dde7d6b976732da05a0a7a68fab281768f41644f0e5715e5b68e7e18ec59bf50b256b75b96de2358f2dc037e2e5e37434f679f803b8cc5fc5fd4a8a275ddaed1198673395f85cf5a67dbd2b9698a547ea33045920587cfa0f53c6f3c3e3e5606ab569504384ab9edf7f3f48d55342ddae240c7fff60d17eb146b201d30eb73bd5de9a7461d40e710f552610ee658348e4e12ea9796d631b0ce425c6043090904fd3907847d5e56494d6f6e304ed99ffcff6ace054d9497089c6efa17831696b7d0127f0991c0baf7813aa3312478221e07c789d69bacd3fda7566b00008e750558a573b95cd12f608d61cd907239fe5351221ef261582cccdd32859bca1d17fb0331b335012c49130f8f7e1ba656cd256b7b36f23459a37283322ed062727fe2a73370c18722725d131fce802c55ae196ce00953d2310cae4bf1630228d978ba2ed49eba94200552d6c4eef3a2c4ec88bb7ceaaefe57ec36306ef3df1a828565ef145bd5824dc776a9fbdca80eb605a76d9ad1e7e4c68d57373c7f4df0389db50887783bb1b8d8762c05152a6809289e5f1b97a5c1eb528b757a8621dcc7b5085f5ee14cf8aacc4c21c563f7e61ee9cf5ed9f67b73cc29c63d772d8ced5ccf79cbc835e8c5ee4114f8d4c7a24d7c421004769a2a46885b5893c9ce240c4c420b6d9b9bb75ca6a19f7106f31174ed6e459f1267a3a0207b0e6bf7338d8ddb63d3d95d772863a87e33a11016eda43f8e7c1ae931d1806f35b2755a4c05e596f534ad258878d60056f8087933663a857587a06054cac36cddac98958dafe25e151aa797bbf7907be203beda49b45b4cfa63d557b65b83b5ad824008b3e5f26ff1a3bf8555058bf3760fbc2f26502bd7a3b10e9c5ab12a88bd7c7aada054854c57540a78f6fff832bd7c38adb244333b85855c00d1e8ae18263908acc279847ab069d889326f1c0a40cc00f4e478e65809cdc7a818d628fed7f6504198aeffd87b60c76774088e8540fbbd61e7243709f7d9c65dbd1c6be36c61fa90807b268c6c03d06fb6b128ade039be3580809c7236344c974f24b6e5843c8ecab564ee477d5e95366f945256394f97812d542c548b959ad426cd583a5d219090167acb96c312f400bea5f4338c37d2d67aaca3794a8f5876bf2bc72e5d80010b49860728185d87002fc5bccefe49539d91f81efa7d2d5dc7859b702db2cfa21a6f85fe8fe163fe1090a0190b65693edc881115d034450f6850d153f66a76b1df07b814c0f9a46746fcd9c2a1670becd6b51c2468ca45a51139878d92ea3ba38d99136b60ba10af84d5c75c6d35ccb9d6dc4992ca0f9d2505086a21855f501f5b4bd999a03db13d40e097ec9ce3df185e5a8e948840abd5656c154dcb0abfe84d8eaa4b1729e0017aa140672cfa1355cb757e151c4567cef66787e37ff2884bc1d2eda3194bab35ed89109abf5821c41b6387597d9f8948dc3c47adc5faa88d8c5ecbea96ca4df93d4644c3ffd970ebe99ffa058e27785b5ec8d5a1f9f02bbcd53c66ee060b17849ec9bc573afb5ca214f492489043c2b77c8bf19bc8c631e1726fb246dcebb69cf6953378def130b708724c9cee167c184d86ef7ba7f918c37d9555613718ba3e7412eef222e6298d84ca2d0410722753f6351dc6b7c98fc3950c6f399756fc48d2e5622ed63740015791db72217f775e9cef33aa5e7306c708e80684d5a9ae6ab9e529024292941096a4a50bb60e5159f524a6739e922b379f0959e9c875a4a0ef22216b5128dc0e55ef27d0eac2799d5a2dcde1b5de1cd7f1d8d81f62d1bef0cd5106c5c7644c1e445b0aca236fec302de9ec8df31424532d745ac11941c9bdeb471db2dd38c741cc34ee504f3ecf66dda1d9c8ddb32a2ae10dfa0425920a7b2d6008719e7090aa8180368e449f03a6c052eaeebb45a6f999e87aaac482213a215bb9d2a67ea200f3721e76a80ebc609a1459e7354ddce16a18bef1a588ba8716a1f49ccfed3cb5a857a45dbacef3b2ac948bb1d3a93d0aaccd29bf17574021ef19953852f274cd2426a3a1689da9abffaed10de76aed1ef95b22d45fd9ad637345dc65a61a3dc4072edc685351aea01b3c56903e5c0e8982fdf34e61319fba158b9827e059cdde2ecb4c0eb1b924d9009523704275ee7dd91770ea82c19bf247d82d9f5fcac481852baf610bdb58af4598c8e9269565900df6a3f9e7b0888864cdb9b3e665cdfcdd7a256ecf0cbcf7d4b42cd399526073ecb6bad18b45946dd8d4a4c4241152695505769470b9014e9a1ca19a779b242e8759ce393922f675b49481330e7bffb168ad05fda30f90ac08288aadcbee508f32823db99c4bb958e38132a20153ab9d55e6d2d9c99a74b8bf703674fdd9abf9761e86197ce104c1b40a046a28770a2b4d3a0048b15eee4ee82f4347dbf85b786c179e4ecf4e097fa1f0841e5143cab3bd296dbc1fbed3902d77c646f87395904a85380504b892795d97d9e8594d80b4d4135a2a9152b8b60d5bc602e0b7a174915f3a1f92503f389ff173eb3454c2ba46fe5257b6201e535a15029f409ea097976e489c7502a9449cec182632d4adb31b6c3af9099edd0afae8e95aaa25d0c29ce5ec0364c84df088cae7694bf46bac9056dd25fbde178e9a8b99a73ba4bb498de04b5513ce0983ace961b8b92ff38850302d0406e4538276df82a8d643254a499f5afc1e04ca22d4ac57f810e7b5796cd055701426d34445e6de5a3a8090a36f556ae8832a371050c0524add71147c59f059716cb69d7947c31298601053708aec76656e5534272acededaa5334f77aabd20d43c7e44d312268f7e658ed2b63b83af61a6e390a38651c85453db310a45b9f1c8bf1b02135a4d180d3bb1ff26e5a0724440b44f158fc8b3b5082787a3abd3d78632a8c50d643e9228555d98f8d278891f9417a7e185709f26fa1ddfba1724dc458ccd638498679bb5d9f7a9680b5749c861bd7faf73bf10b69253e201c9ebd38837f7249a1de65b7fd2881aecae98c0b2a9290957a60661778b626150f85c61fd99932fbff3021f1266202d7f9067b46bd4eff39fc119302b4d76877120a86d177526b4f87acf5dd0ccc97f89c7080527171690dc56be1d05ed11524591cb295d72686ebb06947080a73b8b369ff6e294e085ffecb1680d3d9429fecea7b4367481a5b94f803dea8b025e131249547cb3d790d53a93d48dcacb9a913b82d49926a01c4ca6863fa55e8bbc75a557df84a76b38e46eaeb23df5770fb8c7aa0ccd56fa8a9c62c388af4ca7e5913dd368ac931ed9e4b01baf453a5336724967b20c134f28abd62ba67f7e88eadc012f9cd9bc22fd188260a9e9a0bac28b0fd13d25817046dcb1b2551a0cd4ac706628124a7fe76f67637f781d4a95451f30176c87eb913a56dac13a0e99e79ddb3c19fa15f81ca0e85c931febcc76e317d6e93c0e5c1f30563d961a098081ef7be1b76244e5fd99af700135559f9cd694f5741213ef3de299f0a2bed839f7771b9f84c65fc40e8337e78ca8d61844d51b72acf380ffb85fbdb4bedaba233a1892eaacf7077c9aa711531e565404acfef133536b623a4d5ab534df37b4412ed14628f7efade58c65397e97d7e9a2021a053e425ed983ef6b9ddd9d07117d02f8be6ef37c7233a429bb8e8060775c4591457b6678f7a0f3da49087da9c73e20ab87e3abf17536fb1f66331c04f76fd930126ce5cd9156d7f5fe59cfa35e6ce5bd66ad670456bd99719dc57086ec1807a0289c903d318f21ae00d4aa134ff0a584c7dfddf6dd5e7b6497acf8825e3de6eba82c2f9e15e55039cffa563b821a2cfc0c35e8616335ccdf16692f851c4724e2251694286a3427218c6eb23083299a3cc120fd148de18418f81642a4edd43ca1f46a135b3bbec74b5487ce11210d4b47755817a0f262c76626abd927ecba9e1a44fcb178d036907224ab962ac94b701781ec2e03bf371ef52e251bd864ee5808826d875d086770315f750fc6e00f7a7e9bbf4131a4d720552ed2811e0ea51a162cfac6eb0c65e1c922ab97d8c392f45b6890ecf141251b02ce45b9a4cd3d6b3fcfe78482d6249e4d9c8c634cef578e71d28013c48020ae96c000889909607336367b4902d5dcdb1b88c899fee2105919fe3e0765d3c0847dbf4b377d0754de9fbf3bb3e5ad1fd2fa6c738a9cbbcc9d36fbcddf7b07809762df9f9fc4a5ebf7271c1f3f450a278725fe9dfbbf5e12c8834af242c68ef8d99b7796e8d14ce334e60e28f91542e577cc296a3a08a709b8d0bd01d0713e29aa4b5eee57a0c12ec099ddc14af421b5a4d98e5c80efdbdd2b3e9da1f236d01c11fe64d7be8e3e23b8d6b5f33c957f921130246c47d93b32dcde2c966e7c0f205095f70dc29638b92efbb14f651184621c3a36dcbfa6f68fb6dac275a28507e2bed29a3407b89184221dcb79871f10ea8122054802750fecc25410ab9db75b82ef63b889a1f150f60c6e713799a0ebbe98abe20d239c6e0c54ab2c42f91551643404545724fb97b96acb1a8690dc5a9aab18e759b1f26ff42dd0a560b20b8b63ab44ff5aad8c67fa8365113a9023c0d4be88fa36baec09b3448ae3eb049e857265bd7d3f11397486e3d999fdebb14921a7cd33b453ba595f3628fb1ea44f5a942682a9600299b63aff61defa8669a8a740219d6539631ecefb56017312865a46b9584388ce8351b75976686a9ea591912a2daca3d6e55ed50e931e394c9c1670b094b330e5fd259406475772b12a7edd81718150133283e8823f4cd2494ec2feaefc27fc1fe69aaa031c253d1a499d305cb4176a4b06eea4fe21c6f8d2f15568ebe5bae38bed6d7df9a014d57a4ff86b0c5fc5672326957c740ec20f2741551f4190287ce0ed98bd0557cf5374610cc29cd50f89192fb74203565ed7a49cf96474e03026788521c6f5253ad9c196bcf172eb9bc091faf141ea21a38dc993ca078117406ee32aeecc9ef0d8cba8a107a2ee7d6c8f34694961345cc06866f78954803f54260574902082a9fbb62d306a4da00b60752b1a9e83d103d915a3bf8fbc48b6ee9feabdc1123dd98fb05046f9bb6be21b067c7a78dee6ca99cb501a1b27458d7947a66f7b435859a8793333ed36c14b4d250916e0c185ad712c70b95ad6bc05a16f6907eca4a4a118a1a93186cb326f97280ecd4ced6b7d22382f5faadbdd1d8edfc53621917df679aafe9fcab2d200640f8f4a545df418a7ff0dcb582946cf7a0a3ddae83f16581d644be8a15676e6b055ec652aefd3b80e61314379032ec3d69740e317d467e945c84d5ba49e15dfcedd458e6d62ef9744da21b483364c1f5c6d14a01a6b792c1e60554c3169c88dbe258f96aa31e5d0c39dc54b57e748af3bf01cb65622efe1bfae1ed3fe8ad33705c3b6007c59663f3cf882f43af84665786bcb48fc3bef49556818f672d51b42394d6329674017499838137353676e89f74e05326ced2281e973a97d8cdaaa81d40246b63447aad7cd72241e74872576fee000b070fdc137c376eb995a4a8d1112638f36909d3c75214fad826d6f2438f4da8f1ca1a177d80cb20ed3f32c502eec37f36c70b2b19b27adb2c7db4c6574f69982a004172f991ae017aa200b5d2e36c8dcf26a8940da6455819fa871a3419aee09ca6842fc2ba8aa4732b5ffe51f2e07656e2254cc1c2b462f653d344ce73e7e12322919247113e0bbe6877e407f2592a1d263e0641434269247a6b289e6f36da0c98ef5e67ff6642503decea39450d215264560f6fcf0ae81011a81ad6761d78f9d924ca6b8925e02168bc96e0b3da333ab71cb04b06017d44e83fc23c0b9e79a488143895aebbe2d27d607322dd22fb404cb010b7739b39c320caab555c9314bba3d22b50896e941f6aa6dac87b5757c08c39649055cdea180a2c137c4e5414731010e6cd3b9c3735281fd2e1e2fc8f2c98b4e19e46a456e20eb82205520629e1278e7f53f4062b973ed94875a720a9e6996b108d78a6bbc19a10b198cbfa8ab67d470b2c2d81708d641bb61b61158b82bacf3d8d95cac75147fdf2380009a20c0f616d418544465b41b9b623ca656e6d8146bfa162c81f750342931074d61472ea579cc5e773d7d1e4080800716503e073ae2e1d99eaf8122165d4279fbc2e2c219b299528f9973eb24329ae71ef8f6c00e281e7d367f5644c630f394631ef62e34240619c0dc08df92476cbb428e5b2edddc72f53c065a865e84d0ffc4314b8be5bceee542ba4d07207d63665c428d87bf5c3bfd2a4864ad543e36b505d7facf13285176c8455a5d381a709f63dff62d01fdaa3c7a99e82381e865d9353fbd8597bac6db88837a9590648943bf4d4dbfa89c1feaa8fb65297a74c569d86adcfc06eec57d146bedfb5c66880720e7c4112a5c5f76642f51fb7408062200672862c857997408ac9e3a88ccdd60bb31f130ed5831566efe6558ce52d8263ebce7afb3ba89ac0c142e1a2e591bb13faebe588fd63b7f12077aa3a1d7fe96e68956488e3e4d7d819744e097b632f1162049fbe6de115b121b9bbd426b25aee14b1d48db9ed5b8f8a6e384658522c9318757330d68be1534a48b23d25e71a6b2af053edb4e04146703f1528ba490044fa26ec74cfcaa00a17b0650368e368ae698fa6fb1c749834e1f419313877d354a6a350506e8d34f7f69a15c00e783f4931a0563c7c2bfffee82c5372d3bf51917eb47871cc67a78bcc525b68ac36dbb6537b6071f0b7054b6c9fed3ca423ae8a08e9377e5bbe2f5b0b3c35ff06c80b6e24e5f49baa14d621ec2a0b6809c7525fee7216836f97c0a941eead99c164ee662bbaeb6f1f7ffe3eba21322fe1962ae7af20d250f37f8698a8da1f8a84a34819c1170bb70fa1df6df81df9208ab98df4a16a4d88791319742d62407216c1965070ab4c22c948051723a6f19fa7105eb2c7513485f87369327bca8011270d567410727a53720ed4f1462fb329ede33422522e89cbaf8b89c27d67f8664e3646a6936cee4558b76ece23f883d9a2c6dc09866baa8efe34211cae42a35c328ee7b09e0e3a5fa875bf762dfce7c747571cc3f849ee9cd69662d2e35ce91440c16302cce9226f01589b7693d159de149ef15df546d80365431ca2cf01641ade5e6e81688b3ade26c75fc81a4695e1a1dece4d40a704961c808f4ac635d44335ed2f1cb1802aeb460e775a8b2d9bc73b052ee19ef10068f79929a3a9f91122d4257cbe587d858b9dbadcf6330fe7407e3b4cab286fa8bd9a8019e848c32da3dce8f9fdc41dc201600805e6be2e7dcf372ff17715e24a8f4ef3c41ae36343d558fd25e073604adf3dc0d4e936ec8f7a3ccb15c78d2ec9b548faa7bd4747bdb17d794305d0517125cd114e70176ea2b7989f23f3155fe9f25e406c1f27274681a599c399619ee9630f76c14e689eb717ed4c0b2331c1f48c23404b66b74c86cd8b42a0ec81a83243b17f5b3788c74b794445db43657b57887e1142b5499fde59c7d30e6a1c32292021e90e6a41c547a7313617698fa34836377c0e374522d1fc96ed3af657cda60f409b5d080d4268bad9129ab4afa635c0a432597422b7c81efb4632cfd6b0a4642748b4b6525663227c34dac45921f884eac680f369f7c1ac0b1150b9670b7c99a4af795886ad06c5a42349616c4010f8c002f2583310a749888817fd1d74fdbdffc28329e10ec827344135ec299b3625696eb90bd62eb625fb908dbaf38af4c536876823736e738fc6c8f0cb688776478ac853adb7f9cd819294223857756758e1fd2cb1bd2d25283240a64909286373fede3d33bb0d7900da9ea87995974362b6cf1f1ee94d91d89eed696c816bac15a7a5a1b52811d9fd181185951c101a2f6449e34a6164a02f2f546af9dc7221d181e96af3eb2e6d10b1b5e2102a5ab883ec34caa9d51560615ff876661339c7a46ff145354d47f2947fc8538afeb45ba20885015728aa8ec9a2a272c4698902056096935ea857ea5ae5e5630444bce410534aefd209bc9003bc54bc0c10529fc43dc17f5b24ca5a4655b3a0b889c0501fc7729be6eacc9c0ddd6a2191ec6195e4293cb2c730d662dbed540ac5d30278e7eb0593968c7d5466f21c3c660d1a65c31b9b1cf2a4579100cfa8bc94cfe56b87a8f9e55dc0be913a42b2abe79e6f2bbc2c2028b72192be83f185c92eec57b64772770611be09af9ca383cc78c2951a728ad825c87a04ba6db5451ff4fbb7de710c926b191434b9ea855b54cd0944ca5d919e126dfc13ffcde601b4b7ccb51565ccd60891f051e92deb98f1094bd4f542d37217fb5aa68389c2016ece8f55ca0dd9d447263e69d1fb624379bc207bbd8139cb534713096c2b02cc5ffcf2a7ba0c97a41e66becbda24e540f4130e6757d4e6842e8c515d1e12657fa8aed75132937ec1972b19f2667f09f6e622a25d33b4b94cb4d3ef44faed916d3dbf4987fbce254272fc1b2008cb64b3bf5660b1f2b4ef68f06dc6e613ff72432a6c7bea86509352b661e77453588a291404679623924bfc6f89744830661a01eea2027d1b6eee3f52a496f0aed0435be0878fd60a0aea7bb3d1183ea1dcc1e62098b2291a92ed9cae638270d4cc32510ad0e7c45b8e510180812ef1148d3cbcfaf274d89bdb44e3b4b4effc42a59266e265eca8a78c241b8769628924cd76163e7b9a53ee6d95a85a385837d861e991793ea1cf5ab001b38d397a891cbfc5df3705a38e275ac1df14db0b45be73ebda21472a42d0fe558c3985161a9bf9ec44a5c3dd13d907d42e7c190ac9a3819084a2a5c82adf8b8948015a8654c50a8d64acf0d732b7e2cd70b127bb4ba937acff8d7d9be3434869a42299782807b864034505f11d78cc7789be0374ad6d633e6c9ef6efdf0336b1ef85407fe7ab7fd4226599622cef694d547a72e3e5f085c963f79268f42b5e4d11ecd52e2247ebd2419f74e44ad431207f9a42df536caa421157703f01f5b041fbfbb05bfc378fa088883363b00ad42181361335b57727da26bab40ec402583bbb74c58d953c39df43766413d9bd5112927c835a41a9713498186d60d0ff068581a72b85c90cf2c48af226077f8bce6b6c7fabc9d68aae6e17481340b5f47ea6650d6d810ca9c64bd4ccca251b9d5792ff4271969e0d5d4c84131f30b12f0819c380272503519b2f9bc113072efc3dbf84b65224342b0c4150894c32c095e22b02df2220b50badbc7b8e2755ff7761cfbd3087cfe8dae43835a067b47f25ce737ff7b3a22eccba9c126bd16c45e0b62996ee78c616acbe6f565aeca91838269e49f195cc461ea33bb5bd48eee4c4a5e4c8044f9c93fc38f69c4cbcf5f632a015d28b0e8d2b18c1c0a6c9e7be40b7e5dad2313e78d1aa1f7346a1aa90166664705b64c5b5a904ad99887299b3bbd74a9d34f1a9ee516c76707740f3fb458a6657c3a70395cc72c49ca70f73b04f13d0d78883c3be784f74ef644f17aebda5f54c96f56216333d3e22e3f3d431c5b4d73cc46f79821b85259c67e9591c554a67429702f7098ed954f6d9033954199b026cb5d60ce444df5c0402ea9b56b27b752b940197bbf81d17462c8c8d236ad4bcd780f9d7be2cb9a9fef1a424526a74f8720dbbb6992bb7f9c2d5257970d1e65e69bb1ade59dfde2bee83bb06bc87094a078a67d4ec49aa7423c1ecd3ca6b0b7e560c0132e5bc4bb2ae29fa74f370504ddc4be3d676860b379a45e943c7a4288a759e8609acfbe1b901976d813dbc1dbf7580f5a11fca06a4073f88b6a4dae030c66a688fa8d1384b2457b201604401c48d4f3fa6c574fa21f076ce42ec09ba4aac9f868f375e64e9c3e0b6285bb9f48f79e2f9fd0ce0d814077dcdfe39dca793da1bea2b1d499066770effee8471efc920207abd51fa01aa06ad3fb945a3fb524b823ceb3f78a7fa1b9aa0342f1661c29a189377d4d56bf9f03522395198b2f27eb4f6ef1dab10938fb6c704779ab2303750950277452f113339c32c0b02c472be3ad0f891b76419ea02cf02ee2390a86640730fe720c38ca5661c9df463116d6c98393795f8c7dec9586e6e5c0febb6a7262a5e414f4b635f61c7e6190f099869005b86006d33a97b7ef8029166d4f5b4a2b06c782d8575aa9c34ab183ef03a21254de638d1f77cee63f5ccc0794fd5335c39dfea4783c560f901b95fdc1af0f9e43f300b90a6bba6b32deba74a498d9daa5f6b400e5982bfd0a45bc0632ae92ea446d6d12683aa6c02be66531adc382b2abb0902019ace36fdcf30fb1f05bfc923a04beee5e4df9aad7de8b44e6969957c19b9fb85833d8df10c0a21c45e4ee8f06ceea495b8694bb9322f448bdcfb9a00e07058a5076366e2eae14c44223ac4b3cd179a57aeb1ffa1e53562d67d7f56cae05480b8ef51a0ee45e992658740cc3ecd8650253cf8ecdf3157b91bc0e35f4d31f4de5093eb66954db6ca8c9a2f5408d2d3f25785c5c16c5c1dc7169d430d6970661fc3f57708e516ddcaecf84c4c4a8b8c304a322d0fdae44a05ae0351e373dd2308a7b5fad9635aa7868472d975f331fe1019c134ba108106c2d4d97bc05f482e1850ee718eae848a3814d4753c95993557a781b9ba3a082983cd630f193211967b89f65370313d9cd8a1f77797f8df3b93126d6ce374a4683dd07e7272c9014aef09e55901887a9c7952db2dd9b0b9ee6e5a4aea56fe6ad0f43e3167a64f68d03a319c12c84f813e6f638a62e24c25da078a22535374b5c7aa4dd219f61b28c52b3bc849264d03deaf607e465dbf50189401e4433d99fae21c9e2ab575b2de1bba5cc1e8bff594c426f3053169843d302d594e7f5fb7f8ed79159b125f4c4f9f715a23ae5b2f752dc3912b55d49aa6feabde23598927eb5d11256adbfdd6f40a9e92f5b6369a2f85c3834ba18181b731f7b882a5cb5d724b0]]></content>
      <categories>
        <category>学习の历程(Journal of Studying)</category>
      </categories>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
</search>
